<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://limjoonchul.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Algorithm/Solution-StockPrice" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/23/Algorithm/Solution-StockPrice/" class="article-date">
  <time datetime="2020-10-23T09:46:24.463Z" itemprop="datePublished">2020-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/23/Algorithm/Solution-StockPrice/">AlgorithmSolution_StockPrice(주식가격)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Algorithm-주식가격"><a href="#Algorithm-주식가격" class="headerlink" title="Algorithm - 주식가격"></a>Algorithm - <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/42584">주식가격</a></h1><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><ul>
<li>초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.</li>
</ul>
<h3 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h3><ul>
<li>prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.</li>
<li>prices의 길이는 2 이상 100,000 이하입니다.</li>
</ul>
<h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table>
<thead>
<tr>
<th>prices</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>[1, 2, 3, 2, 3]</td>
<td>[4, 3, 1, 1, 0]</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><ul>
<li>1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.</li>
<li>4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.</li>
<li>5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><h3 id="내가-구현한-코드"><a href="#내가-구현한-코드" class="headerlink" title="내가 구현한 코드"></a>내가 구현한 코드</h3><ul>
<li>처음에 내가 구현했더 코드이다. 너무나 쉽게 구현했다고 생각이 들어서 다른 테스트 케이스를 넣어서 기대값들을 예상해서 출력을 해보면<br>기대했던 값들과 똑같이 나온다. 그런데 프로그래머스 채점을 돌리게 되면 맞는게 하나도 없다.. 완전히 잘 못 구현한 것 같다 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.stackandqueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionStockPrice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>])&#123;</span><br><span class="line">                answer[i] = prices.length - (i+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                answer[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> SolutionStockPrice().solution(prices)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="다른-사람의-풀이"><a href="#다른-사람의-풀이" class="headerlink" title="다른 사람의 풀이"></a>다른 사람의 풀이</h3><ul>
<li>다른 사람들이 풀었던걸 보고, 다시 안보고 구현해 봤다. 이렇게 하니 모든 테스트를 통과했다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.stackandqueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionStockPrice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[i] &lt;= prices[j])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            answer[i] = count;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/23/Algorithm/Solution-StockPrice/" data-id="ckgm2mnam000gvwu2a318bhm2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/Solution-NotFinishedPlayer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/23/Algorithm/Solution-NotFinishedPlayer/" class="article-date">
  <time datetime="2020-10-23T00:31:56.512Z" itemprop="datePublished">2020-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/23/Algorithm/Solution-NotFinishedPlayer/">AlgorithmSolution_완주하지 못한 선수</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Algoritm-완주하지-못한-선수"><a href="#Algoritm-완주하지-못한-선수" class="headerlink" title="Algoritm - 완주하지 못한 선수"></a>Algoritm - <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/42576">완주하지 못한 선수</a></h1><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><ul>
<li>수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.</li>
<li>마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.</li>
</ul>
<h3 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h3><ul>
<li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li>
<li>completion의 길이는 participant의 길이보다 1 작습니다.</li>
<li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li>
<li>참가자 중에는 동명이인이 있을 수 있습니다.</li>
</ul>
<h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table>
<thead>
<tr>
<th>participant</th>
<th>completion</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>[leo, kiki, eden]</td>
<td>[eden, kiki]</td>
<td>leo</td>
</tr>
<tr>
<td>[marina, josipa, nikola, vinko, filipa]</td>
<td>[josipa, filipa, marina, nikola]</td>
<td>vinko</td>
</tr>
<tr>
<td>[mislav, stanko, mislav, ana]</td>
<td>[stanko, ana, mislav]</td>
<td>mislav</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><h4 id="예제-1"><a href="#예제-1" class="headerlink" title="예제 #1"></a>예제 #1</h4><ul>
<li>leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.</li>
</ul>
<h4 id="예제-2"><a href="#예제-2" class="headerlink" title="예제 #2"></a>예제 #2</h4><ul>
<li>vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.</li>
</ul>
<h4 id="예제-3"><a href="#예제-3" class="headerlink" title="예제 #3"></a>예제 #3</h4><ul>
<li>mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><h3 id="내가-구현한-코드"><a href="#내가-구현한-코드" class="headerlink" title="내가 구현한 코드"></a>내가 구현한 코드</h3><ul>
<li>내가 구현한 코드인데 제한 사항중에서 참가자중에 동명이인이 있을 수 있는 3번째 케이스에 대한<br>구현을 어떻게 해결해야 하는지 생각해내지 못했다. 고민하다가 다른 분들의 코드를 참고하기로 했다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solution</span><span class="params">(String[] participant, String[] completion)</span> </span>&#123;</span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; participant.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; completion.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (participant[i] != completion[j])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == completion.length)&#123;</span><br><span class="line">                    answer = participant[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFinishedPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] participant = &#123;<span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;ana&quot;</span>&#125;;</span><br><span class="line">        String[] completion = &#123;<span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;ana&quot;</span>, <span class="string">&quot;mislav&quot;</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().solution(participant,completion));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="해쉬를-이용한-방법"><a href="#해쉬를-이용한-방법" class="headerlink" title="해쉬를 이용한 방법"></a>해쉬를 이용한 방법</h3><ul>
<li>해쉬맵을 이용해서 구현한 방법이다. 해쉬에 입력할 때 <code>key: 참가자이름</code> 과 <code>value: 인원수</code>로 해서<br>그 이름에 몇명이 있는지 hash에 입력이 된다. 그러고 나서 completion 완주자를 반복하면서 인원수를 빼주면<br>인원수가 0이 남게 되면 그 사람은 완주한사람이 되는 것이다 그래서 0이 아닌 값은 완주하지 못한 사람이 되니깐<br>그 key 값을 반환해주면 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solution</span><span class="params">(String[] participant, String[] completion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Map&lt;String,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : participant)&#123;</span><br><span class="line">            hash.put(name, hash.getOrDefault(name,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : completion)&#123;</span><br><span class="line">            hash.put(name, hash.get(name)-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key : hash.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.get(key) != <span class="number">0</span>)&#123;</span><br><span class="line">                answer = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFinishedPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] participant = &#123;<span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;ana&quot;</span>&#125;;</span><br><span class="line">        String[] completion = &#123;<span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;ana&quot;</span>, <span class="string">&quot;mislav&quot;</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().solution(participant,completion));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays를-이용한-방법"><a href="#Arrays를-이용한-방법" class="headerlink" title="Arrays를 이용한 방법"></a>Arrays를 이용한 방법</h3><ul>
<li>Arrays를 이용해서 participant와 completion을 정렬해준다.</li>
<li>그러면 둘 다 같은 순으로 정렬이 될테고, 순서상 같지 않은 참가자를 반환하거나<br>완주자는 참가자보다 길이가 1작으니깐 i를 반복문 전에 로컬 변수로 따로 선언해서 반복문이 돌아가고 순서상 다 같다면 조건문에 걸리지 않아서<br>return 되지 않으니깐 마지막 i++해서 완주자 목록에는 없는 참가자가 완주하지 못한 사람이 된다.<br>그래서 <code>return participant[i];</code> 을 해주게 되는 것이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solution</span><span class="params">(String[] participant, String[] completion)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(participant);</span><br><span class="line">        Arrays.sort(completion);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; completion.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!participant[i].equals(completion[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> participant[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> participant[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFinishedPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] participant = &#123;<span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;ana&quot;</span>&#125;;</span><br><span class="line">        String[] completion = &#123;<span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;ana&quot;</span>, <span class="string">&quot;mislav&quot;</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().solution(participant,completion));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/23/Algorithm/Solution-NotFinishedPlayer/" data-id="ckgm2mnae000avwu27muydbsn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/Solution-PhoneNumberList" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/23/Algorithm/Solution-PhoneNumberList/" class="article-date">
  <time datetime="2020-10-23T00:30:56.655Z" itemprop="datePublished">2020-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/23/Algorithm/Solution-PhoneNumberList/">AlgorithmSolution_전화 번호 목록</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Alogorithm-전화번호목록"><a href="#Alogorithm-전화번호목록" class="headerlink" title="Alogorithm - 전화번호목록"></a>Alogorithm - <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/42577">전화번호목록</a></h1><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><ul>
<li>전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.<br>전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.<ul>
<li>구조대 : 119</li>
<li>박준영 : 97 674 223</li>
<li>지영석 : 11 9552 4421</li>
</ul>
</li>
<li>전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.</li>
</ul>
<h3 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h3><ul>
<li>phone_book의 길이는 1 이상 1,000,000 이하입니다.</li>
<li>각 전화번호의 길이는 1 이상 20 이하입니다.</li>
</ul>
<h3 id="입출력-예제"><a href="#입출력-예제" class="headerlink" title="입출력 예제"></a>입출력 예제</h3><table>
<thead>
<tr>
<th>phone_book</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>[119, 97674223, 1195524421]</td>
<td>false</td>
</tr>
<tr>
<td>[123,456,789]</td>
<td>true</td>
</tr>
<tr>
<td>[12,123,1235,567,88]</td>
<td>false</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><h4 id="입출력-예-1"><a href="#입출력-예-1" class="headerlink" title="입출력 예 #1"></a>입출력 예 #1</h4><ul>
<li>앞에서 설명한 예와 같습니다.</li>
</ul>
<h4 id="입출력-예-2"><a href="#입출력-예-2" class="headerlink" title="입출력 예 #2"></a>입출력 예 #2</h4><ul>
<li>한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.</li>
</ul>
<h4 id="입출력-예-3"><a href="#입출력-예-3" class="headerlink" title="입출력 예 #3"></a>입출력 예 #3</h4><ul>
<li>첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><h3 id="알고리즘-풀면서-배운-점"><a href="#알고리즘-풀면서-배운-점" class="headerlink" title="알고리즘 풀면서 배운 점"></a>알고리즘 풀면서 배운 점</h3><ul>
<li>내가 구현한 코드는 이중 반복문을 하면서 같은 값이 나왔을 때는 <code>continue</code>하고, 접두어가 나오게 되면 false를 반환하도록 구현하는 풀이 과정은 맞았던 것 같다.<br>그런데 테스트 케이스는 통과했지만, 효율성 체크하는 부분에서 시관초과 실패를 했다… 다른 사람들의 풀이를 보면 정말 간단한 문제였다.<br>핵심 부분은 <code>return false</code>를 바로 하는 거였다고 생각한다. 이걸 바로 사용하면 더 이상 코드가 진행되지 않고 끝나게 되니깐.. 결정력이 부족했다</li>
</ul>
<h3 id="내가-구현한-코드"><a href="#내가-구현한-코드" class="headerlink" title="내가 구현한 코드"></a>내가 구현한 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionPhoneNumberList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Boolean&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phone_book.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; phone_book.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phone_book[i].equals(phone_book[j]))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phone_book[j].startsWith(phone_book[i]))&#123;</span><br><span class="line">                    hash.put(phone_book[i],<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    hash.put(phone_book[i],<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash.values().contains(<span class="keyword">false</span>))&#123;</span><br><span class="line">            answer = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumberList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] phone_book = &#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;1235&quot;</span>,<span class="string">&quot;567&quot;</span>,<span class="string">&quot;88&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> SolutionPhoneNumberList().solution(phone_book));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="다른-사람들의-구현-코드"><a href="#다른-사람들의-구현-코드" class="headerlink" title="다른 사람들의 구현 코드"></a>다른 사람들의 구현 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionPhoneNumberList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phone_book.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; phone_book.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phone_book[j].startsWith(phone_book[i]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 여기서 return이 핵심인 것 같다.. retrun을 해주면 더 이상 진행이되지 않고 끝나니깐...</span></span><br><span class="line">                    <span class="comment">// 대박.. 이걸 생각 못함...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumberList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] phone_book = &#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;1235&quot;</span>,<span class="string">&quot;567&quot;</span>,<span class="string">&quot;88&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> SolutionPhoneNumberList().solution(phone_book));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/23/Algorithm/Solution-PhoneNumberList/" data-id="ckgm2mnag000bvwu2002k7t2e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/Solution-NumberKth" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/21/Algorithm/Solution-NumberKth/" class="article-date">
  <time datetime="2020-10-21T12:28:39.658Z" itemprop="datePublished">2020-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/21/Algorithm/Solution-NumberKth/">AlgorithmSolution_K번째 수</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Algorithm-k번째수"><a href="#Algorithm-k번째수" class="headerlink" title="Algorithm - k번째수"></a>Algorithm - <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/42748">k번째수</a></h1><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><ul>
<li>배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.</li>
<li>예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면<ul>
<li>array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.</li>
<li>1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.</li>
<li>2에서 나온 배열의 3번째 숫자는 5입니다.</li>
</ul>
</li>
<li>배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.</li>
</ul>
<h3 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h3><ul>
<li>array의 길이는 1 이상 100 이하입니다.</li>
<li>array의 각 원소는 1 이상 100 이하입니다.</li>
<li>commands의 길이는 1 이상 50 이하입니다.</li>
<li>commands의 각 원소는 길이가 3입니다.</li>
</ul>
<h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table>
<thead>
<tr>
<th>array</th>
<th>commands</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>[1, 5, 2, 6, 3, 7, 4]</td>
<td>[[2, 5, 3], [4, 4, 1], [1, 7, 3]]</td>
<td>[5, 6, 3]</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><ul>
<li>[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.</li>
<li>[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.</li>
<li>[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[][] commands) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.length; i++) &#123;</span><br><span class="line">            first = commands[i][<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line">            last = commands[i][<span class="number">1</span>];</span><br><span class="line">            num = commands[i][<span class="number">2</span>]-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = first; j&lt;last; j++)&#123;</span><br><span class="line">                list.add(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.sort(Integer::compareTo);</span><br><span class="line">            temp.add(list.get(num));</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer = <span class="keyword">new</span> <span class="keyword">int</span>[temp.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;temp.size(); i++) &#123;</span><br><span class="line">            answer[i] = temp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberKth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] commands = &#123;&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> Solution().solution(array,commands)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/21/Algorithm/Solution-NumberKth/" data-id="ckgm2mnah000cvwu27ue2hrdr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/SW_Enginerring/DesignPatterns" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/18/Java/SW_Enginerring/DesignPatterns/" class="article-date">
  <time datetime="2020-10-18T06:59:16.045Z" itemprop="datePublished">2020-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/18/Java/SW_Enginerring/DesignPatterns/">SW_Enginerring-DesignPatterns</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="디자인-패턴-Design-Patterns"><a href="#디자인-패턴-Design-Patterns" class="headerlink" title="디자인 패턴 (Design Patterns)"></a>디자인 패턴 (Design Patterns)</h1><ul>
<li>디자인 패턴이 어떤 것인지와 대표적으로 사용하는 패턴에 대한 사용법 정도만 정리했다.</li>
</ul>
<h2 id="디자인-패턴이란"><a href="#디자인-패턴이란" class="headerlink" title="디자인 패턴이란"></a>디자인 패턴이란</h2><ul>
<li>자주 발생하는 문제를 쉽게 해결하기 위해 제시된 재사용 가능한 해결책<ul>
<li>Don’t reinvent the Wheel (바퀴를 다시 발명하지 마라)</li>
</ul>
</li>
<li>이미 해결된 방식은 해결된 방식대로 해결하고, 새롭게 맞딱드린 문제를 해결하자</li>
<li>소프트웨어 설계 문제를 쉽게 해결할 수 있도록 패턴화된 설계 방식</li>
<li>팀원들과의 소통을 위해 디자인 패턴 학습이 필요하다.<ul>
<li>팀원들이 싱글톤 패턴으로 해결 해주세요 할 때 이 패턴에 대해서 알고 있어야 하겠지?</li>
</ul>
</li>
</ul>
<h2 id="디자인-패턴의-구조"><a href="#디자인-패턴의-구조" class="headerlink" title="디자인 패턴의 구조"></a>디자인 패턴의 구조</h2><ul>
<li>문맥(Context)<ul>
<li>패턴이 적용될 수 있는 문제 상황을 기술</li>
</ul>
</li>
<li>문제(Problem)<ul>
<li>패턴이 적용되어 해결되어야 하는 여러 설계 이슈를 기술</li>
</ul>
</li>
<li>해결(Solution)<ul>
<li>문제를 해결하는 설계 구성 요소와 구성 요소 사이의 관계를 기술</li>
</ul>
</li>
</ul>
<h2 id="디자인-패턴의-종류"><a href="#디자인-패턴의-종류" class="headerlink" title="디자인 패턴의 종류"></a>디자인 패턴의 종류</h2><ul>
<li>Gang of four 패턴<ul>
<li>생성 패턴 (Creational patterns)<ul>
<li>객체의 생성 방식에 관련된 패턴</li>
<li>Abstract Factory, Factory Method, Singleton …</li>
</ul>
</li>
<li>구조 패턴 (Structural patterns)<ul>
<li>클래스/객체를 조합한 구조를 가지는 패턴</li>
<li>Composite, Decorator …</li>
</ul>
</li>
<li>동작 패턴 (Behavioral patterns)<ul>
<li>클래스/객체 사이의 동작 분배에 관련된 패턴</li>
<li>Observer, State, Strategy, Template Method, Command …</li>
</ul>
</li>
</ul>
</li>
<li>동시성 패턴 (Concurrency patterns)<ul>
<li>Scheduling, Monitor, Lock …</li>
</ul>
</li>
<li>아키텍처 패턴 (Architecture patterns)<ul>
<li>Model-View-Controller, Model-View-Presenter, Model-View-ViewModel …</li>
</ul>
</li>
<li>기타 패턴<ul>
<li>Dependency injection, Lazy loading, Mock object …</li>
</ul>
</li>
</ul>
<h2 id="대표적인-디자인-패턴"><a href="#대표적인-디자인-패턴" class="headerlink" title="대표적인 디자인 패턴"></a>대표적인 디자인 패턴</h2><h3 id="싱글톤-패턴"><a href="#싱글톤-패턴" class="headerlink" title="싱글톤 패턴"></a>싱글톤 패턴</h3><ul>
<li>단 하나의 객체만 존재할 수 있는 클래스를 구현하는 패턴<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="팩토리-패턴"><a href="#팩토리-패턴" class="headerlink" title="팩토리 패턴"></a>팩토리 패턴</h3></li>
<li>구상 클래스 객체를 전담하여 생성하는 클래스를 구현하는 패턴</li>
<li>팩토리 메소드 패턴 (ref)</li>
</ul>
<p><img src="../../../image/%ED%8C%A9%ED%86%A0%EB%A6%AC%ED%8C%A8%ED%84%B4.jpg" alt="팩토리 패턴"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"></span><br><span class="line">    Shape shape1 = shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line">    shape1.draw();</span><br><span class="line"></span><br><span class="line">    Shape shape2 = shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    shape2.draw();</span><br><span class="line"></span><br><span class="line">    Shape shape3 = shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    shape3.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="추상-팩토리-패턴"><a href="#추상-팩토리-패턴" class="headerlink" title="추상 팩토리 패턴"></a>추상 팩토리 패턴</h3><p><img src="../../../image/%EC%B6%94%EC%83%81%ED%8C%A9%ED%86%A0%EB%A6%AC%ED%8C%A8%ED%84%B4.jpg" alt="추상 팩토리 패턴"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundedRectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside RoundedRectangle::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundedSquare</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside RoundedSquare::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;    </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();         </span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;     </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundedShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;    </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoundedRectangle();         </span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoundedSquare();</span><br><span class="line">      &#125;     </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(<span class="keyword">boolean</span> rounded)</span></span>&#123;   </span><br><span class="line">      <span class="keyword">if</span>(rounded)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoundedShapeFactory();         </span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line">      shape1.draw();</span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line">      shape2.draw();</span><br><span class="line"></span><br><span class="line">      AbstractFactory shapeFactory1 = FactoryProducer.getFactory(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      Shape shape3 = shapeFactory1.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line">      shape3.draw();</span><br><span class="line">      Shape shape4 = shapeFactory1.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line">      shape4.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="데코레이터-패턴"><a href="#데코레이터-패턴" class="headerlink" title="데코레이터 패턴"></a>데코레이터 패턴</h3><ul>
<li>생성자를 이용해 객체에 일정한 기능을 추가하는 패턴</li>
</ul>
<p><img src="../../../image/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0%20%ED%8C%A8%ED%84%B4.jpg" alt="데코레이터 패턴"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape: Rectangle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape: Circle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      decoratedShape.draw();</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(decoratedShape);        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      decoratedShape.draw();           </span><br><span class="line">      setRedBorder(decoratedShape);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Border Color: Red&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorPatternDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line"></span><br><span class="line">      Shape redCircle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line"></span><br><span class="line">      Shape redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line">      System.out.println(<span class="string">&quot;Circle with normal border&quot;</span>);</span><br><span class="line">      circle.draw();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;\nCircle of red border&quot;</span>);</span><br><span class="line">      redCircle.draw();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;\nRectangle of red border&quot;</span>);</span><br><span class="line">      redRectangle.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="옵저버-패턴"><a href="#옵저버-패턴" class="headerlink" title="옵저버 패턴"></a>옵저버 패턴</h3><ul>
<li>Observable 객체의 변화를 Observer에서 알 수 있도록 하는 패턴 </li>
</ul>
<p><img src="../../../image/%EC%98%B5%EC%A0%80%EB%B2%84%ED%8C%A8%ED%84%B4.jpg" alt="옵저버패턴"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">      observers.add(observer);        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">        observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Subject subject;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">&quot;Binary String: &quot;</span> + Integer.toBinaryString( subject.getState() ) ); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println( <span class="string">&quot;Octal String: &quot;</span> + Integer.toOctalString( subject.getState() ) ); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">&quot;Hex String: &quot;</span> + Integer.toHexString( subject.getState() ).toUpperCase() ); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> HexaObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;First state change: 15&quot;</span>);    </span><br><span class="line">      subject.setState(<span class="number">15</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Second state change: 10&quot;</span>);    </span><br><span class="line">      subject.setState(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/18/Java/SW_Enginerring/DesignPatterns/" data-id="ckgm2mnc90026vwu226k0gjix" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-Annotations" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/18/Java/JavaAdvanced/Java-Annotations/" class="article-date">
  <time datetime="2020-10-18T06:46:06.204Z" itemprop="datePublished">2020-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/18/Java/JavaAdvanced/Java-Annotations/">Java_Annotations</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="애노테이션-Annotation"><a href="#애노테이션-Annotation" class="headerlink" title="애노테이션(Annotation)"></a>애노테이션(Annotation)</h1><h2 id="애노테이션이란"><a href="#애노테이션이란" class="headerlink" title="애노테이션이란"></a>애노테이션이란</h2><ul>
<li>애노테이션의 사전적인 의미는 주석이다,</li>
<li>JVM, 컴파일러, 프레임워크 등에게 전달하는 메타데이터로 사용된다.</li>
<li>프로그램에게 추가적인 정보를 제공하는 메타데이터이다.<ul>
<li>메타데이터란 데이터를 설명하는 데이터를 의미한다.</li>
</ul>
</li>
</ul>
<h2 id="기본-애노테이션"><a href="#기본-애노테이션" class="headerlink" title="기본 애노테이션"></a>기본 애노테이션</h2><table>
<thead>
<tr>
<th>애노테이션</th>
<th>설명</th>
<th>비고</th>
</tr>
</thead>
<tbody><tr>
<td>@Override</td>
<td>상속하여 오버라이드된 메소드</td>
<td></td>
</tr>
<tr>
<td>@Deprecated</td>
<td>앞으로 사라질 예정임을 표기한다.</td>
<td></td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>컴파일러에게 특정 경고 메세지를 무시하도록 한다.</td>
<td>ex- @SuppressWarnings(“unused”)</td>
</tr>
<tr>
<td>@FuntionalInterface</td>
<td>함수형 인터페이스임을 표기(Lambda)</td>
<td></td>
</tr>
</tbody></table>
<h3 id="에노테이션-용도"><a href="#에노테이션-용도" class="headerlink" title="에노테이션 용도"></a>에노테이션 용도</h3><ul>
<li><p>컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공한다.</p>
<ul>
<li>Ex) @Override - 메소드가 재정의 되었는지 확인할 수 있다.<br>(코드를 작성하고 이 코드가 제대로 작성이 되었는지 컴파일러에게 체크할 수 있도록 정보를 제공한다., 뭔가를 지시하는 용도로 사용)</li>
</ul>
</li>
<li><p>소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보를 제공</p>
<ul>
<li>프로그램을 개발하고나서 압축을 할 때가 있는 jar, war상태로 압축할 수 잇는데 어떤 파일명<br> 확장명으로 압축을 해라라고 개발툴에게 지시를 할 때 어노테이션을 통해 할수 있다</li>
<li>Ex) XML 설정 파일을 자동 생성하거나 배포를 위한 JAR 압축 파일을 자동 생성할 수 있다.</li>
</ul>
</li>
<li><p>실행시(런타임시) 특정 기능을 실행하도록 정보를 제공한다.</p>
<ul>
<li>객체를 만들었을 때 다른객체와 달리 특별한 역할을 해야할 경우 그객체에게 어노테이션을 기술해주면<br>어노테이션에 기술되어있는 데이터를 보고 특별한 역할을 할 수 있다.</li>
<li>Ex) 객체가 애플리케이션 내부에서 해야할 역할을 정의할 수 있다(서블릿, 컨트롤러…)</li>
</ul>
</li>
</ul>
<h2 id="애노테이션-타입-정의와-적용"><a href="#애노테이션-타입-정의와-적용" class="headerlink" title="애노테이션 타입 정의와 적용"></a>애노테이션 타입 정의와 적용</h2><ul>
<li><p>애노테이션 타입 정의</p>
<ul>
<li>소스 파일 생성 : AnnotationName.java</li>
<li>소스 파일 내용<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>애노테이션의 작성</p>
<ul>
<li>추상 메소드와 유사한 형태로 구현<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span> <span class="comment">// 메타 애노테이션</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span>                                     <span class="comment">// 메타 애노테이션</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;                                   <span class="comment">// 애노테이션 선언</span></span><br><span class="line">    String [] value();                                                 <span class="comment">// 애노테이션 속성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>애노테이션 타입 적용</p>
<ul>
<li><code>@AnnotationName</code><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> toString()&#123; .. &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>애노테이션의 사용</p>
<ul>
<li>key = value 형태로 애노테이션에 속성의 값 전달<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(value = &#123;&quot;unused&quot;, &quot;rawtypes&quot;&#125;)</span> <span class="comment">// 키 = 값 배열</span></span><br><span class="line"><span class="meta">@SuppressWarnings(value = &quot;unused&quot;)</span>               <span class="comment">// 값이 하나인 경우 배열 생략 가능</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;rawtypes&quot;&#125;)</span>         <span class="comment">// 속성이 value 하나인 경우 키 생략 가능</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation(key1 = &quot;value1&quot;, key2 = &#123;&quot;value2&quot;, &quot;value3&quot;&#125;)</span> <span class="comment">// 속성이 여러개인 경우 키를 여러개 사용</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>애노테이션의 엘리먼트 멤버</p>
<ul>
<li>어노테이션을 코드에 적용할 때 외부의 값(개발자가 입력한 값)을 입력받을 수 있도록 하는 역할</li>
<li>엘리먼트 선언<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">  타입 elementName() [defalut 값(기본값, 생략가능)]; <span class="comment">// 엘리먼트 선언</span></span><br><span class="line">   ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>엘리먼트의 타입은 기본타입과 참조 타입 모두 사용할 수 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">  String elementName1();</span><br><span class="line">  <span class="keyword">int</span> elementName2() <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>어노테이션 적용시 엘리먼트 값을 지정하는 방법<br> @AnnotationName(element=”값”, elementName2 = 3);</p>
</li>
</ul>
<h2 id="기본-엘리먼트-value"><a href="#기본-엘리먼트-value" class="headerlink" title="기본 엘리먼트 value"></a>기본 엘리먼트 value</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">  String value()  <span class="comment">// 기본 엘리먼트 선언</span></span><br><span class="line">  <span class="keyword">int</span> elementName()  <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>애노테이션을 적용할 때 엘리먼트명을 생략가능</p>
<ul>
<li><code>@AnnotationName(&quot;값&quot;);</code> - 기본 엘리먼트인 value에 값이 들어간다<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">&quot;/main&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainServlet</span> &#123;</span> ... &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>두 개 이상의 속성을 기술할 때에는 value =값 형태로 기술해야 한다.</p>
<ul>
<li><code>@AnnotationName(value=&quot;값&quot;, elementName=3);</code></li>
</ul>
</li>
</ul>
<h2 id="애노테이션-적용-대상"><a href="#애노테이션-적용-대상" class="headerlink" title="애노테이션 적용 대상"></a>애노테이션 적용 대상</h2><ul>
<li>코드 상에서 애노테이션을 적용할 수 있는 대상</li>
<li>java.lang.annotation.ElementType. 열거 상수로 정의되어 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>ElementType 열거 상수</th>
<th>적용 대상</th>
</tr>
</thead>
<tbody><tr>
<td>TYPE</td>
<td>클래스, 인터페이스, 열거 타입</td>
</tr>
<tr>
<td>ANNOTATION_TYPE</td>
<td>어노테이션</td>
</tr>
<tr>
<td>FIELD</td>
<td>필드, 열거형 상수</td>
</tr>
<tr>
<td>CONSTRUCTOR</td>
<td>생성자</td>
</tr>
<tr>
<td>METHOD</td>
<td>메소드</td>
</tr>
<tr>
<td>PARAMETER</td>
<td>메소드의 입력 파라미터</td>
</tr>
<tr>
<td>LOCAL_VARIABLE</td>
<td>로컬 변수</td>
</tr>
<tr>
<td>PACKAGE</td>
<td>패키지</td>
</tr>
<tr>
<td>MODULE</td>
<td>모듈</td>
</tr>
</tbody></table>
<ul>
<li>애노테이션 적용 대상 지정 방법<ul>
<li>@Target 애노테이션으로 적용 대상 지정</li>
<li>@Target의 기본 엘리먼트인 value의 타입은 ElementType 배열<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FLELD, ElementTypeMETHOD&#125;) <span class="comment">// TYPE,FELED,METHOD에 적용할 수 있다라는 의미이다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AnnotationName</span> <span class="comment">// 클래스에 사용 가능</span></span><br><span class="line"><span class="keyword">public</span> className&#123;</span><br><span class="line">   <span class="meta">@AnnotationName</span> <span class="comment">// 필드에 사용 가능</span></span><br><span class="line">   <span class="keyword">private</span> String fieldName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AnnotationName</span> x  <span class="comment">// 생성자에는 사용 불가</span></span><br><span class="line">   <span class="keyword">public</span> className()&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AnnotationName</span> <span class="comment">// 메소드에는 사용 가능</span></span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">void</span> methodName()&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="어노테이션-유지-정책"><a href="#어노테이션-유지-정책" class="headerlink" title="어노테이션 유지 정책"></a>어노테이션 유지 정책</h2><ul>
<li><p>어노테이션 적용 코드가 유지되는 시점을 지정하는 것</p>
</li>
<li><p>java.lang.annotation.RetentionPolicy 열거 상수로 정의되어 있다.</p>
<table>
<thead>
<tr>
<th>RetentionPolicy 열거 상수</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>SOURCE</td>
<td>소스상에서만 어노테이션 정보를 유지한다. 소스코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다. 컴파일러가 컴파일 할 때 어노테이션을 바이트코드에서 뺀다,바이트코드에서는 어노테이션이 유지되지 않는 정책이다 개발자가 소스에서 정보를 얻을 목적으로 유지하는 정책</td>
</tr>
<tr>
<td>CLASS</td>
<td>바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다.클래스상에만 존재하고 실제로 실행할 때는 그정보를 읽지못하는 유지 정책.</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임에 어노테이션 정보를 얻을 수 있다. 클래스를 이용할 때 어떤 어노테이션이 적용되었나를 보고 클래스의 역할과 실행방법을 정해줄 수 있기 때문에 대부분 RUNTIME 유지정책을 사용한다</td>
</tr>
</tbody></table>
<ul>
<li>리플렉션(ReFlection) : 런타임에 클래스의 메타 정보를 얻는 기능<ul>
<li>(클래스의 메타정보)클래스가 가지고 있는 필드, 필드의 종류, 필드의 타입 생성자, 메소드, 어노테이션의 정보 등등을 얻을 수 있다.</li>
<li>런타임시에 어노테이션 정보를 얻으려면 유지 정책을 RUNTIME으로 설정해야 한다.</li>
</ul>
</li>
</ul>
</li>
<li><p>유지 정책 지정 방법</p>
<ul>
<li>@Retention 어노테이션으로 유지 정책을 지정</li>
<li>@Retention의 기본 엘리먼트인 value의 타입은 RetentionPolicy<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FLELD, ElementTypeMETHOD&#125;)</span> <span class="comment">// TYPE,FELED,METHOD에 적용할 수 있다라는 의미이다.</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 여기다가 위에 3가지중 하나를 넣어주면 됨. value = RetentionPolicy.RUNTIME과 같다</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="사용자-정의-애노테이션"><a href="#사용자-정의-애노테이션" class="headerlink" title="사용자 정의 애노테이션"></a>사용자 정의 애노테이션</h2><ul>
<li>멤버 변수를 대상으로 하는, Reflection API에서 쓸 수 있ㄴㄴ 애노테이션</li>
<li>애노테이션 속성은 String[]인 value와 “기본값” 기본값을 가지는 valueTwo로 이루어짐</li>
</ul>
<ul>
<li><p>사용자 정의 애노테이션 구현</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    String[] value(); <span class="comment">// 애노테이션 속성 (기본 속성 이름은 value) 첫번째 애노테이션 속성은 value로해주는 게 좋다.</span></span><br><span class="line">    <span class="function">String <span class="title">valueTwo</span><span class="params">()</span> <span class="keyword">default</span> &quot;기본값&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>사용자 정의 애노테이션 사용</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationUsage</span></span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;game&quot;)</span><span class="comment">// 바로밑에 한줄에 적용이된다. 게임네임에는 게임에 대한정보가들어가있다라는 의미이다.</span></span><br><span class="line">    String gameName = <span class="string">&quot;여러분의 틱택토&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//value가 String[]이므로 value = String[]로 넣어 준다.</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;server&quot;,valueTwo = &quot;localhost&quot;)</span> <span class="comment">// value는 원래 배열이다</span></span><br><span class="line">    String serverIP; <span class="comment">// 내용이 들어가도 상관없다. 여기에쓰던지 valueTwo에쓰던지하는 것</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//value가 String[]이지만, 길이가 1이면 String 만 넣어주어도 됨.</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;server&quot;,valueTwo = &quot;8080&quot;)</span></span><br><span class="line">    String serverPort;</span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;game&quot;)</span></span><br><span class="line">    String gameMode = <span class="string">&quot;AI VS. AI&quot;</span>;</span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;db&quot;,valueTwo = &quot;localhost&quot;)</span></span><br><span class="line">    String database;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reflection을 이용하여 애노테이션에 할당된 값 사용</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationUsage obj = <span class="keyword">new</span> AnnotationUsage();</span><br><span class="line">        Map&lt;String, Object&gt; gameProp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Object&gt; serverPrp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Object&gt; dbProp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Field[] fields =AnnotationUsage.class.getDeclaredFields(); // 필드 정보 가져오는 부분 (Reflection API를 사용하여 가져옴)</span><br><span class="line">        <span class="keyword">for</span> (Field filed : fields) &#123;</span><br><span class="line">            MyAnnotation annotation = filed.getDeclaredAnnotation(MyAnnotation.class); // 필드에서 Annotation 정보 가져오는 부분(Reflect API)</span><br><span class="line">            <span class="keyword">if</span>(filed.get(obj) == <span class="keyword">null</span>)&#123; <span class="comment">// 필드 값이 비어있는 경우 valueTwo에서 가져온다.</span></span><br><span class="line">                filed.set(obj, annotation.valueTwo()); <span class="comment">// 값이 없으면 valueTwo를 채워줌</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (annotation.value()[<span class="number">0</span>].equals(<span class="string">&quot;game&quot;</span>))&#123;</span><br><span class="line">                gameProp.put(filed.getName(),filed.get(obj));</span><br><span class="line">            &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (annotation.value()[<span class="number">0</span>].equals(<span class="string">&quot;server&quot;</span>))&#123;</span><br><span class="line">                serverPrp.put(filed.getName(),filed.get(obj));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dbProp.put(filed.getName(),filed.get(obj));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(gameProp);</span><br><span class="line">        System.out.println(serverPrp);</span><br><span class="line">        System.out.println(dbProp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/18/Java/JavaAdvanced/Java-Annotations/" data-id="ckgm2mnbc0011vwu25dskhr7e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-Stream_TerminalOperations" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/Java/JavaAdvanced/Java-Stream_TerminalOperations/" class="article-date">
  <time datetime="2020-10-10T07:45:14.651Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/10/Java/JavaAdvanced/Java-Stream_TerminalOperations/">Java_Stream-최종 처리 메소드(최종 연산자)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="최종-처리-메소드"><a href="#최종-처리-메소드" class="headerlink" title="최종 처리 메소드"></a>최종 처리 메소드</h1><table>
<thead>
<tr>
<th>동작</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>루핑</td>
<td>forEach()</td>
</tr>
<tr>
<td>매칭</td>
<td>allMatch(), anyMatch(), noneMatch()</td>
</tr>
<tr>
<td>집계</td>
<td>count(), max(), min(), average(), sum(), reduce()</td>
</tr>
<tr>
<td>조사</td>
<td>findFirst(), findAny()</td>
</tr>
<tr>
<td>수집</td>
<td>collect()</td>
</tr>
</tbody></table>
<h2 id="루핑"><a href="#루핑" class="headerlink" title="루핑"></a>루핑</h2><h3 id="forEach-메소드로-스트림-요소를-순차적으로-Consumer를-이용해-소비"><a href="#forEach-메소드로-스트림-요소를-순차적으로-Consumer를-이용해-소비" class="headerlink" title="forEach() 메소드로 스트림 요소를 순차적으로 Consumer를 이용해 소비"></a>forEach() 메소드로 스트림 요소를 순차적으로 Consumer<T>를 이용해 소비</h3><ul>
<li>forEach() - 요소들을 계속해서 반복해서 가져와라라는 의미이다.<ul>
<li><code>stream.forEach(name -&gt; System.out.println(name))</code>으로 되어있을 때<br>스트림에 가져온 요소를 name에 넣어서 하나씩 출력되게 하는 것이다.</li>
<li>매개값의 형태는 Consumer 함수형 인터페이스 타입을 갖는다.</li>
</ul>
</li>
<li><code>void forEach(Comsumer&lt;? super T&gt; action)</code> : 스트림의 각 요소를 action으로 소비  </li>
</ul>
<h2 id="매칭"><a href="#매칭" class="headerlink" title="매칭"></a>매칭</h2><h3 id="Predicate-계열을-이용해-스트림-요소들이-특정-조건에-만족하는지-조사하는-메소드"><a href="#Predicate-계열을-이용해-스트림-요소들이-특정-조건에-만족하는지-조사하는-메소드" class="headerlink" title="Predicate 계열을 이용해 스트림 요소들이 특정 조건에 만족하는지 조사하는 메소드"></a>Predicate 계열을 이용해 스트림 요소들이 특정 조건에 만족하는지 조사하는 메소드</h3><ul>
<li><p>boolean allMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 모든 요소가 Predicate를 만족하면 true를 반환</p>
</li>
<li><p>boolean anyMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 요소 중 하나라도 Predicate를 만족하면 true를 반환</p>
</li>
<li><p>boolean noneMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 요소 중 하나라도 Predicate를 만족하지 않으면 true를 반환</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.allMatch(s -&gt; s.equals(<span class="string">&quot;abc&quot;</span>))); <span class="comment">//false</span></span><br><span class="line">st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.anyMatch(s -&gt; s.equals(<span class="string">&quot;cde&quot;</span>))); <span class="comment">//true</span></span><br><span class="line">st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.noneMatch(s -&gt; s.equals(<span class="string">&quot;abcde&quot;</span>)));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="조사"><a href="#조사" class="headerlink" title="조사"></a>조사</h2><h3 id="첫번째-요소-또는-아무-요소를-조사하는-최종-처리-메소드-필터링-등으로-인해-스트림에-요소가-남아있는지-확인할-수-있다"><a href="#첫번째-요소-또는-아무-요소를-조사하는-최종-처리-메소드-필터링-등으로-인해-스트림에-요소가-남아있는지-확인할-수-있다" class="headerlink" title="첫번째 요소 또는 아무 요소를 조사하는 최종 처리 메소드. 필터링 등으로 인해 스트림에 요소가 남아있는지 확인할 수 있다."></a>첫번째 요소 또는 아무 요소를 조사하는 최종 처리 메소드. 필터링 등으로 인해 스트림에 요소가 남아있는지 확인할 수 있다.</h3></li>
<li><p><code>Optional&lt;T&gt; findFirst()</code> : 스트림의 첫 요소 또는 empty Optional 객체를 반환</p>
</li>
<li><p><code>Optional&lt;T&gt; findAny()</code> : 스트림의 아무 요소나 가지는 Optional 객체를 반환 (병렬 스트림일 때 사용한다.)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> firstValue = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line">                .filter(n -&gt; n%<span class="number">3</span> ==<span class="number">0</span>)</span><br><span class="line">                .findFirst()</span><br><span class="line">                .getAsInt();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="집계-통계"><a href="#집계-통계" class="headerlink" title="집계 (통계)"></a>집계 (통계)</h2><ul>
<li><p>최종 처리 기능</p>
<ul>
<li>카운팅, 합계, 평균값, 최대값, 최소값 등과 같이 하나의 값으로 산출한다.</li>
<li>대량의 데이터를 가공해서 축소하는 리덕션이라고 볼 수 있다.</li>
</ul>
</li>
<li><p>기본 집계 메소드</p>
<ul>
<li>기본형 스트림의 통계 : count(), sum(), average(), min(), max()</li>
<li>T 타입 스트림의 통계 : count(), min(), max() (min, max의 경우 Comparator 필요)</li>
</ul>
</li>
</ul>
<h3 id="reduce-메소드-사용자-정의-집계-메소드"><a href="#reduce-메소드-사용자-정의-집계-메소드" class="headerlink" title="reduce() 메소드 : 사용자 정의 집계 메소드"></a>reduce() 메소드 : 사용자 정의 집계 메소드</h3><ul>
<li>모든 자료형에서 사용할 수 있는 집계 메소드이다!</li>
<li>개발자가 프로그램화해서 다양한 집계(리덕션) 결과물을 만들 수 있다.</li>
<li>특정한 값을 집계 할 수 있게 하기 위해서 reduce를 제공한다.</li>
</ul>
<h4 id="세가지-인자를-받아서-처리"><a href="#세가지-인자를-받아서-처리" class="headerlink" title="세가지 인자를 받아서 처리"></a>세가지 인자를 받아서 처리</h4><ul>
<li>accmulator : 각 요소를 처리하는 계산 로직이다. 각 요소가 올 때마다 중간 결과를 생성한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator) </span><br><span class="line"><span class="comment">//accumulator를 수행하고 Optional&lt;T&gt; 타입 반환</span></span><br></pre></td></tr></table></figure></li>
<li>identity : 계산을 위한 초기값이다. stream이 비어서 계산할 값이 없더라도 이 값은 반한된다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator) </span><br><span class="line"><span class="comment">// identity를 초기값으로 하여, accumulator를 이용해 집계 연산</span></span><br></pre></td></tr></table></figure></li>
<li>combiner : 병럴 stream에서 나눠 계산한 결과를 하나로 합쳐 반환한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner) </span><br><span class="line"><span class="comment">// combiner를 이용해 병렬 스트림 결합</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="메소드-형태-및-사용코드"><a href="#메소드-형태-및-사용코드" class="headerlink" title="메소드 형태 및 사용코드"></a>메소드 형태 및 사용코드</h4><table>
<thead>
<tr>
<th>인터페이스</th>
<th>리턴 타입</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Stream</td>
<td>Optional<T></td>
<td>reduce(BinaryOperator<T> accumulator</td>
</tr>
<tr>
<td></td>
<td>T</td>
<td>reduce(T identitiy, BianryOperator<T> accmulator)</td>
</tr>
<tr>
<td>IntStream</td>
<td>OptionalInt</td>
<td>reduce(IntBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>reduce(int indentity, IntBinaryOperator  op)</td>
</tr>
<tr>
<td>LongStream</td>
<td>OptionalLong</td>
<td>reduce(LongBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>reduce(long indentity, LongBinaryOperator  op)</td>
</tr>
<tr>
<td>DoubleStream</td>
<td>OptionalDouble</td>
<td>reduce(DoubleBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>reduce(double indentitiy, DoubleBinaryOperator  op)</td>
</tr>
</tbody></table>
<ul>
<li><p>reduce(BinaryOperator<T> accumulator)</p>
<ul>
<li>이건 연산의 결과가 없으면 예외가 발생한다. NotSuchElementException 요소가 있어야 동작한다.</li>
</ul>
</li>
<li><p>reduce(T identitiy, BianryOperator<T> accmulator) </p>
<ul>
<li>연산의 결과가 없다면, 디폴트로 identity 사용  요소가 없어도 동작한다.</li>
<li>연산의 결과가 없는 것은 요소가 없는 것이다. 그래서 연산의 결과로 디폴트 값으로 identity를 하는 것이다.</li>
</ul>
</li>
<li><p>매개변수</p>
<ul>
<li>XXXBinaryOperator : 두 개의 매개 값을 받아 연산 후 리턴하는 함수적 인터페이스</li>
<li>identity : 스트림에 요소가 전혀 없을 경우 리턴될 디폴트 값   </li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(IntStream.range(<span class="number">0</span>,<span class="number">10</span>).reduce(<span class="number">0</span>,(value1,value2)-&gt;value1+value2)); <span class="comment">//sum()</span></span><br><span class="line"><span class="comment">// 1,2와 더한걸 3이랑 더하고 12 와 3을 더한걸 4 와 더함 .. 누적해서 더하는 것이다.</span></span><br><span class="line"><span class="comment">// identity가 사용이 되는 이유는 처음 identitiy와 1을 더한값과 2를계산하기위해서</span></span><br><span class="line"><span class="comment">// 0 [0,1,2,3,4,5,6,7,8,9] 0+0 =0 -&gt; 0+1-&gt;1 1+2-&gt; 3 과같은 연산 0~9까지 더한 연산</span></span><br><span class="line"><span class="comment">// sum()으로도 나타낼 수 있다 sum,min,max등등 도 reduce로 구현되어 있다</span></span><br><span class="line"></span><br><span class="line">System.out.println(IntStream.range(<span class="number">0</span>,<span class="number">10</span>).reduce(Integer.MAX_VALUE,(value1,value2)-&gt;value1&lt;value2? value1:value2));<span class="comment">// min()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Optional-클래스"><a href="#Optional-클래스" class="headerlink" title="Optional 클래스"></a>Optional<T> 클래스</h3><ul>
<li><p>T 타입 객체의 null 여부에 따라 다르게 동작하는 Wrapper 클래스</p>
</li>
<li><p>자바 8부터 추가된 값을 저장하는 값 기반 클래스</p>
</li>
<li><p>java.util 패키지의 Optional, OptionalDouble, OptionalInt, OptionLong 클래스를 말한다.</p>
</li>
<li><p>집계 메소드의 리턴 타입으로 사용되어 집계 값을 가지고 있다. 이게 핵심이다!!</p>
</li>
<li><p>저장된 값을 얻으려면 get(), getAsDouble(), getAsInt(), getAsLong()를 호출한다. </p>
</li>
<li><p>Optional 클래스의 정적 메소드를 이용해 Optional 객체 생성</p>
<ul>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; of(T value)</code> : value가 null인 경우 NullPointerException을 발생시키는 Wrapping 메소드</li>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code> : value가 null인 경우 empty()의 결과를 리턴하는 Wrapping 메소드</li>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; empty()</code> : 값이 비어있는 Optional 객체를 리턴</li>
</ul>
</li>
<li><p>Optional 객체를 처리하는 메소드</p>
<ul>
<li><code>public T get()</code> : Optional의 값을 리턴하며, null일 경우 NullPointerException 발생</li>
<li><code>public void ifPresent(Consumer&lt;? super T&gt; consumer)</code> : Optional 값이 null이 아닐 경우 consumer를 이용해 소비한다, 값이 저장되어 있지 않을 경우 디폴트 값(매개변수가 디폴트 값이 된다)<ul>
<li>consumer로 집계 값을 받아서 처리하는 코드를 람다식으로 작성한다</li>
</ul>
</li>
<li><code>public T orElse(T other)</code> : Optional의 값이 null일 경우 other를 반환한다, 값이 저장되어 있을 경우 Consumer 에서 처리</li>
<li><code>public T orElseGet(Supplier&lt;? extends T&gt; other)</code> : Optional의 값이 null일 경우 Supplier를 통해 공급받은 값을 반환한다.</li>
<li><code>public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</code> : Optional의 값이 null일 경우 exceptionSupplier에서 공급받은 예외를 throw</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">double</span> avg = list.stream()</span><br><span class="line">            .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">            .average()</span><br><span class="line">            .getAsDouble();</span><br><span class="line">    System.out.println(avg); <span class="comment">//NotSuchElementException</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// isPresent()</span></span><br><span class="line">    OptionalDouble optionalDouble = list.stream()</span><br><span class="line">            .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">            .average()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optionalDouble.isPresent())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;값이 있는 경우 : &quot;</span> + optionalDouble.getAsDouble());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;방법 1-값이 없는 경우 : &quot;</span> + <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// orElse()</span></span><br><span class="line">    <span class="keyword">double</span> avg = list.stream()</span><br><span class="line">            .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">            .average()</span><br><span class="line">            .orElse(<span class="number">0.0</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;방법 2 : &quot;</span> + avg);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ifPresent()</span></span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    list.stream()</span><br><span class="line">            .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">            .average()</span><br><span class="line">            .ifPresent(i-&gt; System.out.println(<span class="string">&quot;방법 3 : &quot;</span>+ i));</span><br><span class="line">    <span class="comment">// 값이 없을 경우 false가 되서 종료가 된다. consumer로 했기 때문에 바로 값 출력</span></span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">## 수집</span><br><span class="line">### 필요한 요소를 수집하여 새로운 Collection으로 구성하여 반환하는 메소드</span><br><span class="line">* 최종 처리 기능으로 요소들을 수집 또는 그룹핑한다.</span><br><span class="line">    * 필터링 또는 매핑된 요소들로 최종적으로 얻은요소들로 새로운 컬렉션 생성하는 것.</span><br><span class="line">    * 요소들을 그룹핑하고, 집계를 할 수 있다. </span><br><span class="line">* Stream API는  JCF-&gt; STREAM -&gt; 처리 -&gt; 결과</span><br><span class="line">* 결과가 출력일 수도 있고 값일 수도 있고, 다시 컬렉션으로 만들고 싶을 수 있다.</span><br><span class="line">* 요소가 여러개 있는 프레임워크 혹은 Arrays에서 스트림을 생성한 다음에 스트림에서 중간 처리를 쭉쭉한 다음에 마지막에 출력이나 값을 낼 수 있지만</span><br><span class="line"> 다음 중 <span class="number">3</span>가지중 하나의 조건은 꼭 선택해야 한다.</span><br><span class="line">  * 조건<span class="number">1.</span> foreach()를 사용하거나</span><br><span class="line">  * 조건<span class="number">2.</span> 특정한 값을 리턴을 받거나(reduce())</span><br><span class="line">  * 조건<span class="number">3.</span> count,min,max 스트림을 간추려서 통계를 낼 수 있는 값들을 가져오던지 다시 컬렉션으로 만들어 주던지 해야한다.</span><br><span class="line"></span><br><span class="line">### 보통 수집을 하기 위해서 필터링을 한다.</span><br><span class="line">* 스트림에서 필요한 요소만 필터링해서 별도의 컬렉션으로 만든다</span><br><span class="line">* collect라는 메소드 사용 collect(Collector &lt;T,A,R&gt; collector)</span><br><span class="line">* collect가  요소를 어떤 컬렉션에 수집할 것인지를 결정한다.</span><br><span class="line"></span><br><span class="line">* collect()메소드</span><br><span class="line">  * `&lt;R,A&gt; R collect(Collector&lt;? super T,A,R) collector)` : collector를 이용해 새로운 Collection R에 담아 반환</span><br><span class="line">     * Collectors의 `정적 메소드` : toList(), toSet(), toCollection(), toMap(), toConcurrentMap()</span><br><span class="line">     </span><br><span class="line">  * `&lt;R, A&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)` </span><br><span class="line">  : supplier를 통해 공급된 컨테이너 R에 accumulator를 이용해 T값을 저장. 병렬처리 스트림에 사용될 경우 combiner를 이용해 스레드별 컨테이너 R을 통합</span><br><span class="line"></span><br><span class="line">* Collector의 타입 파라미터</span><br><span class="line">   * <span class="attr">T :</span> 요소                                </span><br><span class="line">   * <span class="attr">A :</span> 누적기(accumulator) 요소를 컬렉션에 수집하는 역할을한다.</span><br><span class="line">   * <span class="attr">R :</span> 요소가 저장될 새로운 컬렉션 </span><br><span class="line">     * T 요소를 A 누적기가 R에 저장한다.</span><br><span class="line"></span><br><span class="line">| 리턴 타입 | 메소드 | 설명 |</span><br><span class="line">| ------- | ----- | ---- |</span><br><span class="line">| Collector&lt;T,?,Collection&lt;T&gt;&gt; | Collectors.toCollection&#123;Supplier&lt;T&gt;&#125; | Supplier가 제공한 Collection에 저장 |</span><br><span class="line">| Collector&lt;T,?,ConcurrentMap&lt;K,U&gt;&gt; |Collectors.toConcurrentMap(...) |ConcurrentMap에 저장한다. |</span><br><span class="line">| Collector&lt;T,?,List&lt;T&gt;&gt; |  Collectors.toList() | List에 저장 |</span><br><span class="line">| Collector&lt;T,?,Map&lt;K,U&gt;&gt; | Collectors.toMap() | Map에 저장 |</span><br><span class="line">| Collecotr&lt;T,?,Set&lt;T&gt;&gt; | Collectors.toSet() | Set에 저장 |</span><br><span class="line"></span><br><span class="line">* Collectors.toConcurrentMap(...) - 멀티쓰레드 환경에서 쓰레드의 안전한 concurrentmap을 만들어서 거기에 요소를 수집하는 Collector를 얻는다. </span><br><span class="line">* A가 ? 인 이유</span><br><span class="line">   * List, Set, Map 컬렉션에 누적할 경우 별도의 누적기가 필요 없다. </span><br><span class="line">   * 컬렉터내부에서 이들 컬렉션에 저장하는 방법을 알고 있기 때문에 별도의 누적기가 필요 없음.</span><br><span class="line"></span><br><span class="line">  ```groovy</span><br><span class="line">    String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line">    List&lt;String&gt; list = Arrays.stream(array)</span><br><span class="line">            .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">            .collect(Collectors.toList()); <span class="comment">// ArrayList</span></span><br><span class="line">            <span class="comment">// .collect(Collectors.toCollection(LinkedList::new))</span></span><br><span class="line">    System.out.println(list.getClass().getName() + <span class="string">&quot;:&quot;</span> + list);</span><br><span class="line">      </span><br><span class="line">    Set&lt;String&gt; set = Arrays.stream(array)</span><br><span class="line">            .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">            .collect(Collectors.toSet()); <span class="comment">// HashSet</span></span><br><span class="line">            <span class="comment">// .collect(Collectors.toCollection(HashSet::new))</span></span><br><span class="line">    System.out.println(set.getClass().getName() + <span class="string">&quot;:&quot;</span> + set);</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Integer&gt; map = Arrays.stream(array)</span><br><span class="line">            .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">            .collect(Collectors.toMap(s -&gt; s, String::length)); <span class="comment">// HashMap</span></span><br><span class="line">            <span class="comment">// .collect(Collectors.toCollection(s -&gt; s, String::length, (oldVal, newVal) -&gt; newVal, TreeMap::new))</span></span><br><span class="line">    System.out.println(map.getClass().getName() + map);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Collectors의 정적 메소드를 이용한 그룹화와 분리</p>
</li>
<li><p>partitioningBy는 어떤 기준으로 무더기로 나누는 것 (2가지 true or false)</p>
</li>
<li><p>groupingBy는 어떤 기준으로 여러개 묶어 내는 것  (여러개)</p>
<ul>
<li><dl><dt><code>public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code></dt><dd>classifier를 key값으로, 해당하는 값의 목록을 List인 value로 가지는 Map으로 스트림을 수집하는 Collector를 반환</dd></dl><ul>
<li><code>public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)</code> : List 대신 downstream collector로 수집</li>
<li>groupingBy(R Function<T>) - Map&lt;R, List<T>&gt;입력받은게 function으로 출력됨 R타입에 따라 그룹이 됨 그래서 R이 키가 된다.</li>
<li>T를 String..length 로 해주면 R은 Integer</li>
<li>결과 - 1: [………..], 2: [………..], 3: [………..]</li>
<li>키를 기준으로 그룹화 하는 것이다 다 대 다 형태 n:m이면 m이 조금 작을 것이다</li>
</ul>
</li>
<li><p><code>public static &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate)</code> : predicate 결과를 key로, 해당하는 값의 목록을 List value로 가지는 Map으로 스트림을 수집하는 Collector를 반환</p>
<ul>
<li><code>public static &lt;T, A, D&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream))</code> : List 대신 downstream collector로 수집</li>
<li>partitionBy(predciate)- Map&lt;Boolean, List<T>&gt; 왜냐하면 이건 두가지로 나누는 것이기 때문에 predicate 계열을 가지고 참인지 거짓인지 판단을 해야 해서</li>
<li>결과 - true :[……] , false: [……]  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> Map&lt;Character, List&lt;String&gt;&gt; map1 = Arrays.stream(array)</span><br><span class="line">         .collect(Collectors.groupingBy(s -&gt; s.charAt(<span class="number">0</span>)));</span><br><span class="line"> System.out.println(map1);</span><br><span class="line"> </span><br><span class="line"> Map&lt;Boolean, List&lt;String&gt;&gt; map2 = Arrays.stream(array)</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.length() &gt;= <span class="number">3</span>));</span><br><span class="line"> System.out.println(map2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>집계를 위한 Collector</p>
<ul>
<li>Downstream collector로 집계를 위한 Collector를 사용할 경우 유용하다.</li>
<li>counting(), summingP(), averagingP(), maxBy(), minBy(), reducing()</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  Map&lt;Character, Long&gt; map = Arrays.stream(array)</span><br><span class="line">          .collect(Collectors.groupingBy(s -&gt; s.charAt(<span class="number">0</span>),</span><br><span class="line">                                         Collectors.counting()));</span><br><span class="line">  System.out.println(map);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/10/Java/JavaAdvanced/Java-Stream_TerminalOperations/" data-id="ckgm2mnbw001lvwu2bawp9do5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-Stream_IntermediateOperations" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/Java/JavaAdvanced/Java-Stream_IntermediateOperations/" class="article-date">
  <time datetime="2020-10-10T07:25:15.662Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/10/Java/JavaAdvanced/Java-Stream_IntermediateOperations/">Java_Stream-중간 처리 메소드(중간 연산자)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="중간-처리-메소드-중간-연산자"><a href="#중간-처리-메소드-중간-연산자" class="headerlink" title="중간 처리 메소드(중간 연산자)"></a>중간 처리 메소드(중간 연산자)</h1><ul>
<li>중간 처리 메소드 이후에 최종 처리 메소드를 붙여서 사용한다.</li>
<li>값을 원하는 형태로 처리하기 위한 연산자이다. 중간 연산자들은 lazy하게 실행되고 결과로 stream을 반환한다.<ul>
<li>lazy한 처리는 최종처리메소드가 실행되기전까지 연산이 실행되지 않음,결과가 필요하기 전까지 실행되지 않는다, 연산의 시점을 최대한 늦춘다는 의미이다.</li>
</ul>
</li>
<li>그렇기 때문에 중간연산자는 연쇄적으로 연결하여 연산을 처리할 수 있다. (Ex - list.stream().filter(…).map(…))</li>
</ul>
<table>
<thead>
<tr>
<th>동작</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>필터링</td>
<td>dinstict(), filter()</td>
</tr>
<tr>
<td>자르기</td>
<td>skip(), limit()</td>
</tr>
<tr>
<td>정렬</td>
<td>sorted()</td>
</tr>
<tr>
<td>매핑</td>
<td>flatMap(), flatMapToP(), map(), mapToP(), asDoubleStream(), asLongStream()</td>
</tr>
<tr>
<td>조회</td>
<td>peek()</td>
</tr>
</tbody></table>
<h2 id="필터링"><a href="#필터링" class="headerlink" title="필터링"></a>필터링</h2><h3 id="필터링은-스트림의-일부-요소를-제거하는-역할을-한다"><a href="#필터링은-스트림의-일부-요소를-제거하는-역할을-한다" class="headerlink" title="필터링은 스트림의 일부 요소를 제거하는 역할을 한다."></a>필터링은 스트림의 일부 요소를 제거하는 역할을 한다.</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Is&quot;</span>,<span class="string">&quot;Fun&quot;</span>,<span class="string">&quot;Isn&#x27;t&quot;</span>,<span class="string">&quot;It&quot;</span>,<span class="string">&quot;?&quot;</span>,<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stringStream.forEach(System.<span class="attr">out:</span>:println); <span class="comment">// 기본형 중복이 포함되서 출력됨.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>distinct() : 스트림에 같은 요소가 있을 경우 하나만 남기고 삭제하는 메소드(중복 제거)<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringStream.distinct().forEach(System.<span class="attr">out:</span>:println);</span><br><span class="line"><span class="comment">// stringStream.distinct() 여기까지 중간처리메소드, foreach는 최종처리 메소드</span></span><br><span class="line">```        </span><br><span class="line">* filter() : Predicate 계열을 입력을 받아, <span class="literal">true</span>인 요소만 남긴다.</span><br><span class="line">```groovy</span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Is&quot;</span>,<span class="string">&quot;Fun&quot;</span>,<span class="string">&quot;Isn&#x27;t&quot;</span>,<span class="string">&quot;It&quot;</span>,<span class="string">&quot;?&quot;</span>);</span><br><span class="line">stringStream.filter(s-&gt;s.length()&gt;=<span class="number">3</span>).forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="자르기"><a href="#자르기" class="headerlink" title="자르기"></a>자르기</h2><h3 id="자르기는-스트림의-일부-요소를-한번에-생략한다"><a href="#자르기는-스트림의-일부-요소를-한번에-생략한다" class="headerlink" title="자르기는 스트림의 일부 요소를 한번에 생략한다."></a>자르기는 스트림의 일부 요소를 한번에 생략한다.</h3><ul>
<li><p>skip(long n) : 스트림의 처음부터 n개의 요소를 생략하는 메소드, n개 자른다. n+1부터 끝까지 반환</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().skip(<span class="number">5</span>).forEach(n-&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
</li>
<li><p>limit(long maxsize) : 스트림의 최대 요소 개수를 maxsize를 제한한다, maxsize의 요소보다 뒤에 있는 값들은 짤린다. 0부터 n개까지 반환</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().limit(<span class="number">5</span>).forEach(n-&gt; System.out.println(s));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="정렬"><a href="#정렬" class="headerlink" title="정렬"></a>정렬</h2><h3 id="스트림-요소의-compareTo-또는-입력받은-Comparator를-이용해-정렬한다"><a href="#스트림-요소의-compareTo-또는-입력받은-Comparator를-이용해-정렬한다" class="headerlink" title="스트림 요소의 compareTo() 또는 입력받은 Comparator를 이용해 정렬한다."></a>스트림 요소의 <code>compareTo()</code> 또는 입력받은 <code>Comparator</code>를 이용해 정렬한다.</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparable 객체를 정렬한 스트림 반환</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line">stringStream.sorted().forEach(System.<span class="attr">out:</span>:println); <span class="comment">// 사전순으로 정렬됨</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator 인터페이스를 람다식으로 구현하여 정렬한다.</span></span><br><span class="line"><span class="comment">// Comparator를 이용하여 정렬된 스트림 반환</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line">stringStream.sorted((o1, o2) -&gt; o1.length() - o2.length()).forEach(System.<span class="attr">out:</span>:println); </span><br><span class="line"><span class="comment">//compreator를 람다식으로 작성해줄 수 있다, 길이가 짧은 것부터 나온다.</span></span><br></pre></td></tr></table></figure>

<h2 id="매핑"><a href="#매핑" class="headerlink" title="매핑"></a>매핑</h2><h3 id="Function-인터페이스를-이용해-요소의-값을-변환한다"><a href="#Function-인터페이스를-이용해-요소의-값을-변환한다" class="headerlink" title="Function 인터페이스를 이용해 요소의 값을 변환한다."></a>Function 인터페이스를 이용해 요소의 값을 변환한다.</h3><ul>
<li>map 계열 - 입력 1 : 1 출력<ul>
<li><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code> : 기존 스트림의 T 타입 요소를 R 타입으로 변환하여 새로운 스트림 반환<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function 계열의 인터페이스를 사용하여 스트림의 각 요소를 매핑(Operator 계열도 사용)</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line"><span class="comment">// Function 계열로 string -&gt; integer 로 변환하는 매핑 Function&lt;String,Intger&gt;와 같은 형식을 람다식에 넣어준 것이다.</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = stringStream.map(s-&gt;s.length()) ;<span class="comment">//입력은 string 출력은 원하는대로 할수 있다</span></span><br><span class="line">stream2.forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure></li>
<li><code>PStream mapToP(ToPFunction&lt;? super T&gt; mapper)</code> : R(return)이 기본형 타입으로 제한된 map()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PStream (기본형 타입의 스트림)은 Operator 계열로 처리(자료형 반환x)</span></span><br><span class="line"><span class="comment">// 입출력 값이 똑같기 때문에</span></span><br><span class="line">IntStream intStream3 = IntStream.of(<span class="number">5</span>,<span class="number">2</span>,<span class="number">30</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">-34</span>);</span><br><span class="line">IntStream intStream4 = intStream3.map(value -&gt; value * <span class="number">10</span>); <span class="comment">// 형 변환이 되지 않고 입력이 출력이 된다.</span></span><br><span class="line">intStream4.forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>flatMap 계열 - 입력 1 : n 출력(스트림 형태로 출력한다.)(Function 계열만 사용)<ul>
<li><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code> : 스트림의 T 타입 요소가 n개의 R 타입 요소로 매핑된 새로운 스트림을 반환</li>
<li><code>PStream flatMapToP(Function&lt;? super T, ? extends PStream&gt; mapper)</code> : R이 기본형 타입으로 제한된 flatMap()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s.split(&quot;&quot;) : &quot;java&quot; -&gt; &#123;&quot;j&quot;,&quot;a&quot;,&quot;v&quot;,&quot;a&quot;&#125;</span></span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;backend&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;course&quot;</span>);</span><br><span class="line">list2.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(s.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;).forEach(System.<span class="attr">out:</span>:println); <span class="comment">//foreach를 사용하면 스트림이 끝나게 된다.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="조회"><a href="#조회" class="headerlink" title="조회"></a>조회</h2><h3 id="스트림-처리-과정에-영향을-미치지-않으며-중간-결과를-확인할-수-있으며-입력받은-스트림과-동일한-스트림을-반환한다"><a href="#스트림-처리-과정에-영향을-미치지-않으며-중간-결과를-확인할-수-있으며-입력받은-스트림과-동일한-스트림을-반환한다" class="headerlink" title="스트림 처리 과정에 영향을 미치지 않으며, 중간 결과를 확인할 수 있으며 입력받은 스트림과 동일한 스트림을 반환한다."></a>스트림 처리 과정에 영향을 미치지 않으며, 중간 결과를 확인할 수 있으며 입력받은 스트림과 동일한 스트림을 반환한다.</h3><ul>
<li>Stream<T> peek(Consumer&lt;? super T&gt; action)<ul>
<li>peek() -&gt; Consumer 계열의 람다식 입력을 받아 입력 요소를 소비</li>
<li>peek()는 입력받아 스트림과 동일한 스트림을 다시 출력<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(list2.stream().flatMap(s -&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> Arrays.stream(s.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;).peek(s-&gt; System.out.println(<span class="string">&quot;flatMap():&quot;</span>+s))</span><br><span class="line">           .distinct().peek(s-&gt; System.out.println(<span class="string">&quot;distinct():&quot;</span>+s))</span><br><span class="line">           .count()); <span class="comment">// 함수형 프로그래밍은 선언형이어서 어떻게 해라라고 말해야한다.</span></span><br><span class="line"><span class="comment">// flatmap은 모든 요소를 다 나타내고 distinct는 중복된것을 없애고 하나만 출력됨.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/10/Java/JavaAdvanced/Java-Stream_IntermediateOperations/" data-id="ckgm2mnbu001kvwu2g238a894" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-JavaInputOutput" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/" class="article-date">
  <time datetime="2020-10-07T11:31:56.495Z" itemprop="datePublished">2020-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h1><h2 id="I-O와-스트림"><a href="#I-O와-스트림" class="headerlink" title="I/O와 스트림"></a>I/O와 스트림</h2><ul>
<li>I/O 입출력(Input/Output)을 함께 부르는 것</li>
<li>자바의 I/O는 스트림을 이용해 데이터를 주고 받는 형식으로 이루어졌다.<ul>
<li>데이터의 소스와 목적지를 노드(Node)라고 부른다.</li>
<li>노드는 키보드(입력), 모니터(출력,터치스크린은 입력가능), 파일(입출력), 메모리에 적혀있는걸 읽는것(입출력둘다 해당), 데이터베이스(입출력),다른 프로그램 등이 될 수 있다.</li>
</ul>
</li>
<li>장치하고는 상관없이 자바의 입출력을 추상화해놓은 스트림이다.</li>
<li>자바 응용프로그램과 입출력 자료사이에 데이터를 입출력하는 통로라고 생각하면 된다!!</li>
</ul>
<h2 id="입출력-스트림이란"><a href="#입출력-스트림이란" class="headerlink" title="입출력 스트림이란?"></a>입출력 스트림이란?</h2><ul>
<li>네트워크에서 자료의 흐름이 물과같다는 의미에서 유래되었다.</li>
<li>다양한 입출력 장치에 독립적으로 일관성있는 입출력 방식을 제공한다.</li>
<li>가상 경로가 있다고 가정하고 입출력이 이뤄진다.</li>
<li>입출력이 구현 되는 곳에서는 모두 I/O 스트림을 사용<ul>
<li>키보드, 파일 디스크, 메모리 등</li>
</ul>
</li>
</ul>
<p><img src="../../../image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="입출력스트림"></p>
<h2 id="입출력-스트림-구분"><a href="#입출력-스트림-구분" class="headerlink" title="입출력 스트림 구분"></a>입출력 스트림 구분</h2><ul>
<li>I/O 대상 기준 : 입력 스트림, 출력 스트림</li>
<li>자료의 종류 : 바이트 스트림, 문자 스트림<ul>
<li>동영상이나 음악파일은 한 바이트씩 쓰인다.</li>
<li>문자, 한글 파일등은 멀티 파이트로 쓰인다.</li>
</ul>
</li>
<li>스트림의 기능 : 기반 스트림(메인 스트림), 보조 스트림</li>
</ul>
<h3 id="기반-스트림-메인스트림-과-보조스트림"><a href="#기반-스트림-메인스트림-과-보조스트림" class="headerlink" title="기반 스트림(메인스트림)과 보조스트림"></a>기반 스트림(메인스트림)과 보조스트림</h3><ul>
<li><p>자바의 I/O는 디자인 패턴 중에 데코레이터 패턴으로 구현되어 있는데 보조스트림은 읽거나 쓰는 기능은 없다.</p>
</li>
<li><p>데코레이터 패턴에서 원래 컴포넌트가 가지는 기능 읽거나 쓰는 기능은 기반 스트림에서 가지고 있고,<br>보조스트림은 기반스트림을 보조하는 기능을 추가하는 것이다.</p>
<ul>
<li>자바 I/O는 데코레이터 패턴 기반이다.</li>
<li>원래 어떤 클래스 기능이 확장되면 상속을 쓰는 경우가 있는데,<br>데코레이터 패턴은 더 유연하게 기능을 확장할 수 있는 그런 디자인 패턴이다.</li>
</ul>
</li>
<li><p>바이트를 문자로 바꿔준다던가 버퍼링기능을 제공한다던가 직렬화 같은 것들이 보조 스트림에서 제공이 된다.</p>
</li>
<li><p>하나의 스트림은 입력이나 출력이냐, 바이트냐 문자냐, 기반이냐 보조냐로 구분해서 보면 스트림을 이해하는데 도움이 된다.</p>
</li>
</ul>
<h3 id="입출력-스트림과-출력-스트림"><a href="#입출력-스트림과-출력-스트림" class="headerlink" title="입출력 스트림과 출력 스트림"></a>입출력 스트림과 출력 스트림</h3><ul>
<li>입력 스트림 : 대상으로부터 자료를 읽어 들이는 스트림</li>
<li>출력 스트림 : 대상으로 자료를 출력하는 스트림</li>
</ul>
<p><img src="../../../image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC2.jpg" alt="입출력스트림"></p>
<h4 id="입출력-스트림과-출력-스트림의-종류"><a href="#입출력-스트림과-출력-스트림의-종류" class="headerlink" title="입출력 스트림과 출력 스트림의 종류"></a>입출력 스트림과 출력 스트림의 종류</h4><ul>
<li>입력 스트림 : FileInputStream, FileReader, BufferedInputStream, BufferedReader 등</li>
<li>출력 스트림 : FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등<ul>
<li>끝에 Stream이 붙은 것은 Byte 단위로 처리하고, Reader/writer는 문자 단위로 처리한다.</li>
<li>Buffered는 버퍼링을 제공하는 보조스트림이다.</li>
</ul>
</li>
</ul>
<h3 id="바이트-단위-스트림과-문자-스트림"><a href="#바이트-단위-스트림과-문자-스트림" class="headerlink" title="바이트 단위 스트림과 문자 스트림"></a>바이트 단위 스트림과 문자 스트림</h3><ul>
<li>바이트 단위 스트림 :  바이트 단위로 자료를 읽고 쓴다(동영상, 음악파일등)</li>
<li>문자 단위 스트림 : 문자는 2바이트씩 처리해야한다!!(char형 나왔을 때 2바이트라는거 생각해!!)</li>
</ul>
<p><img src="../../../image/%EB%B0%94%EC%9D%B4%ED%8A%B8%EB%AC%B8%EC%9E%90%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="바이트문자스트림"></p>
<h4 id="바이트-단위-스트림과-문자-스트림의-종류"><a href="#바이트-단위-스트림과-문자-스트림의-종류" class="headerlink" title="바이트 단위 스트림과 문자 스트림의 종류"></a>바이트 단위 스트림과 문자 스트림의 종류</h4><ul>
<li>바이트 스트림 : FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream 등</li>
<li>문자 스트림 : FileReader, FileWriter, BufferedReader, BufferedWriter 등</li>
</ul>
<h2 id="기반-스트림과-보조-스트림"><a href="#기반-스트림과-보조-스트림" class="headerlink" title="기반 스트림과 보조 스트림"></a>기반 스트림과 보조 스트림</h2><ul>
<li>기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림</li>
<li>보조 스트림 : 직접 읽고 쓰는 기능은 없고 추가적인 기능을 제공해 주는 스트림<br>기반 스트림이나 또 다른 보조 스트림을 생성자의 매개변수로 포함시킨다.</li>
</ul>
<p><img src="../../../image/%EA%B8%B0%EB%B0%98%EB%B3%B4%EC%A1%B0%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="기반보조스트림"></p>
<h3 id="기반-스트림과-보조-스트림의-종류"><a href="#기반-스트림과-보조-스트림의-종류" class="headerlink" title="기반 스트림과 보조 스트림의 종류"></a>기반 스트림과 보조 스트림의 종류</h3><ul>
<li>기반 스트림 : FileInputStream, FileOutputStream, FileReader, FileWriter 등</li>
<li>보조 스트림 : InputStreamReader, OutputStreamReader, BufferedInputStream, BufferedOutputStream 등</li>
</ul>
<h2 id="표준-입출력"><a href="#표준-입출력" class="headerlink" title="표준 입출력"></a>표준 입출력</h2><h3 id="Sytem-in"><a href="#Sytem-in" class="headerlink" title="Sytem.in"></a>Sytem.in</h3><ul>
<li>한바이트 씩 읽어 들인다.</li>
<li>한글과 같은 여러 바이트로 된 문자를 읽기 위해서는 InputStreamReader 와 같은 보조 스트림을 사용해야 한다.</li>
</ul>
<h3 id="Scanner-클래스"><a href="#Scanner-클래스" class="headerlink" title="Scanner 클래스"></a>Scanner 클래스</h3><ul>
<li>java.util 패키지에 있는 입력 클래스</li>
<li>문자뿐 아니라 정수, 실수등 다양한 자료형을 읽을 수 있다.</li>
<li>생성자가 다양하여 여러 소스로부터 자료를 읽을 수 있다.</li>
</ul>
<p><img src="../../../image/%EC%8A%A4%EC%BA%90%EB%84%88%ED%81%B4%EB%9E%98%EC%8A%A4.jpg" alt="스캐너클래스"></p>
<h3 id="Console-클래스"><a href="#Console-클래스" class="headerlink" title="Console 클래스"></a>Console 클래스</h3><ul>
<li><p>System.in 을 사용하지 않고 콘솔에서 표준 입출력이 가능</p>
</li>
<li><p>Console 클래스의 메소드<br><img src="../../../image/%EC%BD%98%EC%86%94%ED%81%B4%EB%9E%98%EC%8A%A4.jpg" alt="콘솔클래스"></p>
</li>
</ul>
<h2 id="노드-스트림"><a href="#노드-스트림" class="headerlink" title="노드 스트림"></a>노드 스트림</h2><h3 id="InputStream과-Reader"><a href="#InputStream과-Reader" class="headerlink" title="InputStream과 Reader"></a>InputStream과 Reader</h3><ul>
<li>InputStream의 주요 메소드(byte 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>byte 하나를 읽어서 int로 반환. 읽을 값이 없으면 -1</td>
</tr>
<tr>
<td>int read(byte b[])</td>
<td>데이터를 읽어 b를 채우고, 읽은 바이트 수를 반환</td>
</tr>
<tr>
<td>int read(byte b[], int offset, int len)</td>
<td>최대 len개의 바이트를 읽어 b의 offset 위치부터 채운다.</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납</td>
</tr>
<tr>
<td>int available()</td>
<td>읽을 수 있는 데이터의 크기를 반납</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>스트림에서 n만큼 건너 뛴다.</td>
</tr>
<tr>
<td>void mark(int readLimit)</td>
<td>reset()으로 돌아갈 위치를 표시한다. readLimit은 돌릴 수 있는 최대 바이트 수</td>
</tr>
<tr>
<td>void reset()</td>
<td>mark()가 호출된 지점으로 돌아간다.</td>
</tr>
<tr>
<td>boolean markSupported()</td>
<td>mark, reset 메소드의 지원 여부를 반환</td>
</tr>
</tbody></table>
<ul>
<li><p>기본 코드</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 여기서는 값을 계속 입력받게 무한루프에 빠지게 된다.(강제 종료를 시켜야한다.)</span></span><br><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123; <span class="comment">//autocloseable 자동으로 close 호출</span></span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span>((read = input.read()) != <span class="number">-1</span>) &#123; <span class="comment">//read는 1바이트를 읽어온다.</span></span><br><span class="line">     <span class="comment">//-1이나오면 더이상 읽을게 없다라고 의미하는 것이다.</span></span><br><span class="line">         System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>버퍼를 사용한 코드</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// byte[] bytes = new byte[2];</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">// 일단 read()안에 버퍼 bytes라고 매개값을 주게 되면, 이 버퍼의 길이만큼 배열안에 입력받은 값들이 담겨져</span></span><br><span class="line">    <span class="comment">// 그 값들의 개수를 반환 시킨다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 512의 크기를 준 것 처럼 한번에 담을 수 없는 큰 크기를 줬을 때 이것 또한 무한 루프에 빠지게 된다.</span></span><br><span class="line">    <span class="comment">// 근데 만약 2 같은 작은 크기를 줬을 때는 2개씩 짤려서 반환시켜서 read에 넣어주다가 마지막에 1개인 값만 남게 되면 반복문이 종료됨</span></span><br><span class="line">    <span class="comment">// 예로 abcd를 입력하고 엔터를치면 ab 두개를 짤라서 read넣으면 2 != 1이니깐 반복문을 한번더 돌고 cd도 2!=1이니깐</span></span><br><span class="line">    <span class="comment">// 한번더 도는데 엔터도 \n라고 값이 있는 것이기 때문에 1개의 값이 되서 종료된다.</span></span><br><span class="line">    <span class="comment">// 그래서 이렇게 작은 버퍼를 주게 되었을 때는 밑에 while문 안에 조건문을 주는 것이 의미가 없게 된다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// input.read(bytes)를 하게 되면 bytes의 크기만큼의 데이터를 읽어서 길이를 반환해주고, bytes안에 입력된 값들이 저장된다.</span></span><br><span class="line">    <span class="keyword">while</span>((read = input.read(bytes)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)bytes[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">// 버퍼를 사용할 때는 입력 받은 글자의 길이를 반환해주는 것이기 때문에</span></span><br><span class="line">    <span class="comment">// 버퍼를 사용할 경우에 어떠한 글자들을 입력해도 계속해서 입력 받을 수 있다.(0과 같지 않을 때라고 조건을 해놨기 때문에)</span></span><br><span class="line">    <span class="keyword">while</span>((read = input.read(bytes)) != <span class="number">0</span>) &#123;  <span class="comment">// 읽은 개수가 0이면 읽을게 없다라는 의미이다</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)bytes[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Stream의 mark/reset 기능</p>
<ul>
<li><p>mark - 스트림이 있고 내용이 차있을 때 하나씩 가져오는게 스트림의 read인데 마크를 호출하게 되면 해당 인덱스에 마킹이 된다<br>그다음 쭉쭉 진행이되다가 reset을하면 마크를 해놓은 부분을 기억해놨다가 마킹되어있는 부분으로 돌아가게 되는 기능이다.</p>
</li>
<li><p>System.out.println(System.in.markSupported()); // mark/reset 가능?하다는 의미 true/fase로 출력</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123; <span class="comment">//autocloseable 자동으로 close 호출</span></span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>((read = input.read()) != <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)read == <span class="string">&#x27;m&#x27;</span>)&#123; <span class="comment">// m은 포함되지 않는다. 다음부터 마크가 된다.</span></span><br><span class="line">            input.mark(<span class="number">32</span>); <span class="comment">//몇개까지 기억을 할것이냐 32개를 기억함.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>)read == <span class="string">&#x27;r&#x27;</span>)&#123; <span class="comment">// r이 입력이 되면 reset이 호출된다.</span></span><br><span class="line">            input.reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Reader의 주요 메소드 (char 단위)<ul>
<li>stream과 유사하나, Reader는 char 단위로 읽어서 int로 반환</li>
<li>stream을 이용해서 Reader를 초기화할 수 있다.</li>
<li>char 단위로 동작하기때문에 한글도 깨지지 않고 잘 동작한다.</li>
<li>byte단위로 하면 한글은 읽어서 조합을 해줘야 한다.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>char 하나를 읽어서 int로 반환. 읽을 값이 없으면 -1</td>
</tr>
<tr>
<td>int read(char cbuf[])</td>
<td>데이터를 읽어 cbuf를 채우고, 읽은 char 수를 반환</td>
</tr>
<tr>
<td>int read(char cbuf[], int off, int len)</td>
<td>최대 len개의 char를 읽어 cbuf의 offset 위치부터 채운다.</td>
</tr>
<tr>
<td>int read(java.nio.CharBuffer target)</td>
<td>NIO target에 데이터를 저장한다.</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납</td>
</tr>
<tr>
<td>int available()</td>
<td>읽을 수 있는 데이터의 크기를 반납</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>스트림에서 n만큼 건너 뛴다.</td>
</tr>
<tr>
<td>void mark(int readAheadLimit)</td>
<td>reset()으로 돌아갈 위치를 표시한다. readLimit은 돌릴 수 있는 최대 바이트 수</td>
</tr>
<tr>
<td>void reset()</td>
<td>mark()가 호출된 지점으로 돌아간다.</td>
</tr>
<tr>
<td>boolean markSupported()</td>
<td>mark, reset 메소드의 지원 여부를 반환</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>))&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>((read = reader.read()) != <span class="number">1</span>) &#123;  </span><br><span class="line">          System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>))&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charbuffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>((read = reader.read(charbuffer)) != <span class="number">-1</span>) &#123;  </span><br><span class="line">        System.out.println(Arrays.toString(charbuffer));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OutputStream과-Writer"><a href="#OutputStream과-Writer" class="headerlink" title="OutputStream과 Writer"></a>OutputStream과 Writer</h3><ul>
<li>OutputStream의 주요 메소드(byte 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>b 내용을 byte로 출력</td>
</tr>
<tr>
<td>void write(byte b[])</td>
<td>b를 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(byte b[], int off, int len)</td>
<td>b의 off부터 (off + len - 1)만큼을 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납. close() 내부적으로 flush() 호출</td>
</tr>
<tr>
<td>void flush()</td>
<td>버퍼 스트림에서 버퍼의 내용을 출력하고 비운다.</td>
</tr>
</tbody></table>
<ul>
<li>Writer의 주요 메소드 (char 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>c 내용을 char로 출력</td>
</tr>
<tr>
<td>void write(char cbuf[])</td>
<td>cbuf를 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(char cbuf[], int off, int len)</td>
<td>cbuf의 off부터 (off + len - 1)만큼을 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>str을 출력한다.</td>
</tr>
<tr>
<td>void write(String str, int off, int len)</td>
<td>str의 off부터 (off + len - 1)만큼을 출력</td>
</tr>
<tr>
<td>Writer append(CharSequence csq)</td>
<td>csq를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>Writer append(CharSequence csq, int start, int end)</td>
<td>csq의 start부터 end까지를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>Writer append(char c)</td>
<td>c를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납. close() 내부적으로 flush() 호출</td>
</tr>
<tr>
<td>void flush()</td>
<td>버퍼 스트림에서 버퍼의 내용을 출력하고 비운다.</td>
</tr>
</tbody></table>
<h3 id="다양한-입출력-처리"><a href="#다양한-입출력-처리" class="headerlink" title="다양한 입출력 처리"></a>다양한 입출력 처리</h3><ul>
<li><p>메모리 기반의 입/출력</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> [] memory = <span class="string">&quot;메모리 입출력 테스트 입력&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">char</span> [] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]; <span class="comment">//버퍼는 단순해야 단순하지 않으면 오히려 속도가 떨어진다.</span></span><br><span class="line"><span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 리소스를 두개 사용하는 방법 ;을 사용하여 나누면됨</span></span><br><span class="line"><span class="keyword">try</span> (CharArrayReader reader = <span class="keyword">new</span> CharArrayReader(memory);</span><br><span class="line">     CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter())&#123;</span><br><span class="line">     <span class="keyword">while</span> ((read = reader.read(cbuf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//writer.write(cbuf, 0,read); // (buffer, offset, len)</span></span><br><span class="line">          <span class="comment">// read 길이만큼 들어있는데 이때 몇개를 스킵할 수 있다 그때 사용하는게 offset</span></span><br><span class="line">          <span class="comment">// 1를 첫번째거빼고 2번째거 부터 하게된다는 의미이다. 0은 스킵없이 처음부터 한다는 것이고</span></span><br><span class="line">          <span class="comment">// len은 몇개까지 한다는 것  개수를 정해줘야 한다.</span></span><br><span class="line">          writer.write(cbuf); <span class="comment">//개수를 지정해주지 않으면 메모리에 남아있는게 마지막 문자뒤에 전에 문자가 붙어서 출력됨</span></span><br><span class="line">          <span class="comment">// 여기서는 [메,모,리, ,입,출,력, ,테,스,트, ,입, 력, 트, ] 이런식으로 출력이 된다.</span></span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(Arrays.toString(writer.toCharArray()));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>파일 기반의 입출력</p>
<ul>
<li><p>생성자 및 생성/삭제 메소드</p>
<table>
<thead>
<tr>
<th>생성자 및 메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>pathname에 해당하는 파일 생성. 기본 경로는 애플리케이션의 시작 경로</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>parent 경로 아래 child 파일 생성</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td>parent 경로 아래 child 파일 생성</td>
</tr>
<tr>
<td>File(URI uri)</td>
<td>file로 시작하는 URI 객체를 이용해 파일 생성</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>새로운 파일을 생성</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>새로운 디렉토리를 생성</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>경로상의 모든 디렉토리를 생성</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>파일/디렉토리 삭제</td>
</tr>
<tr>
<td>void deleteOnExit()</td>
<td>애플리케이션 종료시 자동으로 삭제</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String filePath = <span class="string">&quot;D:&quot;</span> + File.separator + <span class="string">&quot;Temp&quot;</span> + File.separator + <span class="string">&quot;MyTemp&quot;</span>;</span><br><span class="line"></span><br><span class="line">File fileOne = <span class="keyword">new</span> File(filePath);</span><br><span class="line">fileOne.mkdir(); <span class="comment">// 가장 하위 폴더만 생성 상위폴더가 없으면 실패</span></span><br><span class="line">fileOne.mkdirs(); <span class="comment">// 경로에 있는 모든 폴더를 생성한다.</span></span><br><span class="line">File fileTwo = <span class="keyword">new</span> File(filePath, <span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line">fileTwo.createNewFile(); <span class="comment">//성공 True 실패 false</span></span><br><span class="line"></span><br><span class="line">File fileThree = <span class="keyword">new</span> File(fileOne, <span class="string">&quot;file3.txt&quot;</span>);</span><br><span class="line">fileThree.createNewFile(); <span class="comment">// fileOne이 path이기 때문에 이것도 사용가능하다.</span></span><br><span class="line"></span><br><span class="line">File fileFour = <span class="keyword">new</span> File(<span class="keyword">new</span> URI(<span class="string">&quot;file:///d:/Temp/MyTemp/file4.txt&quot;</span>));</span><br><span class="line">fileFour.createNewFile();</span><br><span class="line">fileFour.deleteOnExit();</span><br><span class="line"><span class="comment">// Temp 파일을 사용할 때 유용하다, 4번파일을 생성했다가 프로그램이 종료될때 바로 삭제를 한다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>File 클래스의 주요 메소드</p>
<ul>
<li>getName(), getParent(), getParentFile(), getPath()</li>
<li>isAbsolute(), getAbsolutePath(), getCanonicalPath(), toURI()</li>
<li>canRead(), canWrite()</li>
<li>isDirectory(), isFile()</li>
<li>length(), list(), listFiles(), lastModified(), renameTo()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(fileTwo.getName()); <span class="comment">// 파일이름출력</span></span><br><span class="line">System.out.println(fileTwo.getParent()); <span class="comment">// parent에 해당하는 path 출력</span></span><br><span class="line">System.out.println(fileTwo.isAbsolute()); <span class="comment">// 절대 경로를 사용 하는지?</span></span><br><span class="line"><span class="comment">// 상대 경로는 프로그램을 실행하면 그위치에 파일을 만든다던지 그 내부에 만든다던지 할 수 있다</span></span><br><span class="line">    <span class="comment">// 파일을 실행하는 위치로부터 찾아가는 것</span></span><br><span class="line"><span class="comment">// 절대 경로 어디에서 찾아가도 똑같은 경로</span></span><br><span class="line">System.out.println(fileTwo.getAbsolutePath());</span><br><span class="line"><span class="comment">// 시작위치만 정해주고 그내부에서는 ..을 이용하던 다양한 방식으로 표현이가능하다.</span></span><br><span class="line"><span class="comment">// 절대경로라고 해서 우리가 알고있는 d:Temp/MyTemp 이런 형식의 깔끔한 경로가 반드시 나온다고 할 수 는 없다</span></span><br><span class="line"><span class="comment">// 절대 경로이지 표준형은 아닐 수 있다 그래서 깔끔한 경로만 표현해주는게 getCanonicalPath()</span></span><br><span class="line">System.out.println(fileTwo.getCanonicalPath()); <span class="comment">// 깔끔한 경로만 사용한다 , .. 등을 모두 배제한 표준 표현 법 사용</span></span><br><span class="line"><span class="comment">// 두개의 큰 차이는 없다.앱솔루트가 지저분해 질 수 있다 5:07</span></span><br><span class="line">System.out.println(fileOne.isDirectory()); <span class="comment">// 디렉토리를 가리키는지 윈도우즈 이전 도스에서 사용하던 표현 디렉토리</span></span><br><span class="line">System.out.println(fileTwo.isFile()); <span class="comment">// 파일을 가리키는지</span></span><br><span class="line">    </span><br><span class="line">System.out.println(Arrays.toString(fileOne.list())); <span class="comment">// 리스트를 이용해서 그안에 잇는 파일이름들을 다 출력함 String Array로 출력</span></span><br><span class="line"><span class="comment">// [files.txt,files2.txt...]</span></span><br><span class="line">System.out.println(Arrays.toString(fileOne.listFiles())); <span class="comment">// 파일의 경로까지 출력됨 File 객체로 출력이 나옴</span></span><br><span class="line"><span class="comment">// [D:/Temp/MyTemp/files.txt,D:/Temp/MyTemp/files2.txt ...]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>FileInputStream, FileOutputStream</p>
<ul>
<li>파일명이나 File 객체를 이용하여 입출력 스트림 생성 가능</li>
<li>FileOutputStream에서 boolean append를 true로 하면 기존 파일에 이어서 쓴다.</li>
</ul>
</li>
<li><p>FileReader, FileWriter</p>
<ul>
<li>파일명이나 File 객체를 이용하여 입출력 Reader 생성 가능</li>
<li>FileWriter에서 boolean append를 true로 하면 기존 파일에 이어서 쓴다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="보조-스트림"><a href="#보조-스트림" class="headerlink" title="보조 스트림"></a>보조 스트림</h2><h3 id="보조-스트림의-특징"><a href="#보조-스트림의-특징" class="headerlink" title="보조 스트림의 특징"></a>보조 스트림의 특징</h3><ul>
<li>스트림에 부가적인 기능 제공</li>
<li>노드(데이터 소스/목적지)와 직접 연결되지 않고, 다른 스트림과 연결</li>
<li>Stream Chaining : 스트림을 여러개 연결하여 사용</li>
</ul>
<h3 id="보조-스트림의-종류"><a href="#보조-스트림의-종류" class="headerlink" title="보조 스트림의 종류"></a>보조 스트림의 종류</h3><p>| 보조 스트림 | 기능 |<br>| InputStreamReader | byte 스트림을 char 스트림으로 변환 |<br>| OutputStreamWriter |    byte 스트림을 char 스트림으로 변환 |<br>| BufferedReader | 버퍼링을 통해 스트림 속도 향상 |<br>| BufferedWriter | 버퍼링을 통해 스트림 속도 향상 |<br>| BufferedInputStream |    버퍼링을 통해 스트림 속도 향상 |<br>| BufferedOutputStream | 버퍼링을 통해 스트림 속도 향상 |<br>| DataInputStream |    기본 데이터형 전송 |<br>| DataOutputStream | 기본 데이터형 전송 |<br>| ObjectInputStream | 객체 전송 |<br>| ObjectOuputStream | 객체 전송 |<br>| PrintWriter |    문자열 표현으로 출력 |<br>| PrintStream |    문자열 표현으로 출력 |</p>
<h3 id="스트림-자료형-변경"><a href="#스트림-자료형-변경" class="headerlink" title="스트림 자료형 변경"></a>스트림 자료형 변경</h3><ul>
<li>캐릭터셋: utf-8, ms949, euc-kr<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader readerOne = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>);</span><br><span class="line">InputStreamReader readerTwo = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">OutputStreamWriter writerOne = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line">OutputStreamWriter writerTwo = <span class="keyword">new</span> OutputStreamWriter(System.out, <span class="string">&quot;ms949&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="버퍼를-이용한-스트림"><a href="#버퍼를-이용한-스트림" class="headerlink" title="버퍼를 이용한 스트림"></a>버퍼를 이용한 스트림</h3><ul>
<li><p>기본 버퍼 크기: 8192 bytes</p>
</li>
<li><p>버퍼링을 사용하는 원리 </p>
<ul>
<li>입출력장치에 입력을받고출력을받고 해주면 기기를 사용하는데 있어서</li>
<li>한번 입력을 해주고 출력을해줄때 약간의 오버헤드가 발생한다.</li>
<li>키보드의 입력을 눌렀을 때 컴퓨터는 폴링방식을 이용하는데 계속해서 키보드에 있는 버퍼에 접근을 해서</li>
<li>우리가 가져올 데이터가 있는지 계속확인을 한다 매번하게될 경우 성능이 떨어진다 이게 평균전송속도측면에서 떨어지는 것이다.</li>
<li>대신 반응성은 빨라지게 된다. 두개 delay와 throughput은 tradeoff 관계에 있다,</li>
<li>우리가 동작이 빠르게 일어날 필요가 없다면 throughput을 향상시키는게 좋다</li>
<li>예로 파일의 입출력을 하게 될 경우 파일에 넣어서 작성을 할때 파일 즉 하드디스크에 계속 접근을 해서</li>
<li>쓰는 것보다 메모리에 일정량을 써놓고 한번에 하드디스크에 입력을 하는게 더 효율적이다</li>
<li>딜레이가 생겨도 througput이 더 좋은게 이득이여서 버퍼링을 사용하는게 더 이득이다.</li>
</ul>
</li>
<li><p>반응성이 중요한 경우 : 네트워크에서 게임을 한다했을 때 커멘드를 하나하입력할 때 반응성이 더 중요한 경우이다.</p>
</li>
<li><p>반응성이 중요하지 않은 경우(파일입출력, 네트워크 일부 경우(다운로드, 업로드…), 등등)</p>
</li>
<li><p>BufferedReader         ┬ 스트림에 버퍼링을 적용하여 스트림 throughput 형성</p>
</li>
<li><p>BuuferedWriter         ┤ throughput : 평균 전송 속도</p>
</li>
<li><p>BufferedInputStream    ┤ delay :반응성, 버퍼링을 쓸 경우 오히려 안좋아짐(딜레이시간이 길어지는 것이다) (네트워크에서 핑)</p>
</li>
<li><p>BuuferedOutputStream   ┘  서로 트레이드오프 관계에있다.</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> copyStream(InputStream input, OutputStream output) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">byte</span> [] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> ((read = input.read(buff) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    output.write(buff, <span class="number">0</span>, read);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">  File src = <span class="keyword">new</span> File(<span class="string">&quot;C:/Windows/explorer.exe&quot;</span>);</span><br><span class="line">  File dst = <span class="keyword">new</span> File(<span class="string">&quot;C:/temp/explorer.exe&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> (FileInputStream <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">       FileOutputStream out = <span class="keyword">new</span> FileOutputStream(dst);</span><br><span class="line">       BufferedInputStream buffIn = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">in</span>);</span><br><span class="line">       BufferedOutputStream buffOut = <span class="keyword">new</span> BufferedOutputStream(out)) &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    copyStream(<span class="keyword">in</span>, out);</span><br><span class="line">    System.out.println(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    copyStream(buffIn, buffOut);</span><br><span class="line">    System.out.println(System.nanoTime() - start);</span><br><span class="line">    <span class="comment">// 버퍼를 사용하면 throughput이 향상된다.</span></span><br><span class="line">    <span class="comment">// 반응성이 중요하지 않은 경우 거의 반드시 써야한다고 생각하면 된다.</span></span><br><span class="line">    <span class="comment">// 반응성이 중요하면 버퍼를 사용하지 않으면 좋겠다라고 생각하면 됨.</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BufferedReader는 readLine() 메소드를 사용할 수 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File src = <span class="keyword">new</span> File(<span class="string">&quot;./src.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (BufferedReader buffReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));) &#123;</span><br><span class="line">  String line = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="기본-데이터형-전송-스트림"><a href="#기본-데이터형-전송-스트림" class="headerlink" title="기본 데이터형 전송 스트림"></a>기본 데이터형 전송 스트림</h3><ul>
<li>byte, char 외에 다른 기본 데이터형도 전송 가능한 스트림<ul>
<li>읽은 후에는 자료형을 알 수 없으므로 쓴 순서대로 읽어야 함</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>클래스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>DataInputStream</td>
<td>boolean readBoolean()</td>
</tr>
<tr>
<td></td>
<td>byte readByte()</td>
</tr>
<tr>
<td></td>
<td>short readShort()</td>
</tr>
<tr>
<td></td>
<td>int readInt()</td>
</tr>
<tr>
<td></td>
<td>long readLong()</td>
</tr>
<tr>
<td></td>
<td>float readFloat()</td>
</tr>
<tr>
<td></td>
<td>double readDouble()</td>
</tr>
<tr>
<td></td>
<td>char readChar()</td>
</tr>
<tr>
<td></td>
<td>String readUTF()</td>
</tr>
<tr>
<td>DataOutputStream</td>
<td>void writeBoolean(bool v)</td>
</tr>
<tr>
<td></td>
<td>void writeByte(byte v)</td>
</tr>
<tr>
<td></td>
<td>void writeShort(short v)</td>
</tr>
<tr>
<td></td>
<td>void writeInt(int v)</td>
</tr>
<tr>
<td></td>
<td>void writeLong(long v)</td>
</tr>
<tr>
<td></td>
<td>void writeFloat(float v)</td>
</tr>
<tr>
<td></td>
<td>void writeDouble(double v)</td>
</tr>
<tr>
<td></td>
<td>void writeChar(char v)</td>
</tr>
<tr>
<td></td>
<td>void writeUTF(String v)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">File src = <span class="keyword">new</span> File(<span class="string">&quot;c:/Temp/data.dat&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(src))) &#123;</span><br><span class="line">  out.writeUTF(<span class="string">&quot;김자바&quot;</span>);</span><br><span class="line">  out.writeInt(<span class="number">15</span>);</span><br><span class="line">  out.writeFloat(<span class="number">14.23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 중요!! 읽어올 때는 위에 쓴 순서대로 읽어와야한다 그렇지않으면 디코딩이 제대로 이뤄지지 않음</span></span><br><span class="line"><span class="keyword">try</span> (DataInputStream <span class="keyword">in</span> = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(src))) &#123;</span><br><span class="line">  String string = <span class="keyword">in</span>.readUTF();</span><br><span class="line">  <span class="keyword">int</span> integer = <span class="keyword">in</span>.readInt();</span><br><span class="line">  <span class="keyword">float</span> floatNum = <span class="keyword">in</span>.readFloat();</span><br><span class="line">  System.out.println(string + <span class="string">&quot; &quot;</span> + integer + <span class="string">&quot; &quot;</span> + floatNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="객체-저장을-위한-스트림"><a href="#객체-저장을-위한-스트림" class="headerlink" title="객체 저장을 위한 스트림"></a>객체 저장을 위한 스트림</h3><ul>
<li>일반적인 참조형 객체를 저장하기 위한 스트림</li>
<li>직렬화(Serialization)와 역직렬화(Deserialization) 사용<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span> <span class="comment">// has-a 관계의 모든 클래스가 Serializable이어야 함</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L; <span class="comment">// 객체의 버전 관리</span></span><br><span class="line"></span><br><span class="line">  String userName;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">transient</span> String passWord;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> userName + <span class="string">&quot; &quot;</span> + id + <span class="string">&quot; &quot;</span> + passWord;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main (String [] args) &#123;</span><br><span class="line">    File dst = <span class="keyword">new</span> File(<span class="string">&quot;C:/Temp/obj.data&quot;</span>);</span><br><span class="line">    Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">    foo.userName = <span class="string">&quot;김사탕&quot;</span>;</span><br><span class="line">    foo.id = <span class="number">142</span>;</span><br><span class="line">    foo.passWord = <span class="string">&quot;qwer1234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(dst));</span><br><span class="line">        ObjectInputStream <span class="keyword">in</span> = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(dst));) &#123;</span><br><span class="line">      out.writeObject(foo);</span><br><span class="line">      Object read = <span class="keyword">in</span>.readobject();</span><br><span class="line">      <span class="keyword">if</span> (read != <span class="literal">null</span> &amp;&amp; read <span class="keyword">instanceof</span> Foo) &#123;</span><br><span class="line">        Foo readFoo = (Foo)read;</span><br><span class="line">        System.out.println(readFoo);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>부모 클래스가 Serializable이 아닌 경우 자식 클래스에서 직접 처리<ul>
<li>writeObject(), readObject()를 자식 클래스에서 직접 구현<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentFoo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> memVarOne;</span><br><span class="line">  <span class="keyword">double</span> memVarTwo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildFoo</span> <span class="keyword">extends</span> <span class="title">ParentFoo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> writeObject(ObjectOutputStream out) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    out.writeInt(memVarOne);</span><br><span class="line">    out.writeDouble(memVarTwo);</span><br><span class="line">    out.defaultWriteObject();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> readObject(ObjectInputStream <span class="keyword">in</span>) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    memVarOne = <span class="keyword">in</span>.readInt();</span><br><span class="line">    memVarTwo = <span class="keyword">in</span>.readDouble();</span><br><span class="line">    <span class="keyword">in</span>.defaultReadObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/" data-id="ckgm2mncn002mvwu286y639id" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-Java_langPackage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/29/Java/JavaAdvanced/Java-Java_langPackage/" class="article-date">
  <time datetime="2020-09-29T10:43:02.136Z" itemprop="datePublished">2020-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/29/Java/JavaAdvanced/Java-Java_langPackage/">Java_Java-lang Package</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java-lang-패키지"><a href="#java-lang-패키지" class="headerlink" title="java.lang 패키지"></a>java.lang 패키지</h1><h2 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h2><ul>
<li>Java에서 가장 기본적이며 자주 사용되는 클래스를 모은 패키지</li>
<li>별도로 import하지 않아도 사용이 가능한, Java의 기본 중의 기본</li>
</ul>
<h2 id="ObjectClass"><a href="#ObjectClass" class="headerlink" title="ObjectClass"></a>ObjectClass</h2><ul>
<li>모든 클래스의 최상위 클래스</li>
<li>java.lang.Object 클래스</li>
<li>모든 클래스는 Object 클래스에서 상속 받는다.</li>
<li>모든 클래스는 Object 클래스의 메소드를 사용할 수 있다.</li>
<li>모든 클래스는 Object 클래스의 일부 메소드를 재정의하여 사용할 수 있다.<ul>
<li>final로 재정의된 메소드들은 하위클래스에서 재정의 할 수 없기 때문에 일부 메소드만 재정의할 수 있다 라고 하는 것</li>
</ul>
</li>
</ul>
<h3 id="ObjectClass의-메소드"><a href="#ObjectClass의-메소드" class="headerlink" title="ObjectClass의 메소드"></a>ObjectClass의 메소드</h3><table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>public final native Class&lt;?&gt; getClass()</td>
<td>현재 객체의 클래스를 반환한다.</td>
</tr>
<tr>
<td>public native int hashCode()</td>
<td>현재 객체의 해시코드 값을 반환한다.</td>
</tr>
<tr>
<td>public boolean equals()</td>
<td>현재 객체와 대상이 같은 객체를 참조하는지 여부를 반환한다.</td>
</tr>
<tr>
<td>public String toString()</td>
<td>객체를 문자열로 변환하여 반환한다.</td>
</tr>
<tr>
<td>proteted native clone()</td>
<td>throws CloneNotSupportedException 객체를 복사하여 새로운 객체로 반환한다.</td>
</tr>
</tbody></table>
<ul>
<li><p>Object는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 같은 해쉬코드를 가질 수 없지만,<br>String은 문자열의 내용이 같으면 같은 해시코드를 반환하도록 hasCode()가 오버라이딩 되어있다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">Object obj1 = obj;</span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(obj.getClass()); <span class="comment">// Class 클래스 객체를 반환하게 된다.</span></span><br><span class="line">System.out.println(<span class="string">&quot;obj&quot;</span>+obj.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;obj1&quot;</span>+obj1.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;obj2 &quot;</span>+obj2.hashCode());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 힙안에 있는 스트링 풀에 들어감</span></span><br><span class="line">String str2 = str1;</span><br><span class="line">String str3 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//이미 들어가있는 스트링풀을 가리킨다. 그래서 동일한 객체가 된다.</span></span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// new로 만들경우는 새로운 객체를 명시적으로 생성해줬기 때문에 다르다</span></span><br><span class="line">System.out.println(<span class="string">&quot;str1 &quot;</span>+str1.hashCode()); </span><br><span class="line">System.out.println(<span class="string">&quot;str4 &quot;</span>+str4.hashCode());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="toString-메소드"><a href="#toString-메소드" class="headerlink" title="toString() 메소드"></a>toString() 메소드</h4></li>
<li><p>toString()메소드의 원형</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>
</li>
<li><p>객체의 정보를 String으로 바꾸어 사용할 때 유용하다.</p>
</li>
<li><p>자바 클래스 중에는 이미 정의된 클래스가 많다.</p>
<ul>
<li>예 : String, Integer, Calender 등</li>
</ul>
</li>
<li><p>많은 클래스에서 재정의하여 사용한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends Object 된 것과 같다 컴파일 할 때 자동으로 생성이 된다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book(String title, String author)&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> author+<span class="string">&quot;,&quot;</span>+title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Book book =  <span class="keyword">new</span> Book(<span class="string">&quot;토지&quot;</span>,<span class="string">&quot;박경리&quot;</span>);</span><br><span class="line">        System.out.println(book.toString());</span><br><span class="line">        <span class="comment">// toString을 재정의하지 않았을 때, 메모리 주소가 출력된다.</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;토지&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        <span class="comment">// String 안에 이미 toString()메소드가 정의되어 있어서</span></span><br><span class="line">        <span class="comment">// String클래스 안에 있는 Character의 배열을 출력하도록 되어 있다.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="equals-메소드"><a href="#equals-메소드" class="headerlink" title="equals() 메소드"></a>equals() 메소드</h4></li>
<li><p>두 객체의 동일함을 논리적으로 재정의 할 수 있다.</p>
</li>
<li><p>물리적 동일함 : 객체 같은 메모리 주소를 가지는 있다. </p>
</li>
<li><p>논리적 동일함 : 객체가 실제로 같은 값을 가지고 있다.(같은 학번의 학생, 같은 주문 번호의 주문 등)</p>
</li>
<li><p>물리적으로 다른 메모리에 위치한 객체라도 논리적으로 동일함을 구현하기 위해 사용하는 메소드</p>
</li>
<li><p>원래 ObjectClass의 equals()메소드는 <code>==</code>와 똑같이 메모리 주소를 반환하게 되어있다.<br>그래서 객체를 만들 때 equlas() 메소드를 사용했을 때 메모리 주소가 같은지를 확인하게 되어있어서 값이 같은지를 비교하게 하고 싶을 때는<br>재정의하여 사용하면 된다.</p>
</li>
</ul>
<p><img src="../../../image/equals.jpg" alt="equals"></p>
<h5 id="equals-메소드-예제"><a href="#equals-메소드-예제" class="headerlink" title="equals() 메소드 예제"></a>equals() 메소드 예제</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> studentNum;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student(<span class="keyword">int</span> studentNum, String studentName)&#123;</span><br><span class="line">        <span class="built_in">this</span>.studentName = studentName;</span><br><span class="line">        <span class="built_in">this</span>.studentNum = studentNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> equals(Object obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            Student std = (Student)obj;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.studentNum == std.studentNum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Student lee = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="string">&quot;이상원&quot;</span>);</span><br><span class="line">        Student lee2 =lee;</span><br><span class="line">        Student won = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="string">&quot;이상원&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lee == lee2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(lee == won);<span class="comment">//false equals()메소드 재정의 전</span></span><br><span class="line">        System.out.println(lee.equals(won)); <span class="comment">//equals()메소드 재정의 전(false), 후(true) </span></span><br><span class="line"></span><br><span class="line">        System.out.println(lee.hashCode());</span><br><span class="line">        System.out.println(won.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="String-비교-예제"><a href="#String-비교-예제" class="headerlink" title="String 비교 예제"></a>String 비교 예제</h5><ul>
<li>원래 ObjectClass의 equals()메소드는 <code>==</code>와 똑같이 메모리 주소를 반환하게 되어있는데, String클래스에서 재정의했다.<br>그래서 String은 문자열이 같으면 true를 반환하도록 재정의 되어 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//메모리 주소가 같은가 를 확인</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//두개의 문자열이 같은가를 확인</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="hashCode-메소드"><a href="#hashCode-메소드" class="headerlink" title="hashCode() 메소드"></a>hashCode() 메소드</h4><ul>
<li><p>자바에서 JVM이 있는데 인스턴스가 생성이 됬을 때 메모리 주소를 준다. 그 주소 값을 <code>hashCode</code>라고 한다.</p>
</li>
<li><p>hashCode() 메소드의 반환값: 인스턴스가 저장된 가상머신의 주소를 10진수로 반환</p>
</li>
<li><p>두 개의 서로 다른 메모리에 위치한 인스턴스가 동일하다는 것은?</p>
<ul>
<li>논리적으로 동일 : equals()의 반환 값이 true</li>
<li>동일한 hashCode 값을 가짐 : hashCode()의 반환 값이 동일하다.</li>
</ul>
</li>
<li><p><code>navtive</code> 메소드이므로 구현 내용을 볼 수 없다.</p>
<ul>
<li>native : c 또는 c++등 외부 언어로 작성된 메소드 속도 최적화를 위해서 자바로 구현되어 있지 않다!<br>jvm에 종속 되어 있어야 하고 그런 문제가 있어서</li>
</ul>
</li>
<li><p>실제 메모리 값이 아닌 hashCode값이 동일해야 객체들이 동일하다고 말할 수 있다.</p>
</li>
<li><p>실제 메모리 값은 그대로 있다. 단지 overriding만 하는 것이다.</p>
</li>
<li><p>일반적으로 equals를 오버라이딩하면 hasCode도 오버라이딩 한다.</p>
<ul>
<li>equals()의 반환 값이 true 일때, hashcode도 같은 값이 반환될 수 있도록 한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">100</span>;</span><br><span class="line">Integer i2 = <span class="number">100</span>;</span><br><span class="line">System.out.println(i1.equals(i2));</span><br><span class="line">System.out.println(i1.hashCode());</span><br><span class="line">System.out.println(i2.hashCode());</span><br><span class="line"></span><br><span class="line">System.out.println(System.identityHashCode(i1));</span><br><span class="line">System.out.println(System.identityHashCode(i2)); <span class="comment">//진짜 메모리 값 확인하는 메소드</span></span><br></pre></td></tr></table></figure>
<h5 id="hashCode-의-제한-사항"><a href="#hashCode-의-제한-사항" class="headerlink" title="hashCode()의 제한 사항"></a>hashCode()의 제한 사항</h5></li>
</ul>
</li>
<li><p>한 객체의 hashCode()를 여러 번 호출할 경우, equals()에 사용하는 값이 변하지 않으면<br>동일한 값을 반환해야 한다.</p>
</li>
<li><p>equals() 메소드가 같다고 판단한 두 객체의 hashCode() 반환값은 같아야 한다.</p>
</li>
<li><p>equals() 메소드가 다르다고 판단한 두 객체의 hashCode()가 반드시 다를 필요는 없으나,<br>다른 값이 나오면 HashTable 성능이 향상된다.</p>
</li>
</ul>
<h4 id="clone-메소드"><a href="#clone-메소드" class="headerlink" title="clone() 메소드"></a>clone() 메소드</h4><ul>
<li>객체의 복사본을 만듦</li>
<li>기본 틀(prototype)로부터 같은 속성 값을 가진 객체의 복사본을 생성할 수 있음</li>
<li>객체지향 프로그래밍의 정보은닉에 위배될 가능성이 있으므로 복제할 객체는 cloneable 인터페이스를 명시해야 한다.</li>
<li>같은 객체를 동일하게 인스턴스 값을 동일하게 해서 만드는 것</li>
</ul>
<h4 id="join-메소드-과-StringJoiner-클래스"><a href="#join-메소드-과-StringJoiner-클래스" class="headerlink" title="join()메소드 과 StringJoiner 클래스"></a>join()메소드 과 StringJoiner 클래스</h4><ul>
<li><p>join()은 문자열 사이에 구분자를 넣어서 결합한다</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;CCC&quot;</span>&#125;;</span><br><span class="line">String strJoin = String.join(<span class="string">&quot;-&quot;</span>,strArr);</span><br><span class="line">System.out.println(<span class="string">&quot;strJoin &quot;</span>+strJoin);</span><br></pre></td></tr></table></figure>
</li>
<li><p>java.util.StringJoiner 클래스를 사용하여 문자열을 결합한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String <span class="attr">s :</span> strArr)&#123;</span><br><span class="line">    sj.add(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;String Joiner &quot;</span>+ sj);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="기본형에서-String으로-변환"><a href="#기본형에서-String으로-변환" class="headerlink" title="기본형에서 String으로 변환"></a>기본형에서 String으로 변환</h4><ul>
<li>숫자에 빈문자열(“”)을 더하여서 String형으로 변환 시킬 수 있다.</li>
<li>valueOf() 메소드를 사용하여 변환 할 수 있다.</li>
<li>valueOf()의 반환타입은 int가 아니라 Integer지만 오토박싱에 의해 자동변환</li>
<li>valueOf(String s) 는 메소드 내부에 parseInt(String s)를 호출할 뿐이므로,<br>두 메소드는 반환 타입만 다르고 같은 메소드다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="number">100</span> + <span class="string">&quot;&quot;</span>; <span class="comment">// 100 &gt; &quot;100&quot;</span></span><br><span class="line">String str2 = String.valueOf(<span class="number">100</span>); <span class="comment">// 100 &gt; &quot;100&quot;</span></span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;100&quot;</span>) <span class="comment">// &quot;100&quot; &gt; 100</span></span><br><span class="line"><span class="keyword">int</span> i2 = Integer.valueOf(<span class="string">&quot;100&quot;</span>) <span class="comment">// &quot;100&quot; &gt; 100</span></span><br></pre></td></tr></table></figure>

<h5 id="주의"><a href="#주의" class="headerlink" title="주의"></a>주의</h5><ul>
<li>생성자와는 다르다. 생성자는 기본 초기화를 하면서 만드는데 이건 인스턴스의 상태를 그대로 복제하는 것 </li>
<li>private필드까지 다 복제해올 수 있어서 정보은닉에 위배될 수 있어서 객체 복제를 할 때 cloneable 인터페이스가 명시되어 있어야 한다.</li>
<li>clone() 메소드를 사용할 때 object 형으로 반환되므로 다운캐스팅을 해줘야한다.</li>
<li>구현 클래스에 Cloneable 인터페이스를 implements해야 한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>&#123;</span></span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book(String title, String author)&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> author+<span class="string">&quot;,&quot;</span>+title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object clone() <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        Book book =  <span class="keyword">new</span> Book(<span class="string">&quot;토지&quot;</span>,<span class="string">&quot;박경리&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Book book2 =(Book)book.clone();</span><br><span class="line">        <span class="comment">//book.clone()이렇게 했을 때 object 자료형으로 반환이되서</span></span><br><span class="line">        <span class="comment">//명시적으로 다운캐스팅을 해줘야하고 예외처리를 해줘야 한다.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(book2);</span><br><span class="line">        <span class="comment">//그냥하면 예외가 발생함</span></span><br><span class="line">        <span class="comment">// 이유 위에 cloneable 인터페이스를 implements 하지 않아서</span></span><br><span class="line">        <span class="comment">// 이런 인터페이스를 마크인터페이스라고 한다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="finalize-메소드"><a href="#finalize-메소드" class="headerlink" title="finalize() 메소드"></a>finalize() 메소드</h4><ul>
<li>직접 불러서 사용하는 메소드는 아니다.</li>
<li>이 메소드는 객체가 heap 메모리에서 해체될 때, gc에서 호출되는 메소드이다.<br>이게 정의가 되어 있으면 gc가 이 메소드 부분을 수행한다.</li>
<li>주로 리소스 해제, 안 닫혔을 소켓을 닫는다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> finalize() <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="built_in">super</span>.finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><ul>
<li>실행 중인 OS와 interact하기 위한 클래스</li>
<li>System 클래스의 주요 정적 변수</li>
</ul>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>public static final PrintStream err</td>
<td>오류를 출력하기 위한 표준 출력 스트림</td>
</tr>
<tr>
<td>public static final InputStream in</td>
<td>표준 입력을 처리하기 위한 입력 스트림</td>
</tr>
<tr>
<td>public static final PrintStream out</td>
<td>표준 출력을 처리하기 위한 출력 스트림</td>
</tr>
</tbody></table>
<ul>
<li><p>System 클래스의 주요 정적 메소드</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>arraycopy()</td>
<td>src 배열의 내용을 dst 배열로 복사한다.</td>
</tr>
<tr>
<td>currentTimeMillis()</td>
<td>현재 시스템 시간을 ms로 반환한다.</td>
</tr>
<tr>
<td>exit()</td>
<td>프로그램을 종료한다.</td>
</tr>
<tr>
<td>gc()</td>
<td>GC를 요청한다.</td>
</tr>
<tr>
<td>getenv()</td>
<td>환경 변수의 값을 반환한다.</td>
</tr>
<tr>
<td>getProperties()</td>
<td>시스템 속성을 Property로 반환한다.</td>
</tr>
<tr>
<td>getProperty()</td>
<td>시스템 속성 값을 문자열로 반환한다. 없을 경우 null 또는 def를 반환</td>
</tr>
<tr>
<td>identityHashCode()</td>
<td>객체의 해시코드 값을 반환한다.</td>
</tr>
<tr>
<td>lineSeparator()</td>
<td>시스템의 줄넘김 문자열을 반환한다. UNIX: \n, WINDOWS: \r\n</td>
</tr>
<tr>
<td>nanoTime()</td>
<td>시스템 시간을 ns로 반환한다.</td>
</tr>
<tr>
<td>setProperties()</td>
<td>시스템 속성을 한번에 설정한다.</td>
</tr>
<tr>
<td>setProperty()</td>
<td>시스템 속성을 하나씩 설정한다.</td>
</tr>
</tbody></table>
<ul>
<li><p>주요 메소드</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>user.country</td>
<td>OS 로케일 정보</td>
</tr>
<tr>
<td>java.io.tmpdir</td>
<td>임시 경로</td>
</tr>
<tr>
<td>line.separator</td>
<td>줄넘김 문자열</td>
</tr>
<tr>
<td>user.home</td>
<td>유저 홈 경로</td>
</tr>
<tr>
<td>file.separator</td>
<td>파일 경로 구분</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><ul>
<li><p>수학 계산에 필요한 메소드를 가진 final 클래스</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>abs()</td>
<td>절대값을 반환한다.</td>
</tr>
<tr>
<td>ceil()</td>
<td>올림 값을 double로 반환한다.</td>
</tr>
<tr>
<td>floor()</td>
<td>내림 값을 double로 반환한다.</td>
</tr>
<tr>
<td>max()</td>
<td>두 값 중 더 큰 값을 반환한다.</td>
</tr>
<tr>
<td>min()</td>
<td>두 값 중 더 작은 값을 반환한다.</td>
</tr>
<tr>
<td>random()</td>
<td>0 이상 1.0 미만의 임의의 값을 반환한다.</td>
</tr>
<tr>
<td>round()</td>
<td>소수점 첫째자리에서 반올림한 정수 값을 반환한다.</td>
</tr>
<tr>
<td>addExact()</td>
<td>덧셈 연산으로, Overflow 발생 시 ArithmaticException 발생.</td>
</tr>
<tr>
<td>subtractExact()</td>
<td>뺄셈 연산으로, Overflow 발생 시 ArithmaticException 발생.</td>
</tr>
<tr>
<td>multiplyExact()</td>
<td>곱셈 연산으로, Overflow 발생 시 ArithmaticException 발생.</td>
</tr>
</tbody></table>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/29/Java/JavaAdvanced/Java-Java_langPackage/" data-id="ckgm2mnbp001cvwu25taw21er" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-StockPrice/">AlgorithmSolution_StockPrice(주식가격)</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-NotFinishedPlayer/">AlgorithmSolution_완주하지 못한 선수</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-PhoneNumberList/">AlgorithmSolution_전화 번호 목록</a>
          </li>
        
          <li>
            <a href="/2020/10/21/Algorithm/Solution-NumberKth/">AlgorithmSolution_K번째 수</a>
          </li>
        
          <li>
            <a href="/2020/10/18/Java/SW_Enginerring/DesignPatterns/">SW_Enginerring-DesignPatterns</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>