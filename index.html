<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://limjoonchul.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-TIL-20200827" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/27/TIL-20200827/" class="article-date">
  <time datetime="2020-08-27T12:31:23.598Z" itemprop="datePublished">2020-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="오늘의-한-일"><a href="#오늘의-한-일" class="headerlink" title="오늘의 한 일"></a>오늘의 한 일</h1><ul>
<li>HomeworkDay7 Rect 구현하는 것을 이어서 해 봤는데, rot90() 메소드 90도 회전시키는 부분에 대해서 이해가 가지 않았는데 영원이형이 설명을<br>해줘서 이해하게 됬다 원래 나는 원점(0,0) 일때  (0.5,0.7)의 좌표처럼 원점을 (0.4,0.2)의 좌표로<br>옮겨서 원점으로 둔다음에 0.5,0.7 좌표를 (0.9,0.9) 좌표를 둔다음에 (0.4,0.2)를 중심으로 옮기는 것처럼<br>복잡하게 생각을 했었는데, 그것이 아니라 원점(0,0)을 leftbottom 좌표로 두고 사각형을 그려서<br>그걸 90도 회전시키는 것처럼 (0.4,0.2)를 원점으로 두고 leftbottom 좌표로 둬서 사각형을 그려<br>90도를 회전시키는 것이 였다. 이 원리를 이해해도 코드 자체를 직접 구현이 가능 할지는 모르겠다<br>직접 구현이 가능할지 모르겠다는게 이해를 못한 것 일수도 있는데, 좀 더 고민을 해보고 이해를 해야 할<br>것 같다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> rot90(Vector2D pivot) &#123;</span><br><span class="line"></span><br><span class="line">        Vector2D [] oldPoints = getAllPoints();</span><br><span class="line">        Vector2D [] newPoints = <span class="keyword">new</span> Vector2D[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldPoints.length; i++) &#123;</span><br><span class="line">            newPoints[i] = <span class="keyword">new</span> Vector2D(</span><br><span class="line">                    -(oldPoints[i].y - pivot.y) + pivot.x, <span class="comment">// pivot.y는 0,0기준으로 사각형을 만들기 위해서 -를 해주고  뒤에 pivot.x를 더해준다.</span></span><br><span class="line">                    (oldPoints[i].x - pivot.x) + pivot.y  <span class="comment">// A(a,b) -&gt; A&#x27;(-b,a)</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> min_x = newPoints[<span class="number">0</span>].x;</span><br><span class="line">        <span class="keyword">float</span> min_y = newPoints[<span class="number">0</span>].y;</span><br><span class="line">        <span class="keyword">float</span> max_x = newPoints[<span class="number">0</span>].x;</span><br><span class="line">        <span class="keyword">float</span> max_y = newPoints[<span class="number">0</span>].y;</span><br><span class="line">        <span class="keyword">for</span> (Vector2D <span class="attr">vector2D:</span> newPoints) &#123;</span><br><span class="line">            min_x = Math.min(vector2D.x, min_x);</span><br><span class="line">            min_y = Math.min(vector2D.y, min_y);</span><br><span class="line">            max_x = Math.max(vector2D.x, max_x);</span><br><span class="line">            max_y = Math.max(vector2D.y, max_y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="keyword">new</span> Vector2D(min_x, min_y);</span><br><span class="line">        w = max_x - min_x;</span><br><span class="line">        h = max_y - min_y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// write codes here</span></span><br><span class="line"><span class="comment">//        result[0] = new Vector2D ((float)((pos.x - pivot.x)*Math.cos(90))+(float)((pos.y-pivot.y)*-Math.sin(90)),(float)((pos.x - pivot.x)*Math.sin(90))+(float)((pos.y-pivot.y)*Math.cos(90)));</span></span><br><span class="line"><span class="comment">//        result[1] = new Vector2D((float)((pos.x+w - pivot.x)*Math.cos(90))+(float)((pos.y-pivot.y)* -Math.sin(90)),(float)((pos.x+w - pivot.x)*Math.sin(90))+(float)((pos.y-pivot.y)* -Math.cos(90)));</span></span><br><span class="line"><span class="comment">//        result[2] = new Vector2D((float)((pos.x - pivot.x)*Math.cos(90))+(float)((pos.y+h - pivot.y)*-Math.sin(90)),(float)((pos.x - pivot.x)*Math.sin(90))+(float)((pos.y+h - pivot.y)*-Math.cos(90)));</span></span><br><span class="line"><span class="comment">//        result[3] = new Vector2D((float)((pos.x+w- pivot.x)*Math.cos(90))+(float)((pos.y+h -pivot.y)* -Math.sin(90)),(float)((pos.x+w- pivot.x)*Math.sin(90))+(float)((pos.y+h -pivot.y)* -Math.cos(90)));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;LeftBottom - x : &quot;+result[0].x+&quot; y : &quot;+result[0].y);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;RightBottom - x : &quot;+result[1].x + &quot; y : &quot;+result[1].y);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;LeftTop - x : &quot;+result[2].x + &quot; y : &quot;+result[2].y);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;RightTop - x : &quot;+ result[3].x+ &quot; y : &quot;+result[3].y);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>PreCourse 연산자 섹션의 강의 3개를 보고 정리를 했다.</li>
<li>PreCourse를 들으면서 기존수업과 비슷한 섹션에 대해서 github에 내용들을 묶고, 추가했다.</li>
<li>HomeworkDay 9 List를 구현하는데… 강사님이 하셨던 방법대로 해볼려고하는데 정확한 구현원리를 이해하고<br>하는게 아니라 강사님이 했던 방식을 조금 외워서 그걸 그대로 치는 듯이 했다 결국 에러가 생겼는데 해결하지 못함<br>내일 다시 집중해서 이어서 풀어봐야겠다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/27/TIL-20200827/" data-id="ckecsfnfl00096ou224464tbr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL-20200826" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/26/TIL-20200826/" class="article-date">
  <time datetime="2020-08-26T12:29:35.800Z" itemprop="datePublished">2020-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/26/TIL-20200826/">Study20200826</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="오늘의-한-일"><a href="#오늘의-한-일" class="headerlink" title="오늘의 한 일"></a>오늘의 한 일</h1><ul>
<li>fastCampus PreCourse 자바 기초 자바 프로그래밍부터 변수와 데이터 타입에 대해서<br>온라인 강의를 시청했다.</li>
<li>어제 하다가 마무리 못한 HomeworkDay6 Vector3D를 이어서 다시 풀어봤다.</li>
<li>학원 수업 내용과 precourse를 들으면서 똑같은 섹션에 대해서 따로 따로 정리를 할까<br>같이 묶어서 정리를 할까 고민을 계속하다가 결국 하나로 묶기로 했다 아직 다 정리하지 않아서<br>차근차근 정리를 해 나가야 한다.</li>
<li>HomeworkDay7 Rect 구현을 하다가 다 구현하지 못했다. 내일 이어서 마무리하기.</li>
<li>블로그도 따로 만들 것인지, 아니면 그대로 github.io를 사용할 것인지 결정을 내려야 하고<br>그전까진 github.io에 계속 올릴 것이다.</li>
</ul>
<h1 id="프로그래밍-이란"><a href="#프로그래밍-이란" class="headerlink" title="프로그래밍 이란?"></a>프로그래밍 이란?</h1><ul>
<li>프로그래밍 : 컴퓨터에게 일을 시키기 위해 프로그래밍 언어로 만든 명령어,집합인 프로그램을 만드는 일</li>
<li>컴파일: 프로그래밍 언어를 기계어로 바꾸어 주는일</li>
<li>컴파일러 : 기계어로 바꾸어 주는 프로그램, 자바를 설치하면 자바 컴파일러도 설치 됨.<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">자바를 설치를 하면 자바 라이브러리가 설치가되고 구동되는 환경도 설치되고 자바컴파일러도 설치됨</span><br><span class="line">C,C++는 메모리를 직접 핸들링하는 특징들을 가지고 있었고, 이로 인해 프로그램이 비정상적으로</span><br><span class="line">다운되는 일이 있었다 이렇게 되면 가정제품이나, 임베디드 소프트웨어들이 불안정하게 되서</span><br><span class="line">동작을 멈추게 될 수 있음 그래서 더 안전된 언어가 필요했고 그런게 자바다.</span><br><span class="line">처음에 임베디드소프트웨어를 만드는데 활용되다가 점차 영역이 넓어짐</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="다른-언어와의-차이점"><a href="#다른-언어와의-차이점" class="headerlink" title="다른 언어와의 차이점"></a>다른 언어와의 차이점</h2><ul>
<li>플랫폼에 독립적인 프로그래밍을 할 수 있음</li>
</ul>
<h2 id="자바-프로그램의-특징"><a href="#자바-프로그램의-특징" class="headerlink" title="자바 프로그램의 특징"></a>자바 프로그램의 특징</h2><ul>
<li>객체지향 프로그램으로 유지보수와 확장성이 좋고, 안정적이다.</li>
<li>풍부한 라이브러리가 제공되고 오픈소스와 연동된다.</li>
</ul>
<h2 id="왜-객체지향-프로그램을-해야-하는가"><a href="#왜-객체지향-프로그램을-해야-하는가" class="headerlink" title="왜 객체지향 프로그램을 해야 하는가?"></a>왜 객체지향 프로그램을 해야 하는가?</h2><ul>
<li>재사용성이 용이하다 , 코드관리하기가 쉽다, 유지보수 용이, 신뢰성 높은 프로그램</li>
</ul>
<h2 id="자바로-만들-수-있는-프로그램"><a href="#자바로-만들-수-있는-프로그램" class="headerlink" title="자바로 만들 수 있는 프로그램"></a>자바로 만들 수 있는 프로그램</h2><ul>
<li>웹 서버, 모바일 앱, 게임</li>
</ul>
<h1 id="컴퓨터에서-사용하는-자료형"><a href="#컴퓨터에서-사용하는-자료형" class="headerlink" title="컴퓨터에서 사용하는 자료형"></a>컴퓨터에서 사용하는 자료형</h1><h2 id="이진수"><a href="#이진수" class="headerlink" title="이진수"></a>이진수</h2><ul>
<li>비트 : 컴푸터에서 자료를 표현하는 최소 단위 0 또는 1</li>
<li>바이트 : 8bit</li>
<li>이진수 : 컴퓨터에서 표현되는 자료의 형태<pre><code>     0000 1010(이진수) =&gt; 10(십진수)</code></pre>
</li>
<li>8진수 : 이진수를 3비트씩 모아서 표현</li>
<li>16진수: 이진수를 4비트씩 모아서 표현</li>
</ul>
<h2 id="컴퓨터에서-음수-표현하기"><a href="#컴퓨터에서-음수-표현하기" class="headerlink" title="컴퓨터에서 음수 표현하기"></a>컴퓨터에서 음수 표현하기</h2><ul>
<li>2의 보수로 표현한다.</li>
<li>양수와 음수는 더해서 0이 되어야 하기 때문에<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0101(5)</span><br><span class="line">1111 1010(1의 보수)</span><br><span class="line">1111 1011(5에 대한 2의보수)</span><br><span class="line">5와 5에 대한 2의 보수를 더하면 0이 된다.</span><br></pre></td></tr></table></figure></li>
<li>2의 보수를 만드는 방법(음수 만드는 방법) : 1의 보수를 취하고 나서 1을 더해준다.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 1010 =&gt; 10</span><br><span class="line">첫째 자리를 부호 비트라고 표현한다.</span><br></pre></td></tr></table></figure>

<h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><ul>
<li>변하는 수를 말한다. 사람의 나이, 온라인 상품의 개수, 학생의 학년</li>
<li>변하는 값을 프로그램에서 나타내기 위한 방법</li>
</ul>
<h2 id="변수-선언하기"><a href="#변수-선언하기" class="headerlink" title="변수 선언하기"></a>변수 선언하기</h2><ul>
<li>자료형 변수 이름; int age;</li>
<li>변수에 맞는 자료형과 변수 이름으로 선언</li>
<li>변수를 선언만 할 수 있고, 선언과동시에 초기화할 수 있고 여러개도 한번에 선언할 수 있다.</li>
<li>값을 넣지 않고 출력을 하면 사용할 수 없게 표시됨.</li>
</ul>
<h2 id="변수와-메모리"><a href="#변수와-메모리" class="headerlink" title="변수와 메모리"></a>변수와 메모리</h2><ul>
<li>변수를 선언하는 것은 해당 자료형의 크기 만큼의 메모리를 사용하겠다는 것</li>
<li>메모리의 위치를 변수 이름으로 참조<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">변수를 선언한다는게 프로그래밍적으로 어떤 의미이냐 하면</span><br><span class="line">int는 4바이트 인데, 4바이트 짜리 정수값을 써야 할때 int age; 선언한다.</span><br><span class="line">메모리에 4바이트가 잡히고, 메모리를 사용할 때 변수를 사용하겠다는 의미이다.</span><br><span class="line">변수의 사이즈에 맞는 적정한 메모리가 할당이 되고 메모리를 참조할 때 변수의 이름으로 참조한다.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="자료형이란"><a href="#자료형이란" class="headerlink" title="자료형이란"></a>자료형이란</h1><ul>
<li><p>변수의 종류, 타입</p>
</li>
<li><p>기본형(Primitiv Type):  자바 언어에서 기본적으로  제공해 주는 자료형,메모리의 크기가 정해져 있음 EX)정수형, 문자형, 실수형, 논리형</p>
</li>
<li><p>참조형(Reference Type) : 클래스 자료형, JDK에서 제공되는 클래스와 프로그래머가 정의하는 클래스, 클래스에 따라 사용하는 크기가 다르다. EX) String, Student</p>
<table>
<thead>
<tr>
<th></th>
<th>1byte</th>
<th>2byte</th>
<th>4byte</th>
<th>8byte</th>
</tr>
</thead>
<tbody><tr>
<td>정수형</td>
<td>byte</td>
<td>short</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td>문자형</td>
<td></td>
<td>char</td>
<td></td>
<td></td>
</tr>
<tr>
<td>실수형</td>
<td></td>
<td></td>
<td>float</td>
<td>double</td>
</tr>
<tr>
<td>논리형</td>
<td>boolean</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="정수형-자료형"><a href="#정수형-자료형" class="headerlink" title="정수형 자료형"></a>정수형 자료형</h2><ul>
<li>long은 뒤에 L,l을 붙여줘서 8바이트로 사용하는 거라고 알려주는 것</li>
<li>원래는 기본 4바이트로 사용됨.</li>
</ul>
<p>##문자 자료형</p>
<ul>
<li>내부족으로는 비트의 조합으로 표현 </li>
<li>인코딩 - 각 문자에 따른 특정한 숫자 값( 코드값)을 부여</li>
<li>디코딩 - 숫자 값을 원래의 문자로 변환</li>
</ul>
<h3 id="문자-세트"><a href="#문자-세트" class="headerlink" title="문자 세트"></a>문자 세트</h3><ul>
<li>문자세트 : 문자를 위한 코드 값 (숫자 값)들을 정해 놓은 세트</li>
<li>아스키(ASCII) : 1바이트로 영문자, 숫자, 특수문자 등을 표현 함</li>
<li>유니코드(Unicode) : 한글과 같은 복잡한 언어를 표현 하기 위한 표준 인코딩 ex) UTF-8, UTF-16</li>
<li>문자를 변수에 저장하면? 문자에 해당하는 코드 값이 저장 된다</li>
<li>int val = ‘A’ 라 했을 때 65가 저장된다.</li>
</ul>
<h2 id="실수와-논리-자료형"><a href="#실수와-논리-자료형" class="headerlink" title="실수와 논리 자료형"></a>실수와 논리 자료형</h2><ul>
<li><p>실수는 double 자료형이 기분</p>
</li>
<li><p>float를 사용할 때는 f, F 식별자를 사용한다.</p>
</li>
<li><p>실수는 부동 소수점 방식으로 표현</p>
</li>
<li><p>실수를 지수부와 가수부로 표현함</p>
</li>
<li><p>0.1을 표현하는 방식 1.0(가수) * 10(밑수)^-1(지수)</p>
</li>
<li><p>float = 부호비트 + 지수부(8비트) + 가수부(23비트) 총32비트</p>
</li>
<li><p>double = 부호비트 + 지수부(11비트) + 가수부(52비트)  총65비트</p>
</li>
</ul>
<h3 id="부동소수점방식"><a href="#부동소수점방식" class="headerlink" title="부동소수점방식"></a>부동소수점방식</h3><ul>
<li>장점 아주 많은 범위를 실수를 표현할 수 있다</li>
<li>단점은 약간의 오차가 발생할 수 있음</li>
</ul>
<h3 id="부동-소수점-방식의-오류"><a href="#부동-소수점-방식의-오류" class="headerlink" title="부동 소수점 방식의 오류"></a>부동 소수점 방식의 오류</h3><ul>
<li>지수와 가수로 표현되는 부동 소수 점은 0을 표현 할 수 없음</li>
<li>따라서 부동 소수점 방식에서는 약간의 오차가 발생할 수 있음</li>
</ul>
<h2 id="논리-자료형"><a href="#논리-자료형" class="headerlink" title="논리 자료형"></a>논리 자료형</h2><ul>
<li><p>boolean 으로 선언</p>
</li>
<li><p>논리값 true(참), false(거짓)을 표현</p>
</li>
<li><p>자료형 없이 변수 사용하기(자바10)</p>
</li>
<li><p>지역 변수 자료형 추론(local vaiable type inference)</p>
</li>
<li><p>변수에 대입되는 값을 보고 컴파일러가 추론</p>
</li>
</ul>
<h2 id="상수와-리터럴"><a href="#상수와-리터럴" class="headerlink" title="상수와 리터럴"></a>상수와 리터럴</h2><ul>
<li>상수(constant) : 변하지 않는 수</li>
<li>리터럴(literal) : 프로그램에서 사용하는 모든 숫자, 값, 논리 값 ex)10,3.14,’A’,true</li>
<li>모든 리터럴은 상수 풀(constant pool)에 저장되어 있음</li>
<li>상수 풀에 저장될 때 정수는 int, 실수는 double로 저장됨</li>
</ul>
<h2 id="형-변환"><a href="#형-변환" class="headerlink" title="형 변환"></a>형 변환</h2><ul>
<li>서로 다른 자료형의 값이 대입되는 경우 형 변환이 일어 남</li>
<li>묵시적 형 변환(implicit type conversion) : 작은 수에서 큰 수로 더 정밀한 수에서 더 정밀한 수로 대입되는 경우<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">byte</span> bNum = (<span class="keyword">byte</span>)i;</span><br><span class="line"><span class="comment">//데이터의 유실이 발생할 수 있다.</span></span><br><span class="line">System.out.println(bNum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dNum1 = <span class="number">1.2</span>;</span><br><span class="line"><span class="keyword">float</span> fNum = <span class="number">0.9</span>f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iNum1 = (<span class="keyword">int</span>)(dNum1 + fNum);</span><br><span class="line"><span class="keyword">int</span> iNum2 = (<span class="keyword">int</span>)dNum1 + (<span class="keyword">int</span>)fNum;</span><br><span class="line"><span class="comment">// 두개의 결과 값이 다름</span></span><br></pre></td></tr></table></figure></li>
<li>명시적 형 변환(explict type conversion): 변환되는 자료 형을 몃이 자료의 손실이 발생할 수 있다<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> bNum = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> iNum = bNum;</span><br><span class="line"></span><br><span class="line">System.out.println(bNum);</span><br><span class="line">System.out.println(iNum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iNum2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">float</span> fNum = iNum2;</span><br><span class="line"></span><br><span class="line">System.out.println(fNum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dNum;</span><br><span class="line">dNum = fNum + iNum;</span><br><span class="line">System.out.println(dNum);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/26/TIL-20200826/" data-id="ckecsfnfj00086ou2ccb0fglq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL-20200825" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/25/TIL-20200825/" class="article-date">
  <time datetime="2020-08-25T11:12:43.521Z" itemprop="datePublished">2020-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/25/TIL-20200825/">Study20200825</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ObjectClass"><a href="#ObjectClass" class="headerlink" title="ObjectClass"></a>ObjectClass</h1><h2 id="ObjectClass란"><a href="#ObjectClass란" class="headerlink" title="ObjectClass란"></a>ObjectClass란</h2><ul>
<li>모든 클래스의 최상위 클래스</li>
<li>java.lang.Object 클래스</li>
<li>모든 클래스는 Object 클래스에서 상속 받음</li>
<li>모든 클래스는 Object 클래스의 메소드를 사용할 수 있음</li>
<li>모든 클래스는 Object 클래스의 일부 메소드를 재정의하여 사용할 수 있음<ul>
<li>final로 재정의된 메소드들은 하위클래스에서 재정의 할 수 없기 때문에 일부 메소드만 재정의할 수 있다 라고 하는 것</li>
</ul>
</li>
</ul>
<h2 id="ObjectClass의-메소드"><a href="#ObjectClass의-메소드" class="headerlink" title="ObjectClass의 메소드"></a>ObjectClass의 메소드</h2><h3 id="toString-메소드"><a href="#toString-메소드" class="headerlink" title="toString() 메소드"></a>toString() 메소드</h3><ul>
<li>toString()메소드의 원형</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>

<ul>
<li>객체의 정보를 String으로 바꾸어 사용할 때 유용함</li>
<li>자바 클래스중에는 이미 정의된 클래스가 많음</li>
<li>예 : String, Integer, Calender 등</li>
<li>많은 클래스에서 재정의하여 사용<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends Object 된 것과 같다 컴파일할 때 자동으로 생성이됨</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book(String title, String author)&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> author+<span class="string">&quot;,&quot;</span>+title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Book book =  <span class="keyword">new</span> Book(<span class="string">&quot;토지&quot;</span>,<span class="string">&quot;박경리&quot;</span>);</span><br><span class="line">        System.out.println(book.toString());</span><br><span class="line">        <span class="comment">// 메모리주소가 출력됨.</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;토지&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="equals-메소드"><a href="#equals-메소드" class="headerlink" title="equals() 메소드"></a>equals() 메소드</h3><ul>
<li>두 객체의 동일함을 논리적으로 재정의 할 수 있음</li>
<li>물리적 동일함 : 같은 주소를 가지는 객체</li>
<li>논리적 동일함 : 같은 학번의 학생, 같은 주문 번호의 주문</li>
<li>물리적으로 다른 메모리에 위치한 객체라도 논리적으로 동일함을 구현하기 위해 사용하는 메소드</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> studentNum;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student(<span class="keyword">int</span> studentNum, String studentName)&#123;</span><br><span class="line">        <span class="built_in">this</span>.studentName = studentName;</span><br><span class="line">        <span class="built_in">this</span>.studentNum = studentNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> equals(Object obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            Student std = (Student)obj;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.studentNum == std.studentNum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Student lee = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="string">&quot;이상원&quot;</span>);</span><br><span class="line">        Student lee2 =lee;</span><br><span class="line">        Student won = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="string">&quot;이상원&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lee == lee2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(lee == won);<span class="comment">//false</span></span><br><span class="line">        System.out.println(lee.equals(won)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(lee.hashCode());</span><br><span class="line">        System.out.println(won.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode-메소드"><a href="#hashCode-메소드" class="headerlink" title="hashCode() 메소드"></a>hashCode() 메소드</h3><ul>
<li><p>자바에서 JVM이 있는데 인스턴스가 생성이 됬을 때 메모리 주소를 준다.<br>그 주소값을 <code>hashCode</code>라고 한다.</p>
</li>
<li><p>hashCode() 메소드의 반환값: 인스턴스가 저장된 가상머신의 주소를 10진수로 반환</p>
</li>
<li><p>두 개의 서로 다른 메모리에 위치한 인스턴스가 동일하다는 것은?</p>
<ul>
<li>논리적으로 동일 : equals() 의 반환값이 true</li>
<li>동일한 hashCode 값을 가짐 : hashCode()의 반환 값이 동일 </li>
</ul>
</li>
<li><p>실제 메모리 값이 아닌 hashCode값이 동일해야 객체들이 동일하다고 말할 수 있다.</p>
</li>
<li><p>실제 메모리값은 그대로 있다. 단지 overriding만 하는 것이다.</p>
</li>
<li><p>일반적으로 equals를 오버라이딩하면 hasCode도 오버라이딩 한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">100</span>;</span><br><span class="line">Integer i2 = <span class="number">100</span>;</span><br><span class="line">System.out.println(i1.equals(i2));</span><br><span class="line">System.out.println(i1.hashCode());</span><br><span class="line">System.out.println(i2.hashCode());</span><br><span class="line"></span><br><span class="line">System.out.println(System.identityHashCode(i1));</span><br><span class="line">System.out.println(System.identityHashCode(i2)); <span class="comment">//진짜 메모리주소 확인하는 메소드</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="clone-메소드"><a href="#clone-메소드" class="headerlink" title="clone() 메소드"></a>clone() 메소드</h3><ul>
<li>객체의 복사본을 만듦</li>
<li>기본 틀(prototype)으로 부터 같은 속성 값을 가진 객체의 복사본을 생성할 수 있음</li>
<li>객체지향 프로그래밍의 정보은닉에 위배되는 가능성이 있으므로 복제할 객체는 cloneable 인터페이스를<br>명시해야 함.</li>
<li>같은 객체를 동일하게 인스턴스 값을 동일하게 해서 만드는 것</li>
</ul>
<h4 id="주의"><a href="#주의" class="headerlink" title="주의"></a>주의</h4><p>생성자와는 다름 생성자는 기본 초기화를하면서 만드는데 이건 인스턴스의 상태를 그대로 복제하는 것<br>private필드까지 다 복제해올 수 있어서 정보은닉에 위배될 수 있어서 객체복제를 할 때<br>cloneable인터페이스가 명시되어 있어야 한다.</p>
<ul>
<li>clone() 메소드를 사용할 때 object 형으로 반환되므로 다운캐스팅을 해줘야한다</li>
<li>구현 클래스에 Cloneable인터페이스를 implements해야 한다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>&#123;</span></span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book(String title, String author)&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> author+<span class="string">&quot;,&quot;</span>+title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object clone() <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        Book book =  <span class="keyword">new</span> Book(<span class="string">&quot;토지&quot;</span>,<span class="string">&quot;박경리&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Book book2 =(Book)book.clone();</span><br><span class="line">        <span class="comment">//book.clone()이렇게 했을 때 object 자료형으로 반환이되서</span></span><br><span class="line">        <span class="comment">//명시적으로 다운캐스팅을 해줘야하고 예외처리를 해줘야 한다.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(book2);</span><br><span class="line">        <span class="comment">//그냥하면 예외가 발생함</span></span><br><span class="line">        <span class="comment">// 이유 위에 cloneable 인터페이스를 implements 하지 않아서</span></span><br><span class="line">        <span class="comment">// 이런 인터페이스를 마크인터페이스라고 한다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###finalize() 메소드</p>
<ul>
<li>직접 불러서 사용하는 메소드는 아니다.</li>
<li>이메소드는 이 객체가 heap메모리에서 해체될 때</li>
<li>gc에서 호출되는 메소드 이게 정의가 되어있으면 gc가 이 메소드 부분을 수행한다.</li>
<li>주로 리소스해제, 안닫혔을 소켓을 닫는다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> finalize() <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="built_in">super</span>.finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Class-클래스"><a href="#Class-클래스" class="headerlink" title="Class 클래스"></a>Class 클래스</h1><ul>
<li>자바의 모든 클래스와 인터페이스는 컴파일 후 class파일로 생성됨</li>
<li>class 파일에는 객체의 정보(멤버 변수, 메소드, 생성자 등) 가 포함되어 있음</li>
<li>Class 클래스는 컴파일된 class파일에서 객체의 정보를 가져올 수 있음</li>
<li>동적로딩할 때 주로 사용하고 Class클래스를 이용해서 코딩할 일이 많지는 않다.</li>
<li>이미 내 로컬PC에는 내가 사용하고자하는 라이브러리들이 있고 라이브러리들이 자료형을 다<br>알고 있는 상태이기 때문에</li>
</ul>
<h2 id="Class-클래스-가져오기"><a href="#Class-클래스-가져오기" class="headerlink" title="Class 클래스 가져오기"></a>Class 클래스 가져오기</h2><ol>
<li>String s = new String();<br>Class c = s.getClass(); //object의 메소드 Class 클래스를 가져옴</li>
<li>Class c = String.Class; //  컴파일된 상태로 있는 경우 </li>
<li>Class c = Class.forName(“java.lang.String”); //동적로딩<ul>
<li>대부분 컴파일 할 때 시스템에서 어떤 애들을 가져다 쓸것인지 컴파일타임에 거의다 바인딩이된다(정적로딩)<br>스태틱으로 다 바인딩이 된다 그런데 클래스.forName은 런타임때 바인딩이 됨(동적로딩)<br>클래스.forName(“이름”) 이름에 해당하는 클래스가 로컬에 있으면 불러다가 사용할 수 있다.</li>
</ul>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">자바에서 jdbc를 사용할 때 관련 db라이브러리(orcale, mysql, mssql) 같은 것들이 있는데</span><br><span class="line">그런 라이브러리들을 모두 스태틱하게 링크해서 컴파일 할 수 없음 </span><br><span class="line">너무 많은 라이브러리들을 링크해서 사용해야 하는건데 그럴 필요없이 라이브러리들을 install 한 </span><br><span class="line">상태에서 필요할 때 부를수 있게 끔 oracle과 연결이될거다 orcacle 이름이 들어가면 된다.</span><br></pre></td></tr></table></figure>
<ul>
<li>장점 : 런타임 때 그때그때상황에맞게 라이브러리를 매칭시킬 수 있다는 것</li>
<li>단점 : 오타가나면 로딩되다가 클래스를 찾을 수없은 예외가 나타나서 런타임때 오류가날수 있다.</li>
</ul>
<h2 id="reflection-프로그래밍"><a href="#reflection-프로그래밍" class="headerlink" title="reflection 프로그래밍"></a>reflection 프로그래밍</h2><ul>
<li>Class 클래스로부터 객체의 정보를 가져와 프로그래밍 하는 방식</li>
<li>로컬에 객체가 없고 자료형을 알 수 없는 경우 유용한 프로그래밍</li>
<li>java.lang.reflect 패키지에 있는 클래스 활용</li>
</ul>
<h2 id="newInstance-메소드"><a href="#newInstance-메소드" class="headerlink" title="newInstance()메소드"></a>newInstance()메소드</h2><ul>
<li>Class 클래스 메소드</li>
<li>new 키워들 ㄹ사용하지 않고 인스턴스를 생성</li>
</ul>
<h2 id="forName-메소드와-동적로딩"><a href="#forName-메소드와-동적로딩" class="headerlink" title="forName() 메소드와 동적로딩"></a>forName() 메소드와 동적로딩</h2><ul>
<li>Class 클래스 static 메소드</li>
<li>동적로딩이란? <ul>
<li>컴파일 시에 데이터 타입이 모두 binding 되어 자료형이 로딩되는 것(static loding)이 아니라 실행 중에 데이터 타입을 알고 binding 되는 방식</li>
</ul>
</li>
<li>실행 시에 로딩되므로 경우에 따라 다른 클래스가 사용될 수 있어 유용하다.</li>
<li>컴파일 타임에 체크할 수 없으므로 해당 문자열에 대한 클래스가 없는 경우 예외(ClassNotFoundException)이 발생 할 수 있다.</li>
</ul>
<h2 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class 클래스에서 class.forName을 주의 깊게 봐야 한다.</span><br><span class="line"></span><br><span class="line">다른 언어들도 동적로딩하는 방법이 있다.</span><br><span class="line"></span><br><span class="line">스태틱으로 컴파일타임에 다 어떤걸쓰는지 바인딩되는 그런 방법도 있고,</span><br><span class="line">런타임 때 내가 쓸걸 로딩해서 쓰는 방법도 있고 언어들마다 제공되고 있다.</span><br><span class="line"></span><br><span class="line">자바에서 동적바인딩은 class.forName으로 제공되고있다.</span><br></pre></td></tr></table></figure>

<h1 id="오늘의-배운점"><a href="#오늘의-배운점" class="headerlink" title="오늘의 배운점"></a>오늘의 배운점</h1><ul>
<li>this.studentNum == std.stduentNum 과 main method의 System.out.println(lee == won) 의 조건문이 같은 값들을 비교하는 걸로 착각함</li>
<li><code>this.studentNum == std.stduentNum</code> : 이건 객체의 변수가 같은걸 비교하는 것이다</li>
<li><code>lee == won</code> : 이건 객체 자체를 비교하는 것</li>
<li>객체의 변수를 비교하는 것과 객체 자체를 비교하는 것인데 그걸 생각하지 않고 혼자서 왜 같은걸 비교하고 있지라고 생각하고 있었다…</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> studentNum;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student(<span class="keyword">int</span> studentNum, String studentName)&#123;</span><br><span class="line">        <span class="built_in">this</span>.studentName = studentName;</span><br><span class="line">        <span class="built_in">this</span>.studentNum = studentNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> equals(Object obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            Student std = (Student)obj;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.studentNum == std.studentNum)&#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Student lee = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="string">&quot;이상원&quot;</span>);</span><br><span class="line">        Student lee2 =lee;</span><br><span class="line">        Student won = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="string">&quot;이상원&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lee == lee2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(lee == won);<span class="comment">//false</span></span><br><span class="line">        System.out.println(lee.equals(won)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>String은 예상한대로 결과 값이 나오는데 객체를 가지고 하는 비교는 예상과 달랐다. 모르는 부분을 배운 것 같다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//메모리 주소가 같은가 를 확인 false</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//두개의 문자열이 같은가를 확인 true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>여기서 newInstance()는 반환하면 object 타입이다 그래서 다운캐스팅을 해줘야 한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Class.forName(<span class="string">&quot;ClassEx.Person&quot;</span>);</span><br><span class="line">        Person person1 = (Person) c1.newInstance();</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
</li>
<li><p>로컬에서 person이라는 타입을 쓸 수 없는 경우 이렇게 사용</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] initargs = &#123;<span class="string">&quot;김유신&quot;</span>&#125;;</span><br><span class="line">Person personLee = (Person) cons.newInstance(initargs);</span><br><span class="line">System.out.println(personLee);</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;토지&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="comment">//String 안에 이미 toString()메소드가 정의되어 있어서</span></span><br><span class="line"><span class="comment">// String클래스 안에 있는 Chararcter의 배열을 출력하도록 되어 있다.</span></span><br><span class="line"></span><br><span class="line">Book book2 =(Book)book.clone();</span><br><span class="line"><span class="comment">//book.clone()이렇게 했을 때 object 자료형으로 반환이되서</span></span><br><span class="line"><span class="comment">//명시적으로 다운캐스팅을 해줘야하고 예외처리를 해줘야 한다.</span></span><br><span class="line"></span><br><span class="line">System.out.println(book2);</span><br><span class="line"><span class="comment">//그냥하면 예외가 발생함</span></span><br><span class="line"><span class="comment">// 이유 위에 cloneable 인터페이스를 implements 하지 않아서</span></span><br><span class="line"><span class="comment">// 이런 인터페이스를 마크인터페이스라고 한다.</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/25/TIL-20200825/" data-id="ckecsfnfi00076ou26v6mffmc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL-20200823" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/25/TIL-20200823/" class="article-date">
  <time datetime="2020-08-25T11:10:27.984Z" itemprop="datePublished">2020-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/25/TIL-20200823/">Study20200823</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="온라인-강의들으며-복습"><a href="#온라인-강의들으며-복습" class="headerlink" title="온라인 강의들으며 복습"></a>온라인 강의들으며 복습</h3><h1 id="추상-클래스"><a href="#추상-클래스" class="headerlink" title="추상 클래스"></a>추상 클래스</h1><ul>
<li>추상메소드를 포함한 클래스<ul>
<li>추상 메소드 - 구현 코드가 없이 선언부만 있는 메소드</li>
</ul>
</li>
</ul>
<h2 id="추상클래스-특징"><a href="#추상클래스-특징" class="headerlink" title="추상클래스 특징"></a>추상클래스 특징</h2><ul>
<li>abstract 예약어 사용</li>
<li>추상클래스는 new(인스턴스화) 할 수 없다.</li>
<li>추상클래스는 단독으로 사용되는 것이아니라 상위클래스로서 사용된다</li>
<li>공통적으로 사용할 수 있는 메소드들은 사용할 수 있다.</li>
<li>구현해야하는 메소드들은 사위클래스에서 선언을 해놓고,<br>구현의 책임을 하위클래스에 위임한다.</li>
<li>하나의 추상메소드라도 포함을 하면 추상클래스가 되야 한다.</li>
<li>추상메소드가없어도 abstract 키워드를 사용하면 추상클래스가 된다</li>
</ul>
<h2 id="추상클래스-구현"><a href="#추상클래스-구현" class="headerlink" title="추상클래스 구현"></a>추상클래스 구현</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> display();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> typing(); <span class="comment">//하위클래스에서 구현됨.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> turnOn()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;전원을 켭니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> turnOff()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;전원을 끕니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>추상클래스의 일반메소드들은 하위클래스들이 공통으로 사용하는 메소드들이고<br>추상메소드들은 하위클래스에서 구현해서 사용해야하는 메소드들이다.<br>하나라도 하위클래스에서 추상메소드가 구현이 안되어있다면 error가 난다.</p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>추상클래스는 주로 상속의 상위클래스로 사용된다</li>
<li>추상메소드 - 하위클래스가 구현해야 하는 메소드</li>
<li>구현된 메소드- 하위클래스가 공통으로 사용하는 기능의 메소드, 하위클래스에 따라 재정의할 수 있음.</li>
</ul>
<h1 id="템플릿-메소드"><a href="#템플릿-메소드" class="headerlink" title="템플릿 메소드"></a>템플릿 메소드</h1><ul>
<li>템플릿 - 틀이나 견본을 의미한다</li>
<li>템플릿메소드 - 추상메소드나 구현된 메소드를 활용하여 전체의 흐름(시나리오)를 정의해 놓은 메소드<br>final로 선언하여 재정의 할 수 없게 한다.</li>
</ul>
<h2 id="템플릿-메소드-패턴"><a href="#템플릿-메소드-패턴" class="headerlink" title="템플릿 메소드 패턴"></a>템플릿 메소드 패턴</h2><ul>
<li>디자인 패턴의 일종으로 프레임워크에서 많이 사용되는 설계패턴이다</li>
<li>추상클래스로 선언된 상위클래스에서 추상메소드를 이용하여 전체 구현의 흐름을 정의하고<br>구체적인 각 메소드 구현은 하위클래스에 위임함 </li>
<li>하위클래스가 다른 구현을 했 다고 해서 템플릿 메소드에 정의된 시나리오대로 수행됨.</li>
</ul>
<h2 id="final-예약어"><a href="#final-예약어" class="headerlink" title="final 예약어"></a>final 예약어</h2><ul>
<li>fianl 변수는 값이 변경될 수 없는 상수이다.</li>
<li>public static final double PI = 3.14;</li>
<li>오직 한번만 값을 할당 할 수 있음</li>
<li>final 메소드는 하위 클래스에서 재정의(overriding) 할 수 없음.</li>
<li>final 클래스는 더 이상 상속되지 않음</li>
<li>상속이 됬을 때 문제가 될 수도 있고 고유한 기능이 있는 경우 상속 할 일이 없다면 <code>final</code>을 붙이면 된다<h3 id="public-static-final-상수-값-정의해-사용하기"><a href="#public-static-final-상수-값-정의해-사용하기" class="headerlink" title="public static final 상수 값 정의해 사용하기"></a>public static final 상수 값 정의해 사용하기</h3></li>
<li>프로젝트 구현 시 여러 파일에서 공유해야 하는 상수 값은 하나의 파일에 선언해 사용하면 편리</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/25/TIL-20200823/" data-id="ckecsfnff00056ou2h34eb0ru" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL-20200820" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/25/TIL-20200820/" class="article-date">
  <time datetime="2020-08-25T11:06:45.580Z" itemprop="datePublished">2020-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/25/TIL-20200820/">Study20200820</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="온라인-강의들으며-복습"><a href="#온라인-강의들으며-복습" class="headerlink" title="온라인 강의들으며 복습"></a>온라인 강의들으며 복습</h3><h1 id="메모리-할당-시점"><a href="#메모리-할당-시점" class="headerlink" title="메모리 할당 시점"></a>메모리 할당 시점</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">변수가 메모리에 생성될 때는 초기화가 이루어지는 시점인데, 초기화가 되는 시점은</span><br><span class="line">클래스나 메소드에서 초기화 값을 준다고 해도 메모리에 생성이 되는게 아니다.</span><br><span class="line">변수를 선언하는 것은 메모리를 자료형의 크기만큼 쓰겠다라고 하는 것이다(메모리에 공간 확보)</span><br><span class="line">변수 초기화는 메모리에 실제 값을 할당 하는 것이다.</span><br><span class="line">메인 메소드안에 있는 변수들은 실행될 때 메모리에 생성됨.</span><br><span class="line">정적 변수 - 클래스가 생성이 될 때 메모리에 할당이 된다.</span><br></pre></td></tr></table></figure>

<h1 id="상속과-다형성"><a href="#상속과-다형성" class="headerlink" title="상속과 다형성"></a>상속과 다형성</h1><ul>
<li>상속과 다형성에 대해 이해를 잘하게 되면 유지보수하기 쉽고 확장성 있는 시스템을 설계할 수 있다.</li>
<li>객체지향프로그래밍의 큰 특징 중 하나이다.</li>
<li>상속, 추상클래스, 인터페이스까지 쭉 이어지는 내용이므로 확실히 이해하는게 중요!!</li>
</ul>
<h2 id="상속이란"><a href="#상속이란" class="headerlink" title="상속이란"></a>상속이란</h2><ul>
<li>새로운 클래스를 정의할 때 이미 구현된 클래스를 상속(Inheritance) 받아서<br>속성이나 기능이 확장된 클래스를 구현함.</li>
<li>코드의 재사용이 되긴 하지만 코드의 재사용 방법이라고 이해하면 안된다 조금 다름.</li>
<li>상속은 일반적인 클래스가 있고 이것보다 좀 더 기능이 구체적인 클래스를 설계한다.<br>유사한 클래스를 만드는데 기존의 클래스를 가져다가 좀 더 확장된 클래스를 만들 때 사용.</li>
<li>extends 키워드를 사용하고 extends 키워드 뒤에는 단 하나의 class만 사용 가능,<br>다중 상속이 불가능 하다.</li>
</ul>
<h3 id="상속에서-클래스의-제어자"><a href="#상속에서-클래스의-제어자" class="headerlink" title="상속에서 클래스의 제어자"></a>상속에서 클래스의 제어자</h3><ul>
<li>private를 사용하면 상속받은 관계에서도 사용할 수가 없다. 그래서 상속하기 위해 protected 제어자를 사용함.<br>(다른 외부 클래스에서 사용할 수 없지만 자식클래스는 사용이 가능하기 때문에)</li>
</ul>
<h3 id="상속-클래스의-이름"><a href="#상속-클래스의-이름" class="headerlink" title="상속 클래스의 이름"></a>상속 클래스의 이름</h3><ul>
<li>상속하는 클래스를 상위클래스, 부모클래스, 슈퍼클래스라고 한다.</li>
<li>상속받는 클래스를 하위클래스, 자식클래스, 서브클래스 등의 다양한 이름으로 불린다.</li>
</ul>
<h3 id="상속에서의-메모리-상태"><a href="#상속에서의-메모리-상태" class="headerlink" title="상속에서의 메모리 상태"></a>상속에서의 메모리 상태</h3><ul>
<li>상위 클래스의 인스턴스가 메모리에 먼저 생성이 되고, 하위클래스의 인스턴스가 생성된다</li>
</ul>
<h3 id="상속에서-클래스-생성-과정과-형-변환"><a href="#상속에서-클래스-생성-과정과-형-변환" class="headerlink" title="상속에서 클래스 생성 과정과 형 변환"></a>상속에서 클래스 생성 과정과 형 변환</h3><ul>
<li>하위 클래스가 생성되는 과정<ul>
<li>하위클래스가 생성될 때 상위 클래스가 먼저 생성된다</li>
<li>상위클래스의 생성자가 호출되고 하위 클래스의 생성자가 호출 된다</li>
<li>하위클래스의 생성자에서는 무조건 상위 클래스의 생성자가 호출 되어야 한다</li>
<li>하위클래스에서 상위클래스의 생성자를 호출하는 코드가 없는 경우, 컴파이럴에서 자동으로 super()를 추가함.<ul>
<li>(super() 상위클래스를 호출 할때 사용하는 키워드)</li>
</ul>
</li>
</ul>
</li>
<li>만약 상위 클래스의 기본생성자가 없는 경우 (파라미터 생성자만 존재하는 경우)<br>클래스는 명시적으로 상위클래스의 생성자를 호출해줘야만 한다.</li>
</ul>
<h3 id="상위클래스로의-묵시적-형변환-업-캐스팅"><a href="#상위클래스로의-묵시적-형변환-업-캐스팅" class="headerlink" title="상위클래스로의 묵시적 형변환(업 캐스팅)"></a>상위클래스로의 묵시적 형변환(업 캐스팅)</h3><ul>
<li>상위 클래스 형으로 변수를 선언하고 하위 클래스 인스턴스를 생성 할 수 있다.</li>
<li>하위클래스는 상위클래스의 타입을 내포하고 있으므로 상위 클래스로 묵시적 형변환이 가능하다</li>
<li>상속관계에서 모든 하위클래스는 상위클래스로 묵시적 형 변환이 된다, 그 반대는 성립하지 않는다.</li>
</ul>
<h2 id="메소드-오버라이딩"><a href="#메소드-오버라이딩" class="headerlink" title="메소드 오버라이딩"></a>메소드 오버라이딩</h2><h3 id="오버라이딩이란"><a href="#오버라이딩이란" class="headerlink" title="오버라이딩이란"></a>오버라이딩이란</h3><ul>
<li>상위 클래스에서 정의된 메소드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않은 경우<br>하위클래스에서 동일한 이름의 메소드를 재정의할 수 있다.</li>
<li>이미 구현된 코드를 다른 코드로 재구현한다, 덮어씌운다는 의미이다.</li>
</ul>
<h3 id="애노테이션-Annotation"><a href="#애노테이션-Annotation" class="headerlink" title="@ 애노테이션(Annotation)"></a>@ 애노테이션(Annotation)</h3><ul>
<li>재정의된 메소드라는 의미로 선언부가 기존의 메소드와 다른 경우 에러가 발생한다.(같게 해줘야 함)</li>
<li>애노테이션은 컴파일러에게 특정한 정보를 제공해주는 역할을 한다<ul>
<li>(컴파일 오류를 막아주고, 컴파일러에게 정보를 전달해줌.)</li>
</ul>
</li>
<li>주로 사용되는 자바에서 제공되는 애노테이션</li>
</ul>
<table>
<thead>
<tr>
<th>애노테이션</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>@Override</td>
<td>재정의된 메소드라는 정보 제공</td>
</tr>
<tr>
<td>@FuctionalInterface</td>
<td>함수형 인터페이스라는 정보 제공</td>
</tr>
<tr>
<td>@Deprecated</td>
<td>이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨</td>
</tr>
<tr>
<td>@SupperessWarnings</td>
<td>특정 경고가 나타나지 않도록 함 ex) @SupperessWarnings(“deprecations”)는 @Depreacted가 나타나지 않도록 함.</td>
</tr>
</tbody></table>
<h3 id="형-변환과-오버라이딩-메소드-호출"><a href="#형-변환과-오버라이딩-메소드-호출" class="headerlink" title="형 변환과 오버라이딩 메소드 호출"></a>형 변환과 오버라이딩 메소드 호출</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Customer vc = <span class="keyword">new</span> VIPCustomer();</span><br><span class="line">vc.calcPrice(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<p>위 코드에서 <code>calcPrice()</code> 메소드는 어느 메소드에서 호출 될까?<br>자바에서 항상 인스턴스의 메소드가 호출이 된다.<br>그 이유는 <code>Virtual method Call</code>이 이루어지기 때문이다.</p>
<h4 id="Virtual-method-Call이란"><a href="#Virtual-method-Call이란" class="headerlink" title="Virtual method Call이란"></a>Virtual method Call이란</h4><p> 메소드의 이름과 메소드 주소를 가진 가상 메소드 테이블에서 호출될 메소드의 주소를 참조한다.<br> 멤버함수는 생성된 객체의 메모리를 참조하기 때문에 가상메소드가 되서 VIPCostomer의 calcPrice를 참조하게 된다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Customer customerLee = <span class="keyword">new</span> Customer(<span class="number">10010</span>,<span class="string">&quot;이순신&quot;</span>);</span><br><span class="line">customerLee.bonusPoint=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">VIPCustomer customerKim = <span class="keyword">new</span> VIPCustomer(<span class="number">10020</span>,<span class="string">&quot;김유신&quot;</span>);</span><br><span class="line">customerKim.bonusPoint = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> priceLee = customerLee.calcPrice(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">int</span> priceKim = customerKim.calcPrice(<span class="number">10000</span>);</span><br><span class="line">System.out.println(customerLee.showCustomerInfo() +<span class="string">&quot;지불금액은 &quot;</span>+priceLee);</span><br><span class="line"><span class="comment">//이순신님의 등급은 Silver이며, 적립된 보너스 포인트는 1100점 입니다.지불금액은 10000</span></span><br><span class="line"></span><br><span class="line">System.out.println(customerKim.showCustomerInfo()+<span class="string">&quot;지불금액은 &quot;</span>+priceKim);</span><br><span class="line"><span class="comment">//김유신님의 등급은 VIP이며, 적립된 보너스 포인트는 10500점 입니다.지불금액은 9000</span></span><br><span class="line"></span><br><span class="line">Customer customerNo = <span class="keyword">new</span> VIPCustomer(<span class="number">10030</span>,<span class="string">&quot;나몰라&quot;</span>);</span><br><span class="line">customerNo.bonusPoint=<span class="number">10000</span>;</span><br><span class="line">System.out.println(customerNo.showCustomerInfo()+<span class="string">&quot;지불금액은 &quot;</span>+customerNo.calcPrice(<span class="number">10000</span>));</span><br><span class="line"><span class="comment">//나몰라님의 등급은 VIP이며, 적립된 보너스 포인트는 10000점 입니다.지불금액은 9000</span></span><br><span class="line"><span class="comment">// 지불금액이 예상하기로 10000이 나와야하지만 결과는 9000이나옴 이유는 vipcustomer의 calcPrice()메소드가 호출되었기 때문에 이것을 가상메소드호출이라 한다.</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/25/TIL-20200820/" data-id="ckecsfnfe00046ou26ccf3oti" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL-20200819" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/25/TIL-20200819/" class="article-date">
  <time datetime="2020-08-25T11:05:14.170Z" itemprop="datePublished">2020-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/25/TIL-20200819/">Study20200819</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="온라인-강의들으며-복습"><a href="#온라인-강의들으며-복습" class="headerlink" title="온라인 강의들으며 복습"></a>온라인 강의들으며 복습</h3><h1 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h1><h2 id="배열이란"><a href="#배열이란" class="headerlink" title="배열이란"></a>배열이란</h2><ul>
<li>자료구조의 일종으로 가장 기본적이면서도 단순한 구조고 많이 쓰는 구조이다.</li>
<li>자료들을 모아두는 방식이다. 동일한 자료형의 순차적 자료 구조이다.</li>
<li>배열은 크기가 고정되어 있음. 배열의 크기를 바꾸고 싶을 때는 새로운 배열을 만들어서<br>복사해서 사용해야 한다.</li>
<li>장점 첨자연산이 빠르다.</li>
<li>배열은 물리적인 위치와 논리적인 위치가 순서가 동일하다.(순차적,연속적)</li>
<li>배열을 만들면 메모리를 보면 첫인덱스의 시작 주소부터 자료형의 크기만큼 딱 딱 그 주소가<br>떨어져 있음.</li>
<li>동일하지 않는 것도 있다 (LinkedList - 개수에 제한이 덜하다.)</li>
</ul>
<h2 id="배열-선언"><a href="#배열-선언" class="headerlink" title="배열 선언"></a>배열 선언</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>선언과 동시에 값을 넣어주는 것은 경우에만 new int[]가 생략될 수 있고<br>선언하고 밑에 예제처럼 초기화하는 것은 안됨.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span>[] arr;</span><br><span class="line">  arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">````  </span><br><span class="line"></span><br><span class="line">* 배열의 각 요소들을 초기화 해주지 않으면 자료형의 기본값으로 초기화 된다</span><br><span class="line">```groovy</span><br><span class="line">   <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> <span class="attr">i :</span> arr)&#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">double</span>[] dArr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</span><br><span class="line">   dArr[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">   dArr[<span class="number">1</span>] = <span class="number">2.1</span>;</span><br><span class="line">   dArr[<span class="number">2</span>] = <span class="number">3.1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">double</span> total = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dArr.length; i++)&#123;</span><br><span class="line">        total *= dArr[i];</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(total); <span class="comment">// 0이나온다</span></span><br><span class="line">   <span class="comment">//이유 인덱스 0,1,2까지만 값을 넣어주고 나머지 3,4는 넣어주지 않았을 때</span></span><br><span class="line">   <span class="comment">//자동으로 빈값은 0.0으로 초기화 됨. 그래서 곱해도 0이 나옴.</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">* 객체 배열 객체들이 연속된 자료형으로 있을 때 기본 자료형 배열과 참조 자료형 배열의 차이</span><br><span class="line">   * 객체 배열은 선언만했을 때 안에 <span class="literal">null</span>값을 갖는데 나중에 생성할 객체의 주소를 담는 공간이다.</span><br><span class="line"></span><br><span class="line">## arraycopy() </span><br><span class="line">* System의 <span class="keyword">static</span> method 한 배열에 있던 값들을 다른 배열의 값에 넣을 때 사용하는 메소드.</span><br><span class="line">* System.arraycopy(기존배열,기존배열에서 옮길 값의 시작 인덱스, 옮길배열, 옮길배열의 시작 인덱스, 몇개를 옮길 것인지);</span><br><span class="line">````groovy</span><br><span class="line"> <span class="keyword">int</span>[] arr1 = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"> <span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,&#125;;</span><br><span class="line"> System.arraycopy(arr1,<span class="number">0</span>,arr2,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr2.length; i++)&#123;</span><br><span class="line">     System.out.println(arr2[i]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="다차원-배열"><a href="#다차원-배열" class="headerlink" title="다차원 배열"></a>다차원 배열</h2><ul>
<li>2차원 이상의 배열</li>
<li>지도, 게임, 평면이나 공간을 구현할 때 사용 <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> [][]arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(arr.length); 배열의 개수</span></span><br><span class="line"><span class="comment">//System.out.println(arr[0].length); 배열의 첫번째 인덱스안의 개수</span></span><br><span class="line"><span class="comment">//System.out.println(arr[1].length); 배열의 두번째 인덱스안의 개수</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr[i].length; j++)&#123;</span><br><span class="line">            System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ArrayList-클래스"><a href="#ArrayList-클래스" class="headerlink" title="ArrayList 클래스"></a>ArrayList 클래스</h2><ul>
<li><p>자바에서 제공되는 객체 배열이 구현된 클래스</p>
</li>
<li><p>객체 배열을 사용하는데 필요한 여러 메소드들이 구현되어 있음</p>
</li>
<li><p>배열의 길이와 ArrayList 사이즈의 차이</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 총갯수는 size로 꺼낼수 있는데 배열은 length로 꺼낼 수 있는데</span></span><br><span class="line"><span class="comment">// size와 length의 차이점</span></span><br><span class="line"><span class="comment">// 배열은 길이가 10개고 요소가 3개만 들어있어도 length는 10이지만,</span></span><br><span class="line"><span class="comment">// size는 요소가 들어가 있는 개수만큼이다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">     System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String <span class="attr">s :</span> list)&#123;</span><br><span class="line">     System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="오늘-코딩할-때-고칠점"><a href="#오늘-코딩할-때-고칠점" class="headerlink" title="오늘 코딩할 때 고칠점"></a>오늘 코딩할 때 고칠점</h1><ul>
<li>배운 증감연산자를 활용해서 코드의 길이를 줄일 수 있었지만, 아직 활용하는 것에 익숙하지 않아서 놓쳤다,<br>이런 사소한 부분까지 신경써서 작성하는 습관을 길러야겠다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> []alphabets = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;alphabets.length; i++)&#123;</span><br><span class="line">   alphabets[i] = ch++;</span><br><span class="line">   <span class="comment">//ch++; 이렇게 다음줄에 ch++ 안해도 되고 바로 윗줄에 연산자를 이용해서 ++해주면 됨</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">//System.out.println(alphabets[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;alphabets.length; i++)&#123;</span><br><span class="line">    System.out.println(alphabets[i]+<span class="string">&quot;,&quot;</span>+(<span class="keyword">int</span>)alphabets[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>사소한 실수이지만, 반환값이 void인 메소드를 이미 메소드안에 출력값이 있으니 그냥 호출만하면되는데<br>print문안에 넣어서 출력을 하려고 하는 실수를 했다. 신경쓰자!<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Book[] libarary = <span class="keyword">new</span> Book[<span class="number">5</span>];</span><br><span class="line">Book[] copyLibrary = <span class="keyword">new</span> Book[<span class="number">5</span>];</span><br><span class="line">  </span><br><span class="line">libarary[<span class="number">0</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥1&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">libarary[<span class="number">1</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥2&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">libarary[<span class="number">2</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥3&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">libarary[<span class="number">3</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥4&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">libarary[<span class="number">4</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥5&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">  </span><br><span class="line">System.arraycopy(libarary,<span class="number">0</span>,copyLibrary,<span class="number">0</span>,libarary.length);</span><br><span class="line"><span class="keyword">for</span> (Book <span class="attr">i :</span> copyLibrary)&#123;</span><br><span class="line">i.showBookInfo(); <span class="comment">// showBookInfo()가 void형이고 안에 출력문이 있기 때문에</span></span><br><span class="line"><span class="comment">//System.out.println(i.showBookInfo()); 이런형식으로 쓰는게 안된다.</span></span><br><span class="line"><span class="comment">// 자꾸 생각없이 쓰니 이런 형식으로 쓰게 된다 주의하자!</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="얕은-복사-깊은-복사"><a href="#얕은-복사-깊은-복사" class="headerlink" title="얕은 복사 / 깊은 복사"></a>얕은 복사 / 깊은 복사</h2><h3 id="얕은-복사"><a href="#얕은-복사" class="headerlink" title="얕은 복사"></a>얕은 복사</h3><ul>
<li>얕은 복사 인스턴스가 새로 생성되서 복사하는게 아니라 주소만 복사하는 것</li>
<li>두개의 객체배열이 똑같은 주소를 가지고 있기 때문에 하나만 변경되도 같이 변경된다.</li>
<li>가르키고 있는 주소의 값들을 변경하는 것이기 때문에.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Book[] libarary = <span class="keyword">new</span> Book[<span class="number">5</span>];</span><br><span class="line">Book[] copyLibrary = <span class="keyword">new</span> Book[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">libarary[<span class="number">0</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥1&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">libarary[<span class="number">1</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥2&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">libarary[<span class="number">2</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥3&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">libarary[<span class="number">3</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥4&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line">libarary[<span class="number">4</span>] = <span class="keyword">new</span> Book(<span class="string">&quot;태백산맥5&quot;</span>,<span class="string">&quot;조정래&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.arraycopy(libarary,<span class="number">0</span>,copyLibrary,<span class="number">0</span>,libarary.length);</span><br><span class="line">  </span><br><span class="line">libarary[<span class="number">0</span>].setTitle(<span class="string">&quot;나목&quot;</span>);</span><br><span class="line">libarary[<span class="number">0</span>].setAuthor(<span class="string">&quot;박완서&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Book <span class="attr">book :</span> libarary)&#123;</span><br><span class="line">    book.showBookInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Book <span class="attr">book :</span> copyLibrary)&#123;</span><br><span class="line">    book.showBookInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="깊은-복사"><a href="#깊은-복사" class="headerlink" title="깊은 복사"></a>깊은 복사</h3><ul>
<li>깊은 복사 새로운 객체를 생성해줘서 값을 넣어주는 것.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">copyLibrary[<span class="number">0</span>] = <span class="keyword">new</span> Book();</span><br><span class="line">copyLibrary[<span class="number">1</span>] = <span class="keyword">new</span> Book();</span><br><span class="line">copyLibrary[<span class="number">2</span>] = <span class="keyword">new</span> Book();</span><br><span class="line">copyLibrary[<span class="number">3</span>] = <span class="keyword">new</span> Book();</span><br><span class="line">copyLibrary[<span class="number">4</span>] = <span class="keyword">new</span> Book();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;libarary.length; i++)&#123;</span><br><span class="line">    copyLibrary[i].setAuthor(libarary[i].getAuthor());</span><br><span class="line">    copyLibrary[i].setTitle(libarary[i].getTitle());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;++++++++++++++++++&quot;</span>);</span><br><span class="line">libarary[<span class="number">0</span>].setTitle(<span class="string">&quot;나목&quot;</span>);</span><br><span class="line">libarary[<span class="number">0</span>].setAuthor(<span class="string">&quot;박완서&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Book <span class="attr">book :</span> libarary)&#123;</span><br><span class="line">    book.showBookInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Book <span class="attr">book :</span> copyLibrary)&#123;</span><br><span class="line">   book.showBookInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/25/TIL-20200819/" data-id="ckecsfnfc00036ou2el8p3q00" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL-20200817" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/25/TIL-20200817/" class="article-date">
  <time datetime="2020-08-25T11:04:18.635Z" itemprop="datePublished">2020-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/25/TIL-20200817/">Study20200817</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="온라인-강의들으며-복습"><a href="#온라인-강의들으며-복습" class="headerlink" title="온라인 강의들으며 복습"></a>온라인 강의들으며 복습</h3><h1 id="상속-Inheritance"><a href="#상속-Inheritance" class="headerlink" title="상속 (Inheritance)"></a>상속 (Inheritance)</h1><ul>
<li>어떤 클래스의 모든 멤버 변수 및 메소드를 계승하여, 새로운 클래스를 생성하는 것</li>
<li>부모클래스로부터 상속을 받는 자식클래스는 부모클래스의 메소드나 멤버변수등 부모의 것을 가지고 있고, 추가적으로 자기의 것들도 가질 수 있다. ‘IS-A’관계라고도 한다.</li>
</ul>
<h1 id="클래스의-포함-관계"><a href="#클래스의-포함-관계" class="headerlink" title="클래스의 포함 관계"></a>클래스의 포함 관계</h1><p>– 클래스를 조합해서 클래스를 만든다. Class Composition</p>
<ul>
<li><p>상속하고 유사하지만, 한 클래스가 다른 클래스의 객체를 포함하는 관계<br>‘HAS-A’ 관계라고 표현된다. </p>
</li>
<li><p>상속과 컴포지션의 차이 - 일치하냐, 보유하냐</p>
</li>
</ul>
<h1 id="메소드-재정의-method-overriding"><a href="#메소드-재정의-method-overriding" class="headerlink" title="메소드 재정의 method overriding"></a>메소드 재정의 method overriding</h1><ul>
<li>override – 덮어씌운다, 해킹해서 뭔가 달라지게 한다. 기존에 있던걸 덮어씌워서 다른걸로 변형시키는 것. 다형성의 근간이 된다.</li>
<li>상속받는 자식클래스에 메소드를 재정의할 때 @Override를 적어주는 것이 관례이다, (필수x)</li>
</ul>
<h1 id="super-키워드"><a href="#super-키워드" class="headerlink" title="super 키워드"></a>super 키워드</h1><ul>
<li><p>호출할 때 this와 마찬가지로 첫줄에 써야함.</p>
</li>
<li><p>this는 자신의 객체를 참조하고, super는 부모 객체를 참조한다.</p>
</li>
<li><p>부모의 부모는 참조할 수 없고, 바로 위의 부모만 참조할 수 있음.</p>
</li>
<li><p>멤버 변수명이 부모와 겹치면 재정의 하지만, 부모가 사라지는 것은 아니다.</p>
</li>
<li><p>부모클래스에 기본 생성자를 사용하는 경우에는 호출 안해줘도 됨. 파라미터 생성자일 때만<br>호출해주면 된다.</p>
</li>
<li><p>부모클래스 생성자와 다르게 파라미터 변수명을 해줘야 한다.</p>
</li>
<li><p>부모 객체를 먼저 생성한다음, 자식객체가 생성됨.</p>
</li>
<li><p>자식클래스 생성자를 만들 때 부모 클래스 생성자도 같이 호출해줘야한다.</p>
</li>
<li><p>자식객체를 생성할 때마다 부모 객체를 따로따로 만들어서 가지고 있음.</p>
</li>
</ul>
<h1 id="제어자"><a href="#제어자" class="headerlink" title="제어자"></a>제어자</h1><ul>
<li>자바 파일명과 같은 public class 클래스명이 꼭 있어야 한다.</li>
<li>private – 같은 클래스에서만 사용가능, 내부 구현을 위해서만 사용한다.</li>
<li>default – package라고도 한다 제어자명은 생략한다. 사용범위가 같은 패키지안에서 가능.</li>
<li>protected – private와 비슷하게 사용이 되나, 상속한 경우 구현 시 접근이 필요할 때 사용.<pre><code>      자식이면 다른 패키지여도 접근할 수가 있다, 하나의 자식외에는 못봄,
      부모의 부모는 건들 수 없음.</code></pre>
</li>
<li>public – 모든 곳에서 사용가능.</li>
<li>클래스는 public 과 default만 사용 가능하다.</li>
</ul>
<h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><p>– 오버로딩에 의한 다형성, 오버라이딩에 의한 다형성(상속에 의한 다형성과 같다.)</p>
<ul>
<li><p>부모 클래스 타입으로 자식 클래스 타입의 객체를 참조하는 특징.</p>
</li>
<li><p>자식 클래스의 메소드,변수 사용이 불가능하다.</p>
</li>
<li><p>반대로 자식 클래스 타입으로 부모 클래스 타입의 객체를 참조할 경우에는 문법적으로 오류는<br>나지 않지만, 런타임시 에러가 발생한다.</p>
</li>
<li><p>멤버 변수의 재정의는 선언된 객체의 타입을 따른다. 문법적으로 본다.</p>
</li>
<li><p>메소드 오버라이딩은 메모리상의 객체 타입을 따른다. 실제 객체로 본다.</p>
</li>
<li><p>virtual method call이 이루어진다.</p>
</li>
</ul>
<h1 id="공변-반환-타입"><a href="#공변-반환-타입" class="headerlink" title="공변 반환 타입"></a>공변 반환 타입</h1><ul>
<li>오버라이딩이지만, 리턴 타입이 달라질 수 있다 여기서는 예외적으로 반환값이 달라진다.</li>
</ul>
<h1 id="추상클래스"><a href="#추상클래스" class="headerlink" title="추상클래스"></a>추상클래스</h1><ul>
<li>일부 메소드가 구현되지 않고, 선언만 되어있는 클래스 </li>
<li>자식 클래스에서 이것을 반드시 구현하게끔 강제하는 것</li>
<li>생성자를 가질 수 있고, 일반 메소드도 가질 수 있다. </li>
<li>생성자를 갖지만, 객체 생성이 불가능하다. 그런데 구현된 자식클래스의 객체는 받을 수 있다.</li>
</ul>
<h1 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h1><ul>
<li>클래스가 사용되는 방식/접점만을 선언하는 클래스와 유사한 틀</li>
<li>아무런 구현이 되어 있지 않으며, 모든 메소드가 추상 메소드이다.</li>
<li>생성자를 가질 수 없고, 객체 생성을 할 수 없음.</li>
<li>자식 객체는 참조할 수 있으나 메소드와 변수는 사용 X</li>
<li>인터페이스명으로 클래스 메소드 호출이 가능하나, </li>
<li>자식클래스명으로 클래스 메소드 호출 불가능.</li>
<li>class가 아니고 interface 키워드를 사용한다.</li>
<li>멤버 변수는 항상 public static final 인데, 생략이 가능하다.</li>
<li>멤버 메소드도 항상 public abstract 이며, 생략이 가능하다.</li>
<li>클래스는 하나만 상속할 수 있으나, 인터페이스는 다중 상속이 가능하다.</li>
<li>클래스와 마찬가지로 제어자는 public,default 가능. </li>
</ul>
<p>JDK 1.8 버전 이후에 인터페이스 default 메소드를 구현할 수 있음.<br>인터페이스 철학과 맞지 않으나, 모든 자식 메소드에 동일하게 구현되어야 하는 메소드가 생긴 경우에 쉽게 기능을 추가하기 위해 만들어짐.<br>default메소드는 반드시 오버라이딩해야하는 것은 아니다.</p>
<h1 id="열거형-enumeration"><a href="#열거형-enumeration" class="headerlink" title="열거형 enumeration"></a>열거형 enumeration</h1><p>enum 키워드로 표현, ‘이넘’이라고 부른다.<br>enum은 이미 java.lang.Enum 클래스를 상속하고 있어서 다른 클래스를 상속하지 못함.<br>인터페이스 구현은 가능하다.<br>열거형 타입에는 열거형 상수와 null 값 할당 가능.<br>일종의 클래스 자료형으로 쓸 수 있고, 열거형 상수도 객체로 사용 가능.<br>생성자가 있을 수 있는데 앞에 private만 쓸 수 있고 생략 가능.<br>생성자는 String을 입력 받게 되어있는데, 각각 만들 때 각 객체에 값을 넣어줘야 함.</p>
<h1 id="제네릭"><a href="#제네릭" class="headerlink" title="제네릭"></a>제네릭</h1><ul>
<li>클래스를 선언할 때에는 타입이 알려지지 않으며, 타입 파라미터를 사용한다.</li>
<li>생성자 있고, 객체 참조 가능. 인터페이스, 추상클래스 상속 가능.</li>
<li>정적 메소드도 사용이 가능하다. 다만, 클래스와 정적메소드의 타입파라미터를 갖게 하면 안된다.</li>
<li>생성자도 갖을 수 있음.</li>
<li>타입의 상속시 부모와 자식클래스의 타입을 맞추어 줘야 한다. 타입 파라미터도 모두 채워 주어야 한다. 부모클래스/인터페이스의 동일한 타입 파라미터를 넘겨줄 수 있다.</li>
<li>static 멤버 변수, static 메소드는 타입파라미터를 사용할 수 없다.(왜냐하면, static은 객체가 생성되기 전에 메모리에 할당되는데 메모리에 할당되려면 타입이 있어야 하고, 타입 파라미터는 객체를 선언할 때 값이 넘어오기 때문에)</li>
<li>new 키워드를 사용하여 객체를 참조할 수 없다.</li>
<li>instanceof의 피연산자로 사용할 수 없다.</li>
</ul>
<h1 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h1><ul>
<li>메소드가 생길 때 자료형이랑 정의되어 있어서 기계가 동작하게 만들어지게 정상적인데, 자료형이 정해져있지 않아서 들어오는거에 따라 동작이 달라짐.<br>실제로 런타임이 되지 않으면 컴파일 타임이 알 수 없음.( 컴파일 타임에는 동작이 완전히 정의가 되지 않음)</li>
</ul>
<h1 id="wrapper-클래스"><a href="#wrapper-클래스" class="headerlink" title="wrapper 클래스"></a>wrapper 클래스</h1><ul>
<li>기본형 타입을 객체로 쓰기 위해 있는 클래스</li>
<li>기본형을 객체로 사용할 수 있게 하는 것을 - &gt; Autoboxing</li>
<li>객체를 기본형으로 바꾸는 것을 -&gt; Unboxing</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/25/TIL-20200817/" data-id="ckecsfnf800016ou2fgrs61db" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL-20200824" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/25/TIL-20200824/" class="article-date">
  <time datetime="2020-08-25T11:01:48.000Z" itemprop="datePublished">2020-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/25/TIL-20200824/">Study20200824</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="온라인-강의들으며-복습"><a href="#온라인-강의들으며-복습" class="headerlink" title="온라인 강의들으며 복습"></a>온라인 강의들으며 복습</h3><h1 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h1><h2 id="인터페이스란"><a href="#인터페이스란" class="headerlink" title="인터페이스란"></a>인터페이스란</h2><ul>
<li>클래스를 사용하는 방식, 접점만을 선언하는 클래스와 유사한 틀</li>
<li>인터페이스라는 것은 어떤 객체 오브젝트의 명세라고 보면된다<br>인터페이스가 어떤 객체를 제공할것이다 어떤객체다라고 설명하는 설명서와 같다<br>인터페이스는 프로젝트를할때 설계단계에서 많이 사용함.</li>
</ul>
<h2 id="인터페이스의-특징"><a href="#인터페이스의-특징" class="headerlink" title="인터페이스의 특징"></a>인터페이스의 특징</h2><ul>
<li>기존 클래스와의 차이점은 추상메소드로만 이루어져 있다.</li>
<li>구현코드가 들어가지 않아서 new(인스턴스화)될 수 없다.</li>
<li>변수를 선언하게되면 변수를 선언한것과 같지만 멤버변수는 인스턴스가생성되고 힙영역에<br>메모리가 잡혀야하는데 인터페이스는 추상메소드로 이루어져있어서 인스턴스화가 될수 없음<br>그래서 인터페이스의 모든 변수는 상수가 된다.</li>
<li>Java 8이후에 디폴트메소드, 정적메소드, private메소드가 생김<br>인터페이스가 구현을 갖지 못하니깐 인터페이스를 구현하게 되는 클래스들이 중복된 구현을 하게 되는데<br>중복을 막기 위해 생긴 메소드들이다.</li>
</ul>
<h2 id="인터페이스의-요소"><a href="#인터페이스의-요소" class="headerlink" title="인터페이스의 요소"></a>인터페이스의 요소</h2><ul>
<li>상수: 선언된 모든 변수는 상수로 처리됨</li>
<li>메소드 : 모든 메소드는 추상 메소드</li>
<li>디폴트 메소드 : 기본 구현을 가지는 메소드 구현하는 클래스에서 재정의 할 수 있음(java 8)</li>
<li>정적 메소드 : 인스턴스 생성과 상관없이 인터페이스 타입으로 호출하는 메소드(java 8)</li>
<li>private 메소드 : 인터페이스 내에서 사용하기 위해 구현한 메소드<br>구현하는 클래스에서 재정의 할 수 없음(java9)</li>
</ul>
<h2 id="인터페이스-선언과-구현"><a href="#인터페이스-선언과-구현" class="headerlink" title="인터페이스 선언과 구현"></a>인터페이스 선언과 구현</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">인터페이스 선언과 구현</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calc</span>&#123;</span></span><br><span class="line">  <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">  <span class="keyword">int</span> ERROR = <span class="number">-99999999999</span>;  </span><br><span class="line"> <span class="comment">// 인터페이스에서 선언한 변수는 컴파일 과정에서 상수로 변환됨</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> add(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2);</span><br><span class="line">  <span class="keyword">int</span> substract(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2);</span><br><span class="line">  <span class="keyword">int</span> times(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2);</span><br><span class="line">  <span class="keyword">int</span> divide(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2); </span><br><span class="line"><span class="comment">// 인터페이스에서 선언한 메소드는 컴파일 과정에서 추상메소드로 변환됨</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="타입-상속과-형-변환"><a href="#타입-상속과-형-변환" class="headerlink" title="타입 상속과 형 변환"></a>타입 상속과 형 변환</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calc calc = <span class="keyword">new</span> CompleteCalc();</span><br></pre></td></tr></table></figure>
<ul>
<li>인터페이스를 구현한 클래스는 인터페이스 타입으로 변수를 선언하여 인스턴스를 생성할 수 있음<br>인터페이스는 구현 코드가 없기 때문에 타입 상속이라고도 함.</li>
</ul>
<h2 id="인터페이스를-활용한-다형성-구현하기"><a href="#인터페이스를-활용한-다형성-구현하기" class="headerlink" title="인터페이스를 활용한 다형성 구현하기"></a>인터페이스를 활용한 다형성 구현하기</h2><ul>
<li>주로 설계할 때 사용한다. 인터페이스가 정의되어있고 구현한 클래스들이 있을텐데 클래스들을<br>사용할 때 다양한 클래스들을 사용할 수 있는데 다형성과 관련되어있다</li>
</ul>
<h2 id="인터페이스의-역할은"><a href="#인터페이스의-역할은" class="headerlink" title="인터페이스의 역할은?"></a>인터페이스의 역할은?</h2><ul>
<li>인터페이스는 클라이언트 프로그램에 어떤 메소드를 제공하는지 알려주는 명세 또는 약속</li>
<li>한 객체가 어떤 인터페이스의 타입이라 함은 그 인터페이스의 메소드를 구현했다는 의미</li>
<li>클라이언트 프로그램은 실제 구현 내용을 몰라도 인터페이스의 정의만 알면 그 객체를<br>사용할 수 있음</li>
<li>인터페이스를 구현해 놓은 다양한 객체를 사용함 - 다형성<ul>
<li>JDBC를 구현한 오라클, MSSQL라이브러리 등</li>
</ul>
</li>
</ul>
<h2 id="인터페이스와-strategy-pattern"><a href="#인터페이스와-strategy-pattern" class="headerlink" title="인터페이스와 strategy pattern"></a>인터페이스와 strategy pattern</h2><ul>
<li>인터페이스를 활용하면 다양한 정책이나 알고리즘을 프로그램의 큰 수정 없이 적용, 확장할 수 있음</li>
</ul>
<h2 id="여러-개의-인터페이스-구현하기"><a href="#여러-개의-인터페이스-구현하기" class="headerlink" title="여러 개의 인터페이스 구현하기"></a>여러 개의 인터페이스 구현하기</h2><ul>
<li>인터페이스는 구현 코드가 없으므로 하나의 클래스가 여러 인터페이스를 구현 할 수 있음</li>
<li>디폴트 메소드의 이름이 중복되는 경우에는 재정의함<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Buy</span>,<span class="title">Sell</span>&#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> buy() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;customer buy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> order() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;customer order&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sell() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;customer sell&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sayHello()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="인터페이스-상속"><a href="#인터페이스-상속" class="headerlink" title="인터페이스 상속"></a>인터페이스 상속</h2><ul>
<li>인터페이스 간에도 상속이 가능함</li>
<li>구현이 없으므로 extends 뒤에 여러 인터페이스를 상속받을 수 있음</li>
<li>구현 내용이 없으므로 타입 상속(type inheritance)라고 함</li>
</ul>
<h2 id="인터페이스-구현과-클래스-상속-함께-하기"><a href="#인터페이스-구현과-클래스-상속-함께-하기" class="headerlink" title="인터페이스 구현과 클래스 상속 함께 하기"></a>인터페이스 구현과 클래스 상속 함께 하기</h2> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> enQueue(String title) &#123; <span class="comment">//배열에 요소추가</span></span><br><span class="line">        shelf.add(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String deQueue() &#123; <span class="comment">//맨 처음 요소를 배열에서 삭제하고 반환</span></span><br><span class="line">        <span class="keyword">return</span> shelf.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getSize() &#123; <span class="comment">//배열 요소 개수 반환</span></span><br><span class="line">        <span class="keyword">return</span> getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/25/TIL-20200824/" data-id="ckecsfnfg00066ou2f3ws6inj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL_20200814" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/15/TIL_20200814/" class="article-date">
  <time datetime="2020-08-15T09:43:47.618Z" itemprop="datePublished">2020-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/15/TIL_20200814/">Study20200814</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="클래스-다이어그램"><a href="#클래스-다이어그램" class="headerlink" title="클래스 다이어그램"></a>클래스 다이어그램</h1><h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><ul>
<li>클래스의 구성요소 및 클래스 간의 관계를 묘사하는 다이어그램</li>
<li>시간에 따라 변하지 않는 정적인 시스템 구조를 표현</li>
</ul>
<h2 id="클래스-다이어그램의-목적"><a href="#클래스-다이어그램의-목적" class="headerlink" title="클래스 다이어그램의 목적"></a>클래스 다이어그램의 목적</h2><ul>
<li>문제 해결을 위한 도메인 구조를 표현한다.</li>
</ul>
<h2 id="Unified-Modeling-Language-UML"><a href="#Unified-Modeling-Language-UML" class="headerlink" title="Unified Modeling Language(UML)"></a>Unified Modeling Language(UML)</h2><ul>
<li>표준화된 모델링 표기 체계</li>
<li>클래스를 구현하기 전에 설계하는 단계에서 사용<ul>
<li>클래스 이름, 파라미터, 리턴 타입 등</li>
</ul>
</li>
</ul>
<h2 id="IDEA에서-UML-작성하기-Plant-UML"><a href="#IDEA에서-UML-작성하기-Plant-UML" class="headerlink" title="IDEA에서 UML 작성하기(Plant UML)"></a>IDEA에서 UML 작성하기(Plant UML)</h2><ul>
<li>Plant UML 플러그인 설치</li>
<li>Graphviz 설치 (<a target="_blank" rel="noopener" href="https://graphviz.org/download/">https://graphviz.org/download/</a>)</li>
<li>Plant UML의 문법<ul>
<li>클래스, 추상클래스, 인터페이스<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] array;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    setArray(<span class="keyword">int</span> [] array);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>가시성(Visibility)</li>
<li>public : +</li>
<li>protected : #</li>
<li>default : ~</li>
<li>private : -</li>
<li>클래스 간의 관계</li>
<li>Extension <code>&lt;|-</code></li>
<li>Aggregation <code>o--</code></li>
<li>Composition <code>*--</code></li>
<li>타이틀<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title 클래스 다이어그램 제목</span><br></pre></td></tr></table></figure></li>
<li>노트<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">note left of Foo</span><br><span class="line">  노트 <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>내용<span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> 작성</span><br><span class="line">end note</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="예외-처리-Handling-Exceptions"><a href="#예외-처리-Handling-Exceptions" class="headerlink" title="예외 처리(Handling Exceptions)"></a>예외 처리(Handling Exceptions)</h1><p>2020-08-14 3-4차</p>
<h2 id="오류와-예외"><a href="#오류와-예외" class="headerlink" title="오류와 예외"></a>오류와 예외</h2><ul>
<li>프로그램이 동작 중에 비정상 종료가 발생하는 상황</li>
<li>심각도에 따라 오류와 예외로 분류할 수 있음</li>
</ul>
<h3 id="오류-Errors"><a href="#오류-Errors" class="headerlink" title="오류(Errors)"></a>오류(Errors)</h3><ul>
<li>시스템의 메모리가 부족하거나, 무한히 메소드 호출이 발생하는 등 프로그램 복구가 불가능한 상황.</li>
<li>로그램을 진행하기 어려운 상태 계속했다가 해킹을 할 수 있는 여지가 생긴다. 오류가발생하면 프로그램이 종료하는게 정상적인 방법이다.<br>소스코드를 보고 버그픽스를 해서 문제를 해결하는 것이 해결방법이다.</li>
</ul>
<h3 id="예외-Exceptions"><a href="#예외-Exceptions" class="headerlink" title="예외(Exceptions)"></a>예외(Exceptions)</h3><ul>
<li>오류에 비해 심각도가 낮으며, 프로그램 정상적인 흐름만 방해하는 경우 <ul>
<li>파일명으로 파일을 읽으려 하는데, 파일을 찾을 수 없음</li>
<li>네트워크 연결이 유실 끊겼을 때 다시 연결 해야할 때</li>
</ul>
</li>
<li>문제 상황을 해결하는 로직을 별도로 구성하여 해결 가능.</li>
</ul>
<h3 id="예외-처리"><a href="#예외-처리" class="headerlink" title="예외 처리"></a>예외 처리</h3><ul>
<li>예외가 발생했을 때, 이 상황을 감지하고 해결하기 위한 동작하는 코드</li>
<li>try ~ catch 구문과 Exception 클래스와 그 자식 클래스를 활용.</li>
</ul>
<h3 id="Throwable-클래스"><a href="#Throwable-클래스" class="headerlink" title="Throwable 클래스"></a>Throwable 클래스</h3><ul>
<li>Throwable 클래스는 Exception과 Error 클래스에 의해 상속<ul>
<li>Exception<ul>
<li>Checked Exceptions : 예외 처리되지 않으면 컴파일이 되지 않는 예외</li>
<li>Unchecked Exceptions : 예외가 처리되지 않아도 컴파일이 되는 예외</li>
</ul>
</li>
<li>Error : 프로그램이 복구 불가능한 상황</li>
</ul>
</li>
</ul>
<h3 id="Exception-클래스"><a href="#Exception-클래스" class="headerlink" title="Exception 클래스"></a>Exception 클래스</h3><ul>
<li><p>Throwable 클래스의 주요 메소드</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>public String getMessage()</td>
<td>발생한 예외에 대한 메세지를 반환</td>
</tr>
<tr>
<td>public String getLocalizedMessage()</td>
<td>오버라이드하여 추가 메세지 제공(오버라이드하지 않으면 getMessage()와 동일</td>
</tr>
<tr>
<td>public Throwable getCause()</td>
<td>예외의 원인이 되는 Throwable 객체 반환</td>
</tr>
<tr>
<td>public void printStackTrace()</td>
<td>예외가 발생된 메소드가 호출될 때의 Method call stack을 출력</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="예외-처리-기법"><a href="#예외-처리-기법" class="headerlink" title="예외 처리 기법"></a>예외 처리 기법</h2><h3 id="try-catch-구문"><a href="#try-catch-구문" class="headerlink" title="try ~ catch 구문"></a>try ~ catch 구문</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 예외가 발생할 수 있는 코드 영역</span></span><br><span class="line">   <span class="comment">// 예외 발생 시 예외 객체를 던짐 (throw)</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// 던져진 예외를 받음 (catch)</span></span><br><span class="line">                       <span class="comment">// Exception의 자식 클래스로 지정하여 특정 클래스를 받는다.</span></span><br><span class="line">   <span class="comment">// 예외 상황을 처리하는 코드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="다중-예외-처리"><a href="#다중-예외-처리" class="headerlink" title="다중 예외 처리"></a>다중 예외 처리</h3><ul>
<li>여러 개의 catch 구문을 사용하면 다중 예외를 처리할 수 있음.</li>
<li>if ~ else if 구문처럼, 순차적으로 검사하면서 적용 가능한 예외를 처리</li>
<li>다형성이 적용되어, 자식 예외를 처리 가능<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 예외 발생 가능 코드 영역</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (AException e) &#123;</span><br><span class="line">    <span class="comment">// A예외 처리</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BException e) &#123;</span><br><span class="line">    <span class="comment">// B예외 처리</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (CException e) &#123;</span><br><span class="line">    <span class="comment">// C예외 처리</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 나머지 모든 예외 처리</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="try-catch-finally-구문"><a href="#try-catch-finally-구문" class="headerlink" title="try ~ catch ~finally 구문"></a>try ~ catch ~finally 구문</h3><ul>
<li>try 구문 실행 중에 어떤 일이 발생해도 반드시 실행되어야 하는 구문은 finally 블록에 작성</li>
<li>try 구문 내에 return문이 있는 경우에도 finally 블록은 실행됨</li>
<li>try 구문 내에서 접근한 System 자원을 안전하게 복구하기 위해 사용<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream file = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;파일처리실패&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;파일인풋스트림 종료 실패&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="try-catch-resources-구문"><a href="#try-catch-resources-구문" class="headerlink" title="try ~ catch ~ resources 구문"></a>try ~ catch ~ resources 구문</h3><ul>
<li>Java 1.7에서 추가된 기능</li>
<li>AutoClosable 인터페이스를 구현하는 리소스를 자동으로 close 처리<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileInputStream file = <span class="keyword">new</span> FileInputStream(fileName)) &#123;</span><br><span class="line">    file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;파일처리실패&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="예외-처리-위임"><a href="#예외-처리-위임" class="headerlink" title="예외 처리 위임"></a>예외 처리 위임</h2><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><ul>
<li><p>호출한 메소드로 예외 처리를 전달하는 방식</p>
</li>
<li><p>Checked Exception의 경우 throws로 위임 가능하나, 최종적으로 try ~ cath를 만나야 함</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckedException</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> methodA() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class.forname(<span class="string">&quot;A Class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> methodB() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodA();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Unchecked Exception의 경우 throws로 위임하지 않아도 자동으로 전달</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UncheckedException</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> methodA() &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        x = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> methodB() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          methodA();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>메소드를 오버라이드한 경우, 조상 클래스의 메소드보다 조상 예외는 던질 수 없음</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarOne</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125; <span class="comment">// possible</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarTwo</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;&#125; <span class="comment">// possible</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarThree</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;&#125; <span class="comment">// *NOT* possible</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><ul>
<li>예외를 발생시키는 키워드</li>
<li>new 키워드로 새 Exception 객체를 생성하여 예외 내용을 작성<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> exceptMethod() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (Err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Some Error&quot;</span>); <span class="comment">// 예외 발생 및 Message 전달</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="사용자-정의-예외-Custom-Exceptions"><a href="#사용자-정의-예외-Custom-Exceptions" class="headerlink" title="사용자 정의 예외(Custom Exceptions)"></a>사용자 정의 예외(Custom Exceptions)</h2><ul>
<li><p>Exception 또는 RuntimeException 클래스를 상속하여 작성</p>
<ul>
<li><p>Exception을 상속한 경우 Checked Exception이 되어 반드시 예외를 처리해야 한다.</p>
<pre><code class="java">class MyException extends RuntimeException &#123;
  enum ErrorCode &#123;
      ERROR_A, ERROR_B;
  &#125;

  private ErrorCode errorCode;

  public MyException(ErrorCode errorCode, String message) &#123;
      super(message);
      this.errorCode = errorCode;
  &#125;

  @Override
  public String getLocalizedMessage() &#123;
      String message = getMessage();
      ...
      return localizedMessage;
  &#125;
&#125;</code></pre>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/15/TIL_20200814/" data-id="ckecsfnfs000d6ou278bagn4a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TIL_20200813" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/15/TIL_20200813/" class="article-date">
  <time datetime="2020-08-15T09:27:32.583Z" itemprop="datePublished">2020-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/15/TIL_20200813/">Study20200813</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="제네릭-Generic"><a href="#제네릭-Generic" class="headerlink" title="제네릭(Generic)"></a>제네릭(Generic)</h1><h2 id="제네릭이란"><a href="#제네릭이란" class="headerlink" title="제네릭이란"></a>제네릭이란</h2><ul>
<li>대상 객체의 타입을 입력받아서 사용하는 형식</li>
<li>미리 사용할 수 있는 타입을 명시해서 컴파일 타임에 체크 가능.<ul>
<li>일부 타입을 제한할 수 있는 기능이 있음.</li>
<li>입력을 <code>object</code> 로 할 수 있으나, 런타임에 <code>instanceof</code> 로 객체를 체크해야 함.</li>
</ul>
</li>
<li>원하는 객체가 들어왔는지 계속확인해야함.</li>
<li>제네릭을 사용할 경우 이러한 과정 없이 간결하게 코드 작성을 할 수 있다.</li>
<li>프리미티브 타입 불가능.</li>
</ul>
<h2 id="제네릭-클래스"><a href="#제네릭-클래스" class="headerlink" title="제네릭 클래스"></a>제네릭 클래스</h2><h3 id="제네릭-타입"><a href="#제네릭-타입" class="headerlink" title="제네릭 타입"></a>제네릭 타입</h3><ul>
<li><p>클래스와 인터페이스에 제네릭이 적용된 타입</p>
</li>
<li><p>클래스를 선언할 때에 타입이 알려지지 않으며, 타입 파라미터를 사용.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//일반 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제네릭 클래스</span></span><br><span class="line"><span class="comment">// 클래스를 선언할 때에는 설정되지 않은 타입이 있으며, 이것을 타입 파라미터로 표현한다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericFoo</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">// T: 타입 파라미터</span></span><br><span class="line">    String name;</span><br><span class="line">    T memberVar; <span class="comment">// T를 자료형으로 사용.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericFoo</span><span class="params">(String name, T memberVar)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//생성자 생성 어떤타입의 자료형이 들어오는지 모르는데 구현 가능.</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.memberVar = memberVar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제네릭 인터페이스</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="comment">//인터페이스도 제네릭이 가능</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">k</span>,<span class="title">w</span>&gt;</span>&#123; <span class="comment">// 여러개의 타입 파라미터로 쓸 수 있다.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>제네릭 타입은 실제로 사용될 때 타입 파라미터에 자료형을 입력받는다.</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GenericFoo&lt;String&gt; foo = <span class="keyword">new</span> GenericFoo&lt;String&gt;(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;var&quot;</span>); <span class="comment">//**생성할 때 자료형을 정해주게 되어 있음.**</span></span><br><span class="line">         <span class="comment">// &lt;&gt;안에 스트링으로 넣어줬기 때문에 T도 스트링으로 된다.</span></span><br><span class="line"> </span><br><span class="line">GenericFoo&lt;String&gt; foo1 = <span class="keyword">new</span> GenericFoo&lt;&gt;(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;var&quot;</span>);<span class="comment">//뒤에 &lt;&gt;생략가능</span></span><br></pre></td></tr></table></figure>

<h3 id="주의-해야할-문법들"><a href="#주의-해야할-문법들" class="headerlink" title="주의 해야할 문법들"></a>주의 해야할 문법들</h3><ul>
<li>static은 객체가 생성전에 자료형이 결정되어야 하는데, </li>
<li>class  GenericBar<T>의 타입 파라미터와 static 변수, 메소드는 같은 타입 파라미터를 갖고 있기 때문에 안됨!</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">GenericBar</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 제네릭은 객체를 생성할때 자료형을 입력받기때문에. 스태틱은 객체생성전에 자료형이 결정되어야 하기때문에 / 클래스에 속하기 때문에 t를사용하면 자료형 알 수 없음.</span></span><br><span class="line">  <span class="comment">// static은 클래스에 속하기 때문에 애초에 t가 쓸수 없음 문법적 문제</span></span><br><span class="line">  <span class="keyword">static</span> T classVar; <span class="comment">// 안된다.. 클래스의 스테틱변수는 객체와 관계없이 클래스에 속해있기 때문에 스태틱 변수가 생겨야하는 생서시점에는 t 자료형이 없기 때문에</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;&#125; <span class="comment">//이것도 마찬가지로 불가능.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>문법적으로 문제가 없을 것 같으나, 안정성 문제로 금지. 암기해야 하는 됨!</li>
<li><code>instanceof</code>의 피연산자로 사용할 수 없다.</li>
<li><code>new</code> 키워드를 사용하여 객체 생성을 할 수 없다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    T memberVar = <span class="keyword">new</span> T(); t는 <span class="keyword">new</span> 키워드를 쓸 수 없음. -  안정성 문제 때문에 불가능하다. 티라는 자료형이 결정되지 않기때문에 생성자가 어떻게 정의될지 모르기 때문에 불가능 자바에서 막혀있음.</span><br><span class="line">    <span class="comment">// 타입파라미터의 객체를 생성하는 것은 불가능 하다.</span></span><br><span class="line">      &#123;</span><br><span class="line">          Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">          <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> T)&#123; <span class="comment">// 불가능 어떤 객체가있을대 t에속하는지 확인하기 불가능 안정성 문제 때문에 그냥 막혀있음.</span></span><br><span class="line">    </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="제네릭-타입의-상속"><a href="#제네릭-타입의-상속" class="headerlink" title="제네릭 타입의 상속"></a>제네릭 타입의 상속</h3><ul>
<li>부모 클래스 또는 인터페이스에 선언한 타입 파라미터는 반드시 자식에서도 선언해야 된다.</li>
<li>자식 클래스에서 추가적인 타입 파라미터 선언할 수 있다.</li>
<li>부모 클래스와 인터페이스의 타입 파라미터가 같을 경우 상속받는 클래스에서 다르게 넣어주면 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFoo</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IGFoo</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">GIGFoo</span>&lt;<span class="title">K</span>,<span class="title">T</span>,<span class="title">D</span>&gt; <span class="keyword">extends</span> <span class="title">GFoo</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IGFoo</span>&lt;<span class="title">D</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="파라미터-타입의-제한"><a href="#파라미터-타입의-제한" class="headerlink" title="파라미터 타입의 제한"></a>파라미터 타입의 제한</h3><ul>
<li>extends를 이용하여 파라미터 타입을 제한할 수 있다.<ul>
<li>인터페이스의 경우에도 extends 키워드를 사용한다.</li>
<li>클래스와 인터페이스를 동시에 제약하려면 &amp;로 연결한다.</li>
</ul>
</li>
<li>제한한 자료형의 자식 클래스는 모두 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//타입 제한을 하지 않으면 extends object와 동일하다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNoTypeLimit</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//extends를 이용해서 부모클래스를 제한 할 수 있음// 추상클래스를 상속하면서 인터페이스를 추가로 구현할 수 있음  추상클래스+인터페이스를 구현해야한다</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTypeLimitation</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Cloneable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="제네릭-메소드"><a href="#제네릭-메소드" class="headerlink" title="제네릭 메소드"></a>제네릭 메소드</h2><h3 id="메소드에-선언된-제네릭"><a href="#메소드에-선언된-제네릭" class="headerlink" title="메소드에 선언된 제네릭"></a>메소드에 선언된 제네릭</h3><ul>
<li>메소드의 리턴 타입 앞에 타이 파라미터 변수를 선언하여 사용</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">method</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>메소드에 선언된 제네릭은 정적 메서드에도 사용 가능.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span> </span>&#123; <span class="comment">// Error</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;P&gt; <span class="function">P <span class="title">method</span> <span class="params">(P p)</span> </span>&#123; <span class="comment">// Possible</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>와일드 카드<ul>
<li>와일드카드 ?는 메소드의  입력 타입에 제네릭이 쓰일 경우, 제네릭의 타입 변수를 제한할 수 있다.</li>
<li>&lt;?&gt; =&gt; &lt;? extends Object&gt;와 동일</li>
<li>&lt;? extends T&gt; =&gt; 와일드카드의 상한을 제한</li>
<li>&lt;? super T&gt; =&gt; 와일드카드의 하한을 제한</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 와일드카드</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WildFoo</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WildBar</span> <span class="keyword">extends</span> <span class="title">WildFoo</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WildGeneric</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WildCard</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//&lt;&gt;명시할 수도 있고 명시하지 않을 수 있고 ?를 사용할 수 있음.</span></span><br><span class="line">  <span class="comment">//extends 조상이하의 것들은 다사용할 수 있음.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(WildGeneric&lt;?&gt; x)</span></span>&#123;&#125; <span class="comment">//입력파라미터로 제네릭을 사용한다면 제네릭의 타입변수는 ?를사용해서 미리 정하지 않을 수 있다.여기선 아무거나 들어올 수 있다.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1_Eq</span><span class="params">(WildGeneric&lt;? extends Object&gt; x)</span></span>&#123;&#125; <span class="comment">//object가 상한이고 -&gt; 모든 클래스를 사용할 수 있음.(모든 클래스는 object를 상위클래스로 갖고있기 때문에)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(WildGeneric&lt;? extends WildFoo&gt; x)</span></span>&#123;&#125; <span class="comment">// 가장 조상이 어디까지인지 제한을 하는 것 / 여기선 wildfoo, wildbar 사용가능</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(WildGeneric&lt;? <span class="keyword">super</span> WildBar&gt; x)</span></span>&#123;&#125; <span class="comment">//object, wildfoo, wildbar 사용가능. 여기서 whildbar 이상의 것들 하한선이 whildbar</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generics</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericFoo&lt;String&gt; foo = <span class="keyword">new</span> GenericFoo&lt;String&gt;(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;var&quot;</span>); <span class="comment">//**생성할 때 자료형을 정해주게 되어 있음.**</span></span><br><span class="line">        <span class="comment">// &lt;&gt;안에 스트링으로 넣어줬기 때문에 T도 스트링으로 된다.</span></span><br><span class="line"></span><br><span class="line">        GenericFoo&lt;String&gt; foo1 = <span class="keyword">new</span> GenericFoo&lt;&gt;(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;var&quot;</span>);  <span class="comment">//뒤에 &lt;&gt;생략가능</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        GenericFoo&lt;int&gt; 프리미티브 타입 불가능.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(foo.name);</span><br><span class="line">        System.out.println(foo.memberVar);</span><br><span class="line"></span><br><span class="line">        GenericFoo&lt;Integer&gt; foo2 = <span class="keyword">new</span> GenericFoo&lt;&gt;(<span class="string">&quot;name1&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(foo2.name);</span><br><span class="line">        System.out.println(foo2.memberVar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 동적 바인딩이란 메소드가 생길때 자료형이랑 정의되어있어서 기계가동작하게 만들어지는게 정상적인데 자료형이 정해져있지않아서 들어오는거에따라 동작이 달라짐 실제로 런타임이 되지않으면</span></span><br><span class="line">        <span class="comment">//컴파일타임이 알 수 없음.</span></span><br><span class="line">        <span class="comment">// 동적 바인딩 -&gt; 컴파일타임에는 동작이 완전히 정의가 되지 않음.</span></span><br><span class="line">        <span class="comment">// 런타임에 결정이 된다.</span></span><br><span class="line">        GenericMethod.staticMethod(<span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        GenericMethod.staticMethod(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        GenericMethod.staticMethod(<span class="number">12342</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Wrapper-클래스-Wrapper-Class"><a href="#Wrapper-클래스-Wrapper-Class" class="headerlink" title="Wrapper 클래스(Wrapper Class)"></a>Wrapper 클래스(Wrapper Class)</h1><h2 id="Wrapper-Class란"><a href="#Wrapper-Class란" class="headerlink" title="Wrapper Class란"></a>Wrapper Class란</h2><ul>
<li>기본형 타입을 객체로 쓰기 위해 있은 클래스</li>
<li>기본형 타입이 허용되지 않는 문법에 기본형 타입을 쓰기 위해서 제공 하는 클래스</li>
</ul>
<h2 id="Wrapper-Class의-종류"><a href="#Wrapper-Class의-종류" class="headerlink" title="Wrapper Class의 종류"></a>Wrapper Class의 종류</h2><table>
<thead>
<tr>
<th align="center">기본형</th>
<th align="center">WrapperClass</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">flaot</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<h2 id="Wrapper-객체-생성"><a href="#Wrapper-객체-생성" class="headerlink" title="Wrapper 객체 생성"></a>Wrapper 객체 생성</h2><ul>
<li>생성자를 이용한 객체 생성</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">Character character = <span class="keyword">new</span> Character(<span class="string">&#x27;v&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>valueOf를 이용한 객체 생성</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 = Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">Character character1 = Character.valueOf(<span class="string">&#x27;v&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Autoboxing-amp-Unboxing"><a href="#Autoboxing-amp-Unboxing" class="headerlink" title="Autoboxing &amp; Unboxing"></a>Autoboxing &amp; Unboxing</h2><ul>
<li>객체로 사용될 때 오토박싱, 다시 Primitive Type이 되는건 언박싱.</li>
<li>Autoboxing<ul>
<li>Java1.5부터 추가된 기능으로, 객체로 다루어야 할 때 자동으로 Wrapper 클래스로 변경하는 기능</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T bypass (T x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Integer integer2 = <span class="number">4</span>;</span><br><span class="line">System.out.println(add(<span class="number">4</span>,<span class="number">2</span>));</span><br><span class="line">bypass(<span class="number">5</span>); <span class="comment">// 원래는 프리미티브 타입을t에 넣을 수 없는데 autoboxing이 이뤄져서 가능.</span></span><br><span class="line"><span class="comment">// T: wrapper class인 integer로 결정됨</span></span><br><span class="line"><span class="comment">// 5 -&gt; new Integer(5) autoboxing 1.5버전 이후로 가능해짐.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Unboxing<ul>
<li>Wrapper 객체를 기본형으로 자동으로 변경하는 기능</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="keyword">new</span> Integer(<span class="number">10</span>); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">Integer wrapped = i;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span> + wrapped;</span><br></pre></td></tr></table></figure>

<h2 id="Wrapper-타입의-값-비교"><a href="#Wrapper-타입의-값-비교" class="headerlink" title="Wrapper 타입의 값 비교"></a>Wrapper 타입의 값 비교</h2><ul>
<li>Wrapper 타입은 객체이므로, ==를 이용하여 값을 비교할 수 없다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer intOne = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer intTwo = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(intOne == intTwo); <span class="comment">// false</span></span><br><span class="line">System.out.println(intOne.equals(intTwo)) <span class="comment">// true</span></span><br><span class="line">System.out.println(intOne == <span class="number">100</span>) <span class="comment">// true (Unboxing)</span></span><br></pre></td></tr></table></figure>

<h2 id="문자열의-기본-자료형-반환"><a href="#문자열의-기본-자료형-반환" class="headerlink" title="문자열의 기본 자료형 반환"></a>문자열의 기본 자료형 반환</h2><ul>
<li>Parsing 정적 메소드를 이용한 반환</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> y = Long.parseLong(<span class="string">&quot;512345124&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Wrapper 객체로의 반환</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer intObj = Integer.valueOf(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">Integer intObjTwo = <span class="keyword">new</span> Integer(<span class="string">&quot;1234&quot;</span>);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/08/15/TIL_20200813/" data-id="ckecsfnfq000c6ou2cau815t8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/27/TIL-20200827/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/08/26/TIL-20200826/">Study20200826</a>
          </li>
        
          <li>
            <a href="/2020/08/25/TIL-20200825/">Study20200825</a>
          </li>
        
          <li>
            <a href="/2020/08/25/TIL-20200823/">Study20200823</a>
          </li>
        
          <li>
            <a href="/2020/08/25/TIL-20200820/">Study20200820</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>