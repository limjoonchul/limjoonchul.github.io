<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://limjoonchul.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java/JavaAdvanced/Java-MultiThread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/31/Java/JavaAdvanced/Java-MultiThread/" class="article-date">
  <time datetime="2020-10-31T10:17:03.706Z" itemprop="datePublished">2020-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Multi-Thread-Programming"><a href="#Multi-Thread-Programming" class="headerlink" title="Multi-Thread Programming"></a>Multi-Thread Programming</h1><h2 id="Process-and-Thread"><a href="#Process-and-Thread" class="headerlink" title="Process and Thread"></a>Process and Thread</h2><ul>
<li>Thread : 최소의 프로세스 동작 단위  -&gt; 하나의 프로세스는 여러개의 스레드를 가질 수 있다. 하나의 스레드가 하나의 프로세스에 속한다.</li>
<li>Process: OS로부터 메모리를 할당받아 동작하는 프로그램의 동작 단위, 프로그램이 실제로 메모리에 상주하면서 동작할 때 프로세스가 된다.<br>프로그램이 클래스이고 프로세스가 객체로 생각할 수 있다.<ul>
<li>프로그램을 실행할 때, 멀티 프로세스로 동작하는 프로그램도 있다. 프로세스끼리 통신하면서 동작할 수도 있다. -&gt; 리눅스에서 사용한다.</li>
<li>프로세스끼리 메모리를 공유하는 영역은 없다. 스레드는 같은 프로세스내에있기 때문에 같은 메모리영역을 공유한다.</li>
</ul>
</li>
</ul>
<h2 id="멀티스레드-프로그래밍의-장단점"><a href="#멀티스레드-프로그래밍의-장단점" class="headerlink" title="멀티스레드 프로그래밍의 장단점"></a>멀티스레드 프로그래밍의 장단점</h2><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><ul>
<li>여러 동작을 병렬적으로 처리하여 CPU 사용률 향상 (CPU Utilization)<ul>
<li>인코딩, 렌더링, 배치작업(모아둔걸 한번에 처리하면 되는 것들 DB정리, 로그 처리) 등의 작업들 / 서비스가 커질 수록 최적화가 중요하다.</li>
</ul>
</li>
<li>시간이 걸리는 동작을 분리하여 프로그램의 응답성 향상<ul>
<li>GUI, 게임, 앱, 웹 API(다 프레임워크를 사용하기 때문에 내부적으로 관리해줌, 직접 사용할 일은 없음)<h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h3></li>
</ul>
</li>
<li>디버깅이 어렵다! 쓰레드가 동시에 동작하기 때문에, 디버거로 확인하기 어려움.<ul>
<li>디버거를 쓰거나, 디거빙을 하기 위한 코드를 추가하면 동작이 변한다. (나노 세컨드로 작업을 하기때문에 동작의 순서가 바뀌면 크게 바뀔수 있다.)</li>
</ul>
</li>
<li>구현이 어렵다 쓰레드간의 동기화를 하기 위한 구현이 어렵다. 쉽게 동기화하면 느려진다.<ul>
<li>Context Switching 오버헤드가 있기 때문에 동기화를 잘 못하면 오히려 더 느려진다. (쓰레드가 동작할 수 있는 것이 정해져 있다.)</li>
<li>OS에서 하드웨어의 CPU에 동작이 제한이 걸려있어서 동작하는 CPU를 바꿔가면서 동작하도록 하기 때문에 Context Switching을 하면 오버헤드가 발생한다.<h2 id="스레드-구현"><a href="#스레드-구현" class="headerlink" title="스레드 구현"></a>스레드 구현</h2></li>
</ul>
</li>
<li>스레드 생성<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 방법 1. 익명 내부 클래스를 이용한 생성</span></span><br><span class="line">Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 방법 2. 람다식을 이용한 생성</span></span><br><span class="line">Thread threadTwo = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello Again, Thread!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 방법 3. 스레드를 클래스로 만들어서 생성</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> &#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Again Again, Thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread threadThree = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 방법 4. 구현 후 즉시 실행</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;IDEA&quot;</span>);</span><br><span class="line">&#125;).start(); <span class="comment">// 객체에 대한 참조를 가지고 있지 않기 때문에 이렇게 하면 JOIN등 활용이 어려움. 씽크가 상관이 없다면 이렇게도 사용가능.</span></span><br></pre></td></tr></table></figure></li>
<li>스레드 실행<ul>
<li>쓰레드 객체는 1회용이며, start()로 실행한다.</li>
<li>신입 개발자들이 무한 루프에서 스레드를 스타트하는 실수를 많이 한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread threadOne = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread threadTwo = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">threadOne.run(); <span class="comment">// 이렇게도 동작 가능. 이건 멀티스레드랑 상관없이 클래스의 run()를 그냥 콜한 것이라 상관없음.</span></span><br><span class="line">threadOne.start(); <span class="comment">// 가능.</span></span><br><span class="line">threadOne.run(); <span class="comment">// 그냥 메소드콜이니깐 다시 동작해도 잘 된다.</span></span><br><span class="line">threadOne.start(); <span class="comment">// 스레드 객체는 1회용이므로, start()가 재실행될 수 없다.</span></span><br><span class="line"><span class="comment">// 신입개발자들이 무한루프에서 스레드를 스타트하는 실수를 많이 한다.</span></span><br><span class="line"></span><br><span class="line">threadTwo.start();</span><br><span class="line">System.out.println(<span class="string">&quot;Done!&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="스레드의-상태-및-제어"><a href="#스레드의-상태-및-제어" class="headerlink" title="스레드의 상태 및 제어"></a>스레드의 상태 및 제어</h2><ul>
<li><p>스레드의 상태 </p>
<ul>
<li><p>getState() 메소드로 스레드의 상태를 확인할 수 있다.</p>
<table>
<thead>
<tr>
<th>열거형 상수</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>start() 메소드가 아직 호출되지 않음</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>JVM에 의해 실행 가능한 상태</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>객체가 블락된 상태</td>
</tr>
<tr>
<td>WAITING</td>
<td>sleep(), wait(), join() 등에 의해 무한히 대기 중인 상태</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>sleep(), wait(), join() 등에 의해 정해진 시간 동안 대기 중인 상태</td>
</tr>
<tr>
<td>TERMINATE</td>
<td>run() 메소드가 종료된 상태</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>스레드의 우선순위 제어</p>
<ul>
<li>priority 기능이 있으나, 보장되지 않는다.</li>
<li>이유는 starying(서빙 받지 못하는) 하는 Thread가 없게 하기 위해서 OS가 조절하기 때문.</li>
<li>우선순위가 높은 것에만 집중하면 우선순위가 높은거에만 동작만하고 다른건 동작 못하게 할 수 있기 때문에 동작을 하지 못하는 스레드를 동작시키게 해주게 OS에서 제한을 둔다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Thread p1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread p2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 우선순위 - 값이 높을 수록 우선순위가 높다.   </span></span><br><span class="line">        System.out.println(p1.getPriority()); <span class="comment">// default 5</span></span><br><span class="line">        p1.setPriority(Thread.MAX_PRIORITY); <span class="comment">// MAX = 10</span></span><br><span class="line">        p2.setPriority(Thread.MIN_PRIORITY); <span class="comment">// MIN =1</span></span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        <span class="comment">// 한스레드가 일정시간을 점유하고 다른 스레드가 점유하는 식으로 진행된다, 왔다 갔다한다. 예측하기 어려움.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>void setPriority(int newPriority)</td>
<td>새로운 우선순위로 설정한다.</td>
</tr>
<tr>
<td>int getPriority()</td>
<td>우선순위를 반환한다.</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><code>sleep()</code>을 이용한 제어<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          Thread p1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 일반스레드에서 sleep을 사용할 때는 try/catch를 해줘야한다. </span></span><br><span class="line">                    <span class="comment">// throws를 해줄 수 있지만 나중에 Interrupt 때문에 try/catch를 해주는게 좋다.</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;); <span class="comment">// run이라는 단일 메소드를 동작시키는 객체</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">          Thread p2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;Thread by lambda&quot;</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">  </span><br><span class="line">          p2.start();</span><br><span class="line">  </span><br><span class="line">          Thread.sleep(<span class="number">100</span>); <span class="comment">// 100미리 세컨드 동안 쉬고 동작을 한다. sleep을 이용해서 시간차를 줄 수있는 방법!</span></span><br><span class="line">          <span class="comment">// 사용률을 감소시킴, 그래서 느려진다. 메인에서 하면 메인 쓰레드를 sleep시킨다.</span></span><br><span class="line">  </span><br><span class="line">          System.out.println(<span class="string">&quot;Main thread ended&quot;</span>);</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ``` </span><br><span class="line"></span><br><span class="line">* `join()`을 이용한 스레드 조인</span><br><span class="line">   * 스레드 동작을 동기화하기 위해서 사용한다.</span><br><span class="line">   * 한 스레드의 동작이 끝난 다음에 다른 스레드를 동작시키는 메소드이다.</span><br><span class="line">   ```java</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">// 방법 1. 익명 내부 클래스</span></span><br><span class="line">            Thread p1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                   &#125; <span class="comment">// 일반스레드에 쓸때는 try/catch를 해줘야한다 throws를 해줄 수 있지만 트라이캐치를해줘야한다.</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); <span class="comment">// run이라는 단일 메소드를 동작시키는 객체</span></span><br><span class="line">            </span><br><span class="line">            Thread p2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread by lambda&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            p2.start();</span><br><span class="line">            p2.join(); <span class="comment">// 한스레드가 동작을 끝내면 p2동작이 끝나면 그때 조인을해서 p1이 실행이 된다. sleep 없이 join으로 맞출 수 있다. 무언갈 동작하다 막혀있는게 blocking 동작</span></span><br><span class="line">            p2.join(<span class="number">100</span>);  <span class="comment">// p2가 무한루프가 돌고 있을 대 안에 100을주면 100밀리세컨트 뒤에 다음 스레드가 동작될 수 있게 한다. 하지만 p2는 계속 돌고있음.</span></span><br><span class="line">            <span class="comment">// 100ms 기다렸다가 동작을 할수 있게 설정한다.</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// p2끝날 때까지 기다렸다가 시작이 된다. 그전까지 대기상태로 들어가 있지 않은 상태다.</span></span><br><span class="line">            p1.start(); <span class="comment">// start를 해줘야 동작한다. 실제로 OS에 스레드 동작을 요청한다. main이 아닌 새로운 스레드를 동작한다.</span></span><br><span class="line">    </span><br><span class="line">            p1.join();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 100미리 세컨드동안 쉬고 동작을 한다. sleep을 이용해서 시간차를 줄 수있는 방법!</span></span><br><span class="line">            <span class="comment">// 사용률을 감소시킴, 그래서 느려진다. 메인에서 하면 메인쓰레드를 sleep시킨다.</span></span><br><span class="line">    </span><br><span class="line">            System.out.println(<span class="string">&quot;Main thread ended&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>interrupt()</code> 을 이용항 대기 중지<ul>
<li>방해를 의미하긴 하는데 컴퓨터 사이언스적인 용어로 기존 동작을 방해하고 반응을 강제하는 메소드.</li>
<li>주로 임베디드에서 많이 사용. 별로 쓸일은 없다. 스레드 동작을 이해하는데 필요하다 잘 못 스립된 동작을 깨워준다.</li>
<li>의도적으로 쓸 일은 많지 않다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;           </span><br><span class="line">        <span class="comment">// try/catch를 쓰는 이유는 만약 10초동안 쉬고 있는데 다른 동작이 끝나고 쉬고있는 동작을 interrupte로 깨워줄 수 있다.</span></span><br><span class="line">        Thread p1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;p1!!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread p2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;p2!!&quot;</span>);</span><br><span class="line">            p1.interrupt(); </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>yield()</code>를 이용한 상태 제어<ul>
<li>다른 스레드로 양보하고 바로 실행 대기 sleep(0)과 유사</li>
<li>러닝상태에서 빠져나오고 바로 대기 상태로 들어가기 때문에 다른 스레드가 동작을 하지 않게 되면 바로 동작할 수도 있다.</li>
<li>자주 변하게 되면 오버헤드가 증가하는 것이다.</li>
</ul>
</li>
<li><code>sleep()</code>을 이용하면 오버헤드가 엄청 크다. Running 상태에서 Timed_Waiting 상태로 이동 그 다음에 실행 가능 상태로 넘어간다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread p1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;~&quot;</span>);</span><br><span class="line">                Thread.yield(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    Thread.sleep(1); // 오버헤드가 엄청 큼! Running 상태에서 Timed_Waiting 상태로 이동 그 다음에 실행가능상태로 넘어감</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread p2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    Thread.sleep(1);</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(p1.getPriority()); </span><br><span class="line">        p1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        p2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>스레드의 종료<ul>
<li><code>run()</code> 메소드의 종료</li>
<li><code>stop()</code> 메소드 호출 (deprecated)</li>
</ul>
</li>
</ul>
<h2 id="데몬-스레드-daemon-thread"><a href="#데몬-스레드-daemon-thread" class="headerlink" title="데몬 스레드(daemon thread)"></a>데몬 스레드(daemon thread)</h2><ul>
<li><p>다른 스레드가 모두 종료될 경우, 스스로 종료되는 스레드 &lt;- 정의</p>
</li>
<li><p>무한 루프로 대기하면서 동작하는 구현이 많음 &lt;- 활용</p>
<ul>
<li>일정 시간마다 동작, interrupt등에 의해서 동작, 외부의 요청에 의해서 동작하는 것</li>
</ul>
</li>
<li><p>setDaemon(true)로하면 데몬스레드가 된다.</p>
</li>
<li><p>메인 스레드에서 종료되면 스스로 종료되는 데몬 설정</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoSaver</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoSaver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// save something...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Auto save done!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AutoSaver().start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;working&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 메인에서 1초간격으로 동작을 해서 15번이 실행이되면 autosaver는 같이 종료됨</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="데이터-공유와-동기화"><a href="#데이터-공유와-동기화" class="headerlink" title="데이터 공유와 동기화"></a>데이터 공유와 동기화</h2></li>
<li><p>스레드간 데이터 공유 시 신뢰성에 문제가 발생할 수 있다.</p>
<h3 id="Intrinsic-lock-고유-락-과-synchronized-키워드"><a href="#Intrinsic-lock-고유-락-과-synchronized-키워드" class="headerlink" title="Intrinsic lock (고유 락)과 synchronized 키워드"></a>Intrinsic lock (고유 락)과 synchronized 키워드</h3></li>
<li><p>자바의 모든 객체(Object)는 고유 락을 가지고 있다.</p>
<ul>
<li>고유 락은 객체의 소유권을 한정하는 내부적인 구현 -&gt; 소유권은 독점적이다. 한번에 하나밖에 가질 수 없다.</li>
</ul>
</li>
<li><p>synchronized를 이용하면 객체의 고유 락의 소유권을 가져올 수 있다.</p>
<ul>
<li><p>소유권이 이미 점유된 경우에는 Blocking으로 동작 소유권을 가진 객체가 반환하면, 대기하던 스레드가 받아서 동작한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 멀티스레드 동작에 취약한 구현</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increaseCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++count; <span class="comment">// 읽고, 수정하고, 쓰는 작업</span></span><br><span class="line">        <span class="comment">// 동작들이 중복이 될 수 있다, 도중에 다른 스레드가 작업을 하게되면</span></span><br><span class="line">        <span class="comment">// 경쟁적으로 동작하다보면, 읽고 수정하고 쓰기 전에 다른 쓰레드가 읽는 경우가 발생</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object 객체의 Intrinsic Lock을 이용한 구현 - 굳이 이렇게 할 필요 없음.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increaseCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123; <span class="comment">// lock이라는 객체를 소유해야 내부 블록을 동작시킬 수 있다. lock은 한번에 한 스레드만 소유할 수 있다.</span></span><br><span class="line">            <span class="keyword">return</span> ++count; <span class="comment">// 읽고, 수정하고, 쓰는 작업</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. this 객체의 Intrinsic Lock을 이용한 구현(모든 객체는 고유 락을 가지고 있기 때문에) 가장 좋은 구현 방법.</span></span><br><span class="line"><span class="comment">// Intrinsic Lock의 범위가 넓어질 수록 성능이 점점 떨어진다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increaseCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ++count; <span class="comment">// 읽고, 수정하고, 쓰는 작업</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 메소드에 synchronized 키워드를 사용</span></span><br><span class="line"><span class="comment">// synchronized 키워드가 사용된 메소드를 호출하기 위해서는</span></span><br><span class="line"><span class="comment">// 해당 객체를 소유해야만 호출이 가능, 소유하지 못하면 Blocking 동작을 하고 있으면, nonBlocking 멈춰 있으면 Blocking</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increaseCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++count; <span class="comment">// 읽고, 수정하고, 쓰는 작업</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Counter c = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 고유락을 사용하는 것은 한번에 하나만 동작하게 하기위해서 제한을 해두는 것이다</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">//                synchronized(c)&#123; // 이렇게 싱크를 하면, 병렬 동작이 전혀 이루어지지 않는다. 하나의 스레드가 100번을 수행하고 다음 스레드가 100번 수행하는 형태로 동작한다.</span></span><br><span class="line">                    <span class="comment">// 가장 안전하지만 가장 효율이 떨어지는 코드가 된다.</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// c라는 shared object 공유객체 가 있을 때</span></span><br><span class="line">                        <span class="comment">// 멀티스레드로부터 안전한 영역을 생성하는 방법이다.</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (c) &#123; <span class="comment">// 5. c의 고유 락을 획득해야만 동작. &#123;&#125;영역안에서는 다른 스레드가 접근하지 못함</span></span><br><span class="line">                        c.increaseCount();</span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(c.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>두 개의 스레드를 번갈아 동작할 수 있게 하는 방법</p>
<ul>
<li>완벽히 번갈아 가면서 동작하게 하는 건 아니지만 최대한 유사하게 동작하게 하는방법이다.</li>
<li><code>notify()</code> - 대기중인 다른 스레드를 하나 동작상태로 만든다. wait()중인 다른스레드가 들어와도 된다. 하나한테만 알려준다.</li>
<li><code>notifyAll()</code> - 나머지 전체한테 알려준다.</li>
<li><code>wait()</code> - synchronized안에서만 호출이 가능하다. Lcok을 반환하고, 대기상태로 들어간다. </li>
<li><code>notify()</code> 와 <code>wait()</code>의 순서가 중요하다 순서를 바꾸게 되면 한 번 실행하고 대기 상태로 들어가기 때문에 <code>notify()</code>를 기다리는 데드락 상태가 된다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkObject</span></span>&#123;</span><br><span class="line">    <span class="comment">// A가 먼저 실행된다고 할 때 wait()이되면 lock을 반환하고  B가 실행되고 notify를 날리고 동작한다음에 wait()이되고 lock을 반환하고 A가 실행되는 왔다갔다 이렇게 동작함!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA() called&quot;</span>);</span><br><span class="line">        <span class="comment">// 처음 스레드가 실행되는건 notify가 효과가 없다.</span></span><br><span class="line">        notify(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    위에 것과 같음</span></span><br><span class="line"><span class="comment">//    public  void methodASAME()&#123;</span></span><br><span class="line"><span class="comment">//        synchronized (this)&#123;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;methodA() called&quot;);</span></span><br><span class="line"><span class="comment">//            notify(); </span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                wait(); </span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;&#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB() called&quot;</span>);</span><br><span class="line">        notify();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkObject workObject;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(WorkObject workObject, <span class="keyword">boolean</span> isA)</span></span>&#123; <span class="comment">// Dependency Injection</span></span><br><span class="line">        <span class="keyword">this</span>.workObject = workObject;</span><br><span class="line">        <span class="keyword">this</span>.isA = isA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isA)&#123;</span><br><span class="line">                workObject.methodA();</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                workObject.methodB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WorkObject sharedObj = <span class="keyword">new</span> WorkObject();</span><br><span class="line">        Thread p1 = <span class="keyword">new</span> MyThread(sharedObj, <span class="keyword">true</span>);</span><br><span class="line">        Thread p2 = <span class="keyword">new</span> MyThread(sharedObj, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="세마포-Semaphore"><a href="#세마포-Semaphore" class="headerlink" title="세마포(Semaphore)"></a>세마포(Semaphore)</h2><ul>
<li>사전적 의미 횟대(깃발)</li>
<li>n개의 깃발을 놓고, 여러 스레드가 경쟁하도록 하는 sync 기법</li>
<li>n = 1 이면, BinarySemphore라고 하며, Lock(락은 하나만 존재하니깐)과 유사하게 동작</li>
<li>자원관리를 할 수 있다. 충분히 무언가 쌓였을 때 동작할 수 있게 구현할 수 있다.</li>
<li><code>acquire()</code> - 세마포의 허용권을 가져오는 메소드</li>
<li><code>release()</code> - 세마포의 허용권을 증가시키는 메소드, ()안에 숫자를 써주면 그 숫자만큼 증가한다.</li>
<li><code>availablePermits()</code> - 허용권이 몇개 있는지 체크할 때 사용하는 메소드</li>
<li><code>tryAcquire()</code> - 시도를 해서 성공하면 true, 실패하면 false를 반환하고 Blocking하지 않고 바로 다음코드를 진행한다.<ul>
<li>일정시간 동안 Blocking을 할 수 있게 ()안에 타임 아웃을 지정할 수 있다. (ex-<code>sem.tryAcquire(2000, TimeUnit.MILLISECONDS)</code>)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore sem = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">// 세마포 개수를 설정한다.</span></span><br><span class="line"></span><br><span class="line">        sem.release(); </span><br><span class="line">        </span><br><span class="line">        System.out.println(sem.availablePermits());</span><br><span class="line"><span class="comment">//        sem.release(11);</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">////            sem.acquire(12); release가 11개인데 12개를 가져오려고 하면 blocking이 걸림</span></span><br><span class="line"><span class="comment">//            sem.acquire(); // 세마포를 획득하는 과정</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        sem.acquireUninterruptibly(); // acquire와 비슷한데  인터럽트에 반응하지 않음</span></span><br><span class="line"></span><br><span class="line">        System.out.println(sem.tryAcquire()); <span class="comment">// 시도를해서 성공하면 true를 반환함 blocking하지 않는다. 실패하면 false를 반환하고 넘어간다.</span></span><br><span class="line">        <span class="comment">// blocking하지 않는다는 건 기다리지 않고 다음걸 진행한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(sem.tryAcquire(2000, TimeUnit.MILLISECONDS));</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 일정 시간은 블락킹할 수 있다. 안에 시간을 넣을 수 있다.(타임아웃)</span></span><br><span class="line"></span><br><span class="line">        System.out.println(sem.availablePermits()); <span class="comment">// 가능한 허용권을 체크할 수 있다</span></span><br><span class="line"></span><br><span class="line">        sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="세마포를-이용한-식사하는-철학자들-문제"><a href="#세마포를-이용한-식사하는-철학자들-문제" class="headerlink" title="세마포를 이용한 식사하는 철학자들 문제"></a>세마포를 이용한 식사하는 철학자들 문제</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.s14.p08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Fork left;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Fork right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(<span class="keyword">int</span> id,Fork left, Fork right)</span> </span>&#123;  <span class="comment">// DI</span></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                left.acquire();</span><br><span class="line">                System.out.println(id + <span class="string">&quot;: left taken.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            right.acquire();</span></span><br><span class="line">                <span class="comment">// 1초동안기다리다가 오른쪽 포크를 못 집으면 왼쪽 포크를 내려놓는다.</span></span><br><span class="line">                <span class="keyword">if</span> (!right.tryAcquire(<span class="number">1000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    left.release();</span><br><span class="line">                    Thread.yield(); <span class="comment">// 왼쪽 포크를 내려놓고 컨티뉴되서 다시 반복문이돌아서 다시 집어든다 좀더 양보를해서 다른 스레드가 획득할 기회를 더 준다.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(id + <span class="string">&quot;: right taken.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(id + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left.release();</span><br><span class="line">            right.release();</span><br><span class="line">            Thread.yield(); <span class="comment">// 먹은 다음에 양보함.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fork</span> <span class="keyword">extends</span> <span class="title">Semaphore</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinigPhillisopher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Philosopher[] phils = <span class="keyword">new</span> Philosopher[<span class="number">5</span>];</span><br><span class="line">        Fork[] forks = <span class="keyword">new</span> Fork[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            forks[i] = <span class="keyword">new</span> Fork();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//            phils[i] = new Philosopher(i,forks[i],forks[(i+1) % 5]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            phils[i] = <span class="keyword">new</span> Philosopher(i,forks[i],forks[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        phils[<span class="number">4</span>] = <span class="keyword">new</span> Philosopher(<span class="number">4</span>, forks[<span class="number">0</span>],forks[<span class="number">4</span>]); <span class="comment">// 이건 오른쪽을 먼저 들기 때문에 다른사람들이 먹는 확률이 올라감 근데 먹는사람만 먹는 단점이 생김</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            phils[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JCF와-멀티스레드"><a href="#JCF와-멀티스레드" class="headerlink" title="JCF와 멀티스레드"></a>JCF와 멀티스레드</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.s14.p09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list3 = Collections.synchronizedList(list2);</span><br><span class="line">        <span class="comment">// 어레이리스트인데 싱크된다. 이게 훨씬 빠르다.</span></span><br><span class="line">        <span class="comment">// list3 : list2의 싱크된 버전</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    list1.add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line"><span class="comment">//                    synchronized (list2) &#123; // 이렇게 해줬을 때 위에 보다 느림??</span></span><br><span class="line">                        list3.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">        <span class="comment">// 멀티스레드여서 이렇게 기다려야 더 정확해진다? 뭐지 생각해봐</span></span><br><span class="line">        <span class="comment">// 3개의 스레드가 동작한다 메인, 스레드 1, 스레드2 메인스레드에서 동작을 하면서 스레드1,2가 동작을 하는데 이 스레드들이 동작이 다끝나지 않은 상태에서</span></span><br><span class="line">        <span class="comment">// 메인스레드가 종료될 수 있으니깐 메인스레드에 sleep을 줘서 시간차를 준다음에 사이즈를 출력하게 하기 위해서이다.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(list1.size());</span><br><span class="line">        System.out.println(list2.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="스레드-풀-Thread-pool"><a href="#스레드-풀-Thread-pool" class="headerlink" title="스레드 풀(Thread pool)"></a>스레드 풀(Thread pool)</h2><ul>
<li>일반 스레드를 직접 만들어 사용할 경우, 작업을 마친 스레드는 종료된다.(1회용 이니깐)<ul>
<li>멀티 스레들 작업을 계속 할 경우, 스레드를 생성 / 삭제하는 오버헤드가 있다.(속도가 떨어지고, 관리가 어렵다.)</li>
</ul>
</li>
<li>스레드 풀<ul>
<li>미리 생성해 둔 스레드의 집합을 스레드 풀 이라고 한다.( 뭔가를 사용하기 위해 모아둔 것을 풀이라고 함)</li>
<li>미리 스레드를 생성해 두고, 작업만 스레드를 할당하여 동작한다.</li>
<li>배치 작업(모아두고 한번에 처리하는 작업)에 많이 사용.</li>
</ul>
</li>
<li>핵심! 미리 만들어 놓고 상황에 맞춰 동작하게 한다.</li>
</ul>
<h3 id="스레드-풀-생성-방법"><a href="#스레드-풀-생성-방법" class="headerlink" title="스레드 풀 생성 방법"></a>스레드 풀 생성 방법</h3><ul>
<li>Executors <ul>
<li>실행하는 애들을 만들어 놓는 클래스</li>
<li>ExecutorService 객체를 생성하며, 다음 메소드를 제공하여 쓰레드 풀을 개수 및 종류를 정할 수 있습니다.<h4 id="1-newCachedThreadPool"><a href="#1-newCachedThreadPool" class="headerlink" title="1. newCachedThreadPool()"></a>1. newCachedThreadPool()</h4></li>
</ul>
</li>
<li>필요할 때, 필요한 만큼 스레드 풀을 생성한다.</li>
<li>초기 스레드가 0개 하나도 안돌아가고 있어서 오버헤드도 발생하지 않고 어떻게 동작할지 모르는 상태에서 무난하게 사용 가능</li>
<li>코어 스레드가 0개 - 일하지 않아도 살려두는 스레드</li>
<li>요청 작업보다 스레드가 부족하면 새 스레드를 생성한다.(작업에 맞춰 스레드를 생성)</li>
<li>60초 동안  일하지 않은 스레드를 제거한다.</li>
<li>안정적으로 사용할 때 사용!<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2. newFixedThreadPool();"></a>2. newFixedThreadPool();</h4><ul>
<li>인자 개수만큼의 고정된 스레드풀을 생성한다.</li>
<li>최대 스레드 nThreads개</li>
<li>코어 스레드 nThreads개 입력  값 개수</li>
<li>요청 작업보다 스레드가 부족하면 새 스레드를 생성</li>
<li>작업하지 않는 스레드도 제거하지 않고 동작한다.</li>
<li>한번 증가하면 죽이지 않는다. 풀파워로 쓸 때 사용<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 입력받음</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-new-ThreadPoolExecutor"><a href="#3-new-ThreadPoolExecutor" class="headerlink" title="3. new ThreadPoolExecutor()"></a>3. new ThreadPoolExecutor()</h4><ul>
<li>corePoolsize, maximumPoolsize, keepAliveTime, TimeUnit, BlockingQueue를 인자로 받을 수 있다.<ul>
<li>corePoolsize : 코어 스레드의 개수</li>
<li>maximumPoolsize : 최대 스레드 개수</li>
<li>keepAliveTime : 스레드가 일하지 않을 때 제거하기 위한 대기 시간</li>
<li>TimeUnit : 시간 단위를 지정</li>
<li>BlockingQueue : 작업 요청이 오면 쌓아뒀다가 스레드 풀에 하나씩 할당해서 동작한다.<ul>
<li>이게 없으면 작업 요청하면 실제 스레드로 들어가서 동작하기 전까지 메인 스레드가 멈춰 있어야 한다.<br>그래서 큐에 던져놓고 메인스레드는 동작하게 하는 것이다.(존재한다.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">      <span class="number">10</span>, <span class="comment">// 코어 스레드 개수</span></span><br><span class="line">      <span class="number">100</span>, <span class="comment">// 최대 스레드 개수</span></span><br><span class="line">      <span class="number">120</span>, <span class="comment">// 스레드가 이 시간 동안 일하지 않으면 제거 (대기 시간)</span></span><br><span class="line">      TimeUnit.SECONDS, <span class="comment">// 시간 단위를 지정</span></span><br><span class="line">      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;() <span class="comment">// 작업을 요청하면 -&gt; 작업을 쌓아둘 큐 -&gt; 스레드 풀로 할당해서 넘어가서 동작한다.</span></span><br><span class="line">      <span class="comment">// 이게 없으면 작업 요청하면 실제 스레드로 들어가서 동작하기 전까지 메인 스레드가 멈춰있어야 한다. 그래서 큐에 던져 놓고</span></span><br><span class="line">      <span class="comment">// 메인스레드는 동작하게 하는 것이다.(존재한다.)</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="스레드-풀-동작-순서"><a href="#스레드-풀-동작-순서" class="headerlink" title="스레드 풀 동작 순서"></a>스레드 풀 동작 순서</h3><h4 id="1-스레드-풀-생성"><a href="#1-스레드-풀-생성" class="headerlink" title="1. 스레드 풀 생성"></a>1. 스레드 풀 생성</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool1 = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<h4 id="2-스레드에-할당할-작업-생성"><a href="#2-스레드에-할당할-작업-생성" class="headerlink" title="2. 스레드에 할당할 작업 생성"></a>2. 스레드에 할당할 작업 생성</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableWork</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;작업 종료&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-스레드에-작업-요청"><a href="#3-스레드에-작업-요청" class="headerlink" title="3. 스레드에 작업 요청"></a>3. 스레드에 작업 요청</h4><ul>
<li>sumbit() - 스레드를 실행는 메소드<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = <span class="literal">null</span>; </span><br><span class="line">future = pool1.submit(<span class="keyword">new</span> CallableWork());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    pool1.submit(<span class="keyword">new</span> Work()); <span class="comment">// 리턴이 있음</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-스레드-종료-동기화"><a href="#4-스레드-종료-동기화" class="headerlink" title="4. 스레드 종료(동기화)"></a>4. 스레드 종료(동기화)</h4></li>
<li>shutdown() - Thread.join()과 비슷하게 작업이 끝나기를 기다려서 종료<ul>
<li>데몬 스레드가 아닌 이상 (일반 스레드는 )스레드 풀은 자동 종료가 안되기 때문에,직접 스레드 풀을 종료해 주어야 한다.</li>
</ul>
</li>
<li>shutdownNow()는 바로 종료시키는 것</li>
<li>cancle() -  스레드를 종료시킬 때 사용하는 또 다른 메소드로 여기서는 실행중인 Callable 객체를 강제 종료할 수 있다. (mayInterruptIfRunning)안에 true, false 매개값을 줄 수 있다.<ul>
<li>true - 해당 스레드에 인터럽트를 보낸다, true를 주면 추가 기능이 생긴다.(false의 기능에서 더 추가된다.) 작업하는 스레드에 인터럽트를 걸어준다.</li>
<li>false - false를 주고 cancle()을 호출하면 스레드는 아무 동작이 일어나지 않고.(종료하지 않음), get을 할 수 없게 된다.(CanclelationException 발생)</li>
</ul>
</li>
<li>get() - Blocking Method로 CallableWork()의 객체의 작업이 다 끝나고 future로 값이 들어올 때까지 기다리다가 값이 들어오면 작업을 수행한다.<ul>
<li>기다리기는 상황이 있기 때문에 Interrupt가 들어올 수 있다. 들어오면 InterruptException을 수행한다.</li>
<li>Blocking Method이니깐 기다리는 상황일 때 계속 기다리기만 하는 상황이 생길 수 있어서 매개값으로 timeout을 설정할 수 있다.<ul>
<li>Blocking - 다른 작업이 기다릴 때가지 기다리는 것.</li>
</ul>
</li>
</ul>
</li>
<li>isCancelled() - cancle() 됬는지 확인할 때 사용하는 메소드</li>
<li>isDonle() - 작업이 잘 끝났는지 확인하는 메소드이다.</li>
<li>Callable가 어떻게 작업하는지 모르기때문에 외부에서 컨트롤할 수 있게 하기위해 위의 메소드들을 제공한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pool1.shutdown(); <span class="comment">// Thread.join()과 비슷하게 작업이 끝나기를 기다려서 종료</span></span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 다른 스레드와 동기화를 맞추기 위해(여기서는 pool1이 작업을 진행중) 잠시 기다렸다가 밑에 코드가 진행되니깐 작업완료가 마지막에 출력됨!</span></span><br><span class="line"></span><br><span class="line">future.cancel(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">    </span><br><span class="line">    future.isCancelled(); <span class="comment">//캔슬 됬는지 확인</span></span><br><span class="line">    future.isDone(); <span class="comment">// 작업이 잘 끝났는지 확인</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/31/Java/JavaAdvanced/Java-MultiThread/" data-id="ckgxjhqff002pcwu2bld748sr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-RegularExpression" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/31/Java/JavaAdvanced/Java-RegularExpression/" class="article-date">
  <time datetime="2020-10-31T10:16:00.987Z" itemprop="datePublished">2020-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/31/Java/JavaAdvanced/Java-RegularExpression/">Java_RegularExpression(정규표현식)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="정규표현식-Regular-Expression"><a href="#정규표현식-Regular-Expression" class="headerlink" title="정규표현식(Regular Expression)"></a>정규표현식(Regular Expression)</h1><h2 id="정규표현식이란"><a href="#정규표현식이란" class="headerlink" title="정규표현식이란?"></a>정규표현식이란?</h2><ul>
<li>문자열을 다루는 패턴화된 작업을 정의하는 수식</li>
<li>문자열 매칭, 템플릿 일치 여부 확인, 템플릿 매칭 검색(문서가 있을 때 이메일만 뽑는 작업을 할 때 등등)</li>
<li>정규표현식은 느리기 때문에 남용하면 안된다. 많은 동작을 돌리면 안된다. 알고리즘 문제를 정규표현식을 푸는건 적합하지 않음</li>
<li>특정 조건에 맞는 문자열을 검색(search) / 치환(Replace)를 하는 패턴 기반의 식( 패턴: 전화번호 같은 것, 이메일)</li>
<li>이메일, 전화 번호 등 특정한 형식에 맞게 적혀 있는지 Validation 하는데 사용 가능</li>
<li>Crawling(자료를 긁어 모으는 것) 등 날 것의 자료를 긁어 모았을 때 정리 하는데 유용</li>
<li>튜브 댓글이 있으면 형식에 따라 분석을 하고 구분을 할 수 있다.</li>
</ul>
<h2 id="정규표현식-표현-방법"><a href="#정규표현식-표현-방법" class="headerlink" title="정규표현식 표현 방법"></a>정규표현식 표현 방법</h2><ul>
<li><p>정규 표현식의 기본 작성 방식</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/패턴/[플래그(Opt.)]&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>기본 메타 문자</p>
<table>
<thead>
<tr>
<th>메타 문자</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td><code>^x</code></td>
<td>x로 시작</td>
</tr>
<tr>
<td><code>x$</code></td>
<td>x로 끝</td>
</tr>
<tr>
<td><code>.x</code></td>
<td>x앞에 하나의 문자가 있다.</td>
</tr>
<tr>
<td><code>x+</code></td>
<td>x가 1번 이상 반복</td>
</tr>
<tr>
<td><code>x?</code></td>
<td>x가 있거나 없다.</td>
</tr>
<tr>
<td><code>x*</code></td>
<td>x가 0번 이상 반복</td>
</tr>
<tr>
<td><code>.</code></td>
<td>아무 문자 하나를 의미</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>괄호의 활용</p>
<table>
<thead>
<tr>
<th>regexp</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td><code>(xy)</code></td>
<td>괄호 안의 내용을 그룹화</td>
</tr>
<tr>
<td><code>x&#123;n&#125;</code></td>
<td>n번 반복됨</td>
</tr>
<tr>
<td><code>x&#123;n,&#125;</code></td>
<td>n번 이상 반복됨</td>
</tr>
<tr>
<td><code>x&#123;n, m&#125;</code></td>
<td>n번 이상, m번 이하 반복됨</td>
</tr>
<tr>
<td><code>[xy]</code></td>
<td>x 또는 y</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>알파벳 소문자 (a~z)</td>
</tr>
<tr>
<td><code>[0-9]</code></td>
<td>숫자</td>
</tr>
<tr>
<td><code>[가-힣]</code></td>
<td>한글</td>
</tr>
<tr>
<td><code>[^x]</code></td>
<td>x가 아닌 것</td>
</tr>
<tr>
<td><code>[^0-9]</code></td>
<td>숫자가 아닌 것</td>
</tr>
</tbody></table>
</li>
<li><p><code>\...</code> 축약 문자</p>
<table>
<thead>
<tr>
<th>regexp</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td><code>\^</code>,<code>\.</code>…</td>
<td><code>\</code> 뒤에 나오는 문자를 문자로 처리</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>단어의 경계를 찾는다.</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>단어의 경계가 아닌 것을 찾는다.</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>숫자를 찾는다.</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>숫자가 아닌 것을 찾는다.</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>공백 문자를 찾는다.</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>공백 문자가 아닌 것을 찾는다.</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>[a-zA-Z0-9_]</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>[^a-zA-Z0-9_]</td>
</tr>
</tbody></table>
</li>
<li><p>유용한 정규식 예</p>
<ul>
<li>한글 이름 : <code>^[가-힣]&#123;2,5&#125;$</code></li>
<li>핸드폰 번호: <code>^01(0|1|2|6|9)[-\s]?\d&#123;3,4&#125;[-\s]?\d&#123;4&#125;$</code></li>
<li>이메일 주소: <code>^[\w\.-]&#123;1,64&#125;@[\w\.-]&#123;1,252&#125;\.\w&#123;2,4&#125;$</code></li>
</ul>
</li>
</ul>
<h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><table>
<thead>
<tr>
<th>Flag</th>
<th>기능</th>
</tr>
</thead>
<tbody><tr>
<td><code>g</code></td>
<td>문자열 내 모든 패턴을 찾음</td>
</tr>
<tr>
<td><code>i</code></td>
<td>대소문자를 구분하지 않음</td>
</tr>
<tr>
<td><code>m</code></td>
<td>문자열의 모든 줄에서 찾음</td>
</tr>
</tbody></table>
<h2 id="정규표현식을-사용하는-클래스"><a href="#정규표현식을-사용하는-클래스" class="headerlink" title="정규표현식을 사용하는 클래스"></a>정규표현식을 사용하는 클래스</h2><h3 id="Pattern-클래스"><a href="#Pattern-클래스" class="headerlink" title="Pattern 클래스"></a>Pattern 클래스</h3><table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>static Pattern compile(String regex)    Pattern 객체를 생성</td>
</tr>
<tr>
<td>public</td>
<td>Matcher matcher(CharSequence input)    입력을 분석하는 Matcher 객체 생성</td>
</tr>
<tr>
<td>public</td>
<td>static boolean matches(String regex, CharSequence input)    입력이 regexp에 해당하는지 판단</td>
</tr>
</tbody></table>
<h3 id="Matcher-클래스"><a href="#Matcher-클래스" class="headerlink" title="Matcher 클래스"></a>Matcher 클래스</h3><table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>find()</td>
<td>정규표현식에 부합되는 내용이 문자열에 포함되어 있는지 반환. 이전 검색 위치부터 이어서 검색.</td>
</tr>
<tr>
<td>start()</td>
<td>패턴에 부합되는 요소의 시작 인덱스 반환</td>
</tr>
<tr>
<td>end()</td>
<td>패턴에 부합되는 요소가 끝나는 위치 + 1을 반환</td>
</tr>
<tr>
<td>matches()</td>
<td>문자열 전체가 정규표현식에 일치하는지 반환</td>
</tr>
<tr>
<td>lookingAt()</td>
<td>비교하려는 문자열이 정규표현식으로 시작하는지 반환. 0번 인덱스부터 검색.</td>
</tr>
<tr>
<td>replaceFirst()</td>
<td>일치하는 첫 패턴을 문자열로 대체</td>
</tr>
<tr>
<td>replaceAll()</td>
<td>일치하는 모든 패턴을 문자열로 대체</td>
</tr>
<tr>
<td>reset()</td>
<td>Matcher의 정보를 리셋하여 0번 인덱스부터 다시 검색</td>
</tr>
</tbody></table>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a target="_blank" rel="noopener" href="https://regexper.com/">정규표현식을 이미지로 보여주 사이트</a></li>
<li><a target="_blank" rel="noopener" href="https://regexone.com/lesson/introduction_abcs">정규표현식 연습문제 사이트</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/31/Java/JavaAdvanced/Java-RegularExpression/" data-id="ckgxjhqcz001qcwu207qr3gz6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/Solution-StockPrice" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/23/Algorithm/Solution-StockPrice/" class="article-date">
  <time datetime="2020-10-23T09:46:24.463Z" itemprop="datePublished">2020-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/23/Algorithm/Solution-StockPrice/">AlgorithmSolution_StockPrice(주식가격)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Algorithm-주식가격"><a href="#Algorithm-주식가격" class="headerlink" title="Algorithm - 주식가격"></a>Algorithm - <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/42584">주식가격</a></h1><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><ul>
<li>초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.</li>
</ul>
<h3 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h3><ul>
<li>prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.</li>
<li>prices의 길이는 2 이상 100,000 이하입니다.</li>
</ul>
<h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table>
<thead>
<tr>
<th>prices</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>[1, 2, 3, 2, 3]</td>
<td>[4, 3, 1, 1, 0]</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><ul>
<li>1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.</li>
<li>4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.</li>
<li>5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><h3 id="내가-구현한-코드"><a href="#내가-구현한-코드" class="headerlink" title="내가 구현한 코드"></a>내가 구현한 코드</h3><ul>
<li>처음에 내가 구현했더 코드이다. 너무나 쉽게 구현했다고 생각이 들어서 다른 테스트 케이스를 넣어서 기대값들을 예상해서 출력을 해보면<br>기대했던 값들과 똑같이 나온다. 그런데 프로그래머스 채점을 돌리게 되면 맞는게 하나도 없다.. 완전히 잘 못 구현한 것 같다 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.stackandqueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionStockPrice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>])&#123;</span><br><span class="line">                answer[i] = prices.length - (i+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                answer[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> SolutionStockPrice().solution(prices)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="다른-사람의-풀이"><a href="#다른-사람의-풀이" class="headerlink" title="다른 사람의 풀이"></a>다른 사람의 풀이</h3><ul>
<li>다른 사람들이 풀었던걸 보고, 다시 안보고 구현해 봤다. 이렇게 하니 모든 테스트를 통과했다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.stackandqueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionStockPrice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[i] &lt;= prices[j])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            answer[i] = count;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/23/Algorithm/Solution-StockPrice/" data-id="ckgxjhqba000ecwu23x4b6a7x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/Solution-NotFinishedPlayer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/23/Algorithm/Solution-NotFinishedPlayer/" class="article-date">
  <time datetime="2020-10-23T00:31:56.512Z" itemprop="datePublished">2020-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/23/Algorithm/Solution-NotFinishedPlayer/">AlgorithmSolution_완주하지 못한 선수</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Algoritm-완주하지-못한-선수"><a href="#Algoritm-완주하지-못한-선수" class="headerlink" title="Algoritm - 완주하지 못한 선수"></a>Algoritm - <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/42576">완주하지 못한 선수</a></h1><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><ul>
<li>수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.</li>
<li>마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.</li>
</ul>
<h3 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h3><ul>
<li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li>
<li>completion의 길이는 participant의 길이보다 1 작습니다.</li>
<li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li>
<li>참가자 중에는 동명이인이 있을 수 있습니다.</li>
</ul>
<h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table>
<thead>
<tr>
<th>participant</th>
<th>completion</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>[leo, kiki, eden]</td>
<td>[eden, kiki]</td>
<td>leo</td>
</tr>
<tr>
<td>[marina, josipa, nikola, vinko, filipa]</td>
<td>[josipa, filipa, marina, nikola]</td>
<td>vinko</td>
</tr>
<tr>
<td>[mislav, stanko, mislav, ana]</td>
<td>[stanko, ana, mislav]</td>
<td>mislav</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><h4 id="예제-1"><a href="#예제-1" class="headerlink" title="예제 #1"></a>예제 #1</h4><ul>
<li>leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.</li>
</ul>
<h4 id="예제-2"><a href="#예제-2" class="headerlink" title="예제 #2"></a>예제 #2</h4><ul>
<li>vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.</li>
</ul>
<h4 id="예제-3"><a href="#예제-3" class="headerlink" title="예제 #3"></a>예제 #3</h4><ul>
<li>mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><h3 id="내가-구현한-코드"><a href="#내가-구현한-코드" class="headerlink" title="내가 구현한 코드"></a>내가 구현한 코드</h3><ul>
<li>내가 구현한 코드인데 제한 사항중에서 참가자중에 동명이인이 있을 수 있는 3번째 케이스에 대한<br>구현을 어떻게 해결해야 하는지 생각해내지 못했다. 고민하다가 다른 분들의 코드를 참고하기로 했다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solution</span><span class="params">(String[] participant, String[] completion)</span> </span>&#123;</span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; participant.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; completion.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (participant[i] != completion[j])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == completion.length)&#123;</span><br><span class="line">                    answer = participant[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFinishedPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] participant = &#123;<span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;ana&quot;</span>&#125;;</span><br><span class="line">        String[] completion = &#123;<span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;ana&quot;</span>, <span class="string">&quot;mislav&quot;</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().solution(participant,completion));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="해쉬를-이용한-방법"><a href="#해쉬를-이용한-방법" class="headerlink" title="해쉬를 이용한 방법"></a>해쉬를 이용한 방법</h3><ul>
<li>해쉬맵을 이용해서 구현한 방법이다. 해쉬에 입력할 때 <code>key: 참가자이름</code> 과 <code>value: 인원수</code>로 해서<br>그 이름에 몇명이 있는지 hash에 입력이 된다. 그러고 나서 completion 완주자를 반복하면서 인원수를 빼주면<br>인원수가 0이 남게 되면 그 사람은 완주한사람이 되는 것이다 그래서 0이 아닌 값은 완주하지 못한 사람이 되니깐<br>그 key 값을 반환해주면 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solution</span><span class="params">(String[] participant, String[] completion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Map&lt;String,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : participant)&#123;</span><br><span class="line">            hash.put(name, hash.getOrDefault(name,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : completion)&#123;</span><br><span class="line">            hash.put(name, hash.get(name)-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key : hash.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.get(key) != <span class="number">0</span>)&#123;</span><br><span class="line">                answer = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFinishedPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] participant = &#123;<span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;ana&quot;</span>&#125;;</span><br><span class="line">        String[] completion = &#123;<span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;ana&quot;</span>, <span class="string">&quot;mislav&quot;</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().solution(participant,completion));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays를-이용한-방법"><a href="#Arrays를-이용한-방법" class="headerlink" title="Arrays를 이용한 방법"></a>Arrays를 이용한 방법</h3><ul>
<li>Arrays를 이용해서 participant와 completion을 정렬해준다.</li>
<li>그러면 둘 다 같은 순으로 정렬이 될테고, 순서상 같지 않은 참가자를 반환하거나<br>완주자는 참가자보다 길이가 1작으니깐 i를 반복문 전에 로컬 변수로 따로 선언해서 반복문이 돌아가고 순서상 다 같다면 조건문에 걸리지 않아서<br>return 되지 않으니깐 마지막 i++해서 완주자 목록에는 없는 참가자가 완주하지 못한 사람이 된다.<br>그래서 <code>return participant[i];</code> 을 해주게 되는 것이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solution</span><span class="params">(String[] participant, String[] completion)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(participant);</span><br><span class="line">        Arrays.sort(completion);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; completion.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!participant[i].equals(completion[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> participant[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> participant[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFinishedPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] participant = &#123;<span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;mislav&quot;</span>, <span class="string">&quot;ana&quot;</span>&#125;;</span><br><span class="line">        String[] completion = &#123;<span class="string">&quot;stanko&quot;</span>, <span class="string">&quot;ana&quot;</span>, <span class="string">&quot;mislav&quot;</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().solution(participant,completion));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/23/Algorithm/Solution-NotFinishedPlayer/" data-id="ckgxjhqb5000bcwu258srbikn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/Solution-PhoneNumberList" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/23/Algorithm/Solution-PhoneNumberList/" class="article-date">
  <time datetime="2020-10-23T00:30:56.655Z" itemprop="datePublished">2020-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/23/Algorithm/Solution-PhoneNumberList/">AlgorithmSolution_전화 번호 목록</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Alogorithm-전화번호목록"><a href="#Alogorithm-전화번호목록" class="headerlink" title="Alogorithm - 전화번호목록"></a>Alogorithm - <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/42577">전화번호목록</a></h1><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><ul>
<li>전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.<br>전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.<ul>
<li>구조대 : 119</li>
<li>박준영 : 97 674 223</li>
<li>지영석 : 11 9552 4421</li>
</ul>
</li>
<li>전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.</li>
</ul>
<h3 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h3><ul>
<li>phone_book의 길이는 1 이상 1,000,000 이하입니다.</li>
<li>각 전화번호의 길이는 1 이상 20 이하입니다.</li>
</ul>
<h3 id="입출력-예제"><a href="#입출력-예제" class="headerlink" title="입출력 예제"></a>입출력 예제</h3><table>
<thead>
<tr>
<th>phone_book</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>[119, 97674223, 1195524421]</td>
<td>false</td>
</tr>
<tr>
<td>[123,456,789]</td>
<td>true</td>
</tr>
<tr>
<td>[12,123,1235,567,88]</td>
<td>false</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><h4 id="입출력-예-1"><a href="#입출력-예-1" class="headerlink" title="입출력 예 #1"></a>입출력 예 #1</h4><ul>
<li>앞에서 설명한 예와 같습니다.</li>
</ul>
<h4 id="입출력-예-2"><a href="#입출력-예-2" class="headerlink" title="입출력 예 #2"></a>입출력 예 #2</h4><ul>
<li>한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.</li>
</ul>
<h4 id="입출력-예-3"><a href="#입출력-예-3" class="headerlink" title="입출력 예 #3"></a>입출력 예 #3</h4><ul>
<li>첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><h3 id="알고리즘-풀면서-배운-점"><a href="#알고리즘-풀면서-배운-점" class="headerlink" title="알고리즘 풀면서 배운 점"></a>알고리즘 풀면서 배운 점</h3><ul>
<li>내가 구현한 코드는 이중 반복문을 하면서 같은 값이 나왔을 때는 <code>continue</code>하고, 접두어가 나오게 되면 false를 반환하도록 구현하는 풀이 과정은 맞았던 것 같다.<br>그런데 테스트 케이스는 통과했지만, 효율성 체크하는 부분에서 시관초과 실패를 했다… 다른 사람들의 풀이를 보면 정말 간단한 문제였다.<br>핵심 부분은 <code>return false</code>를 바로 하는 거였다고 생각한다. 이걸 바로 사용하면 더 이상 코드가 진행되지 않고 끝나게 되니깐.. 결정력이 부족했다</li>
</ul>
<h3 id="내가-구현한-코드"><a href="#내가-구현한-코드" class="headerlink" title="내가 구현한 코드"></a>내가 구현한 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionPhoneNumberList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Boolean&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phone_book.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; phone_book.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phone_book[i].equals(phone_book[j]))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phone_book[j].startsWith(phone_book[i]))&#123;</span><br><span class="line">                    hash.put(phone_book[i],<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    hash.put(phone_book[i],<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash.values().contains(<span class="keyword">false</span>))&#123;</span><br><span class="line">            answer = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumberList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] phone_book = &#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;1235&quot;</span>,<span class="string">&quot;567&quot;</span>,<span class="string">&quot;88&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> SolutionPhoneNumberList().solution(phone_book));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="다른-사람들의-구현-코드"><a href="#다른-사람들의-구현-코드" class="headerlink" title="다른 사람들의 구현 코드"></a>다른 사람들의 구현 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Hash;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionPhoneNumberList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phone_book.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; phone_book.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phone_book[j].startsWith(phone_book[i]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 여기서 return이 핵심인 것 같다.. retrun을 해주면 더 이상 진행이되지 않고 끝나니깐...</span></span><br><span class="line">                    <span class="comment">// 대박.. 이걸 생각 못함...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumberList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] phone_book = &#123;<span class="string">&quot;12&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;1235&quot;</span>,<span class="string">&quot;567&quot;</span>,<span class="string">&quot;88&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> SolutionPhoneNumberList().solution(phone_book));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/23/Algorithm/Solution-PhoneNumberList/" data-id="ckgxjhqb7000ccwu2flvfak07" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/Solution-NumberKth" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/21/Algorithm/Solution-NumberKth/" class="article-date">
  <time datetime="2020-10-21T12:28:39.658Z" itemprop="datePublished">2020-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/21/Algorithm/Solution-NumberKth/">AlgorithmSolution_K번째 수</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Algorithm-k번째수"><a href="#Algorithm-k번째수" class="headerlink" title="Algorithm - k번째수"></a>Algorithm - <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/42748">k번째수</a></h1><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><ul>
<li>배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.</li>
<li>예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면<ul>
<li>array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.</li>
<li>1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.</li>
<li>2에서 나온 배열의 3번째 숫자는 5입니다.</li>
</ul>
</li>
<li>배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.</li>
</ul>
<h3 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h3><ul>
<li>array의 길이는 1 이상 100 이하입니다.</li>
<li>array의 각 원소는 1 이상 100 이하입니다.</li>
<li>commands의 길이는 1 이상 50 이하입니다.</li>
<li>commands의 각 원소는 길이가 3입니다.</li>
</ul>
<h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table>
<thead>
<tr>
<th>array</th>
<th>commands</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>[1, 5, 2, 6, 3, 7, 4]</td>
<td>[[2, 5, 3], [4, 4, 1], [1, 7, 3]]</td>
<td>[5, 6, 3]</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><ul>
<li>[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.</li>
<li>[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.</li>
<li>[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.</li>
</ul>
<h2 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.Programmers.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[][] commands) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.length; i++) &#123;</span><br><span class="line">            first = commands[i][<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line">            last = commands[i][<span class="number">1</span>];</span><br><span class="line">            num = commands[i][<span class="number">2</span>]-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = first; j&lt;last; j++)&#123;</span><br><span class="line">                list.add(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.sort(Integer::compareTo);</span><br><span class="line">            temp.add(list.get(num));</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer = <span class="keyword">new</span> <span class="keyword">int</span>[temp.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;temp.size(); i++) &#123;</span><br><span class="line">            answer[i] = temp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberKth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] commands = &#123;&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> Solution().solution(array,commands)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/21/Algorithm/Solution-NumberKth/" data-id="ckgxjhqb2000acwu2hjfee5mw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/SW_Enginerring/DesignPatterns" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/18/Java/SW_Enginerring/DesignPatterns/" class="article-date">
  <time datetime="2020-10-18T06:59:16.045Z" itemprop="datePublished">2020-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/18/Java/SW_Enginerring/DesignPatterns/">SW_Enginerring-DesignPatterns</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="디자인-패턴-Design-Patterns"><a href="#디자인-패턴-Design-Patterns" class="headerlink" title="디자인 패턴 (Design Patterns)"></a>디자인 패턴 (Design Patterns)</h1><ul>
<li>디자인 패턴이 어떤 것인지와 대표적으로 사용하는 패턴에 대한 사용법 정도만 정리했다.</li>
</ul>
<h2 id="디자인-패턴이란"><a href="#디자인-패턴이란" class="headerlink" title="디자인 패턴이란"></a>디자인 패턴이란</h2><ul>
<li>자주 발생하는 문제를 쉽게 해결하기 위해 제시된 재사용 가능한 해결책<ul>
<li>Don’t reinvent the Wheel (바퀴를 다시 발명하지 마라)</li>
</ul>
</li>
<li>이미 해결된 방식은 해결된 방식대로 해결하고, 새롭게 맞딱드린 문제를 해결하자</li>
<li>소프트웨어 설계 문제를 쉽게 해결할 수 있도록 패턴화된 설계 방식</li>
<li>팀원들과의 소통을 위해 디자인 패턴 학습이 필요하다.<ul>
<li>팀원들이 싱글톤 패턴으로 해결 해주세요 할 때 이 패턴에 대해서 알고 있어야 하겠지?</li>
</ul>
</li>
</ul>
<h2 id="디자인-패턴의-구조"><a href="#디자인-패턴의-구조" class="headerlink" title="디자인 패턴의 구조"></a>디자인 패턴의 구조</h2><ul>
<li>문맥(Context)<ul>
<li>패턴이 적용될 수 있는 문제 상황을 기술</li>
</ul>
</li>
<li>문제(Problem)<ul>
<li>패턴이 적용되어 해결되어야 하는 여러 설계 이슈를 기술</li>
</ul>
</li>
<li>해결(Solution)<ul>
<li>문제를 해결하는 설계 구성 요소와 구성 요소 사이의 관계를 기술</li>
</ul>
</li>
</ul>
<h2 id="디자인-패턴의-종류"><a href="#디자인-패턴의-종류" class="headerlink" title="디자인 패턴의 종류"></a>디자인 패턴의 종류</h2><ul>
<li>Gang of four 패턴<ul>
<li>생성 패턴 (Creational patterns)<ul>
<li>객체의 생성 방식에 관련된 패턴</li>
<li>Abstract Factory, Factory Method, Singleton …</li>
</ul>
</li>
<li>구조 패턴 (Structural patterns)<ul>
<li>클래스/객체를 조합한 구조를 가지는 패턴</li>
<li>Composite, Decorator …</li>
</ul>
</li>
<li>동작 패턴 (Behavioral patterns)<ul>
<li>클래스/객체 사이의 동작 분배에 관련된 패턴</li>
<li>Observer, State, Strategy, Template Method, Command …</li>
</ul>
</li>
</ul>
</li>
<li>동시성 패턴 (Concurrency patterns)<ul>
<li>Scheduling, Monitor, Lock …</li>
</ul>
</li>
<li>아키텍처 패턴 (Architecture patterns)<ul>
<li>Model-View-Controller, Model-View-Presenter, Model-View-ViewModel …</li>
</ul>
</li>
<li>기타 패턴<ul>
<li>Dependency injection, Lazy loading, Mock object …</li>
</ul>
</li>
</ul>
<h2 id="대표적인-디자인-패턴"><a href="#대표적인-디자인-패턴" class="headerlink" title="대표적인 디자인 패턴"></a>대표적인 디자인 패턴</h2><h3 id="싱글톤-패턴"><a href="#싱글톤-패턴" class="headerlink" title="싱글톤 패턴"></a>싱글톤 패턴</h3><ul>
<li>단 하나의 객체만 존재할 수 있는 클래스를 구현하는 패턴<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="팩토리-패턴"><a href="#팩토리-패턴" class="headerlink" title="팩토리 패턴"></a>팩토리 패턴</h3></li>
<li>구상 클래스 객체를 전담하여 생성하는 클래스를 구현하는 패턴</li>
<li>팩토리 메소드 패턴 (ref)</li>
</ul>
<p><img src="../../../image/%ED%8C%A9%ED%86%A0%EB%A6%AC%ED%8C%A8%ED%84%B4.jpg" alt="팩토리 패턴"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"></span><br><span class="line">    Shape shape1 = shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line">    shape1.draw();</span><br><span class="line"></span><br><span class="line">    Shape shape2 = shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    shape2.draw();</span><br><span class="line"></span><br><span class="line">    Shape shape3 = shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    shape3.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="추상-팩토리-패턴"><a href="#추상-팩토리-패턴" class="headerlink" title="추상 팩토리 패턴"></a>추상 팩토리 패턴</h3><p><img src="../../../image/%EC%B6%94%EC%83%81%ED%8C%A9%ED%86%A0%EB%A6%AC%ED%8C%A8%ED%84%B4.jpg" alt="추상 팩토리 패턴"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundedRectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside RoundedRectangle::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundedSquare</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside RoundedSquare::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;    </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();         </span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;     </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundedShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;    </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoundedRectangle();         </span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoundedSquare();</span><br><span class="line">      &#125;     </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(<span class="keyword">boolean</span> rounded)</span></span>&#123;   </span><br><span class="line">      <span class="keyword">if</span>(rounded)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoundedShapeFactory();         </span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line">      shape1.draw();</span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line">      shape2.draw();</span><br><span class="line"></span><br><span class="line">      AbstractFactory shapeFactory1 = FactoryProducer.getFactory(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      Shape shape3 = shapeFactory1.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line">      shape3.draw();</span><br><span class="line">      Shape shape4 = shapeFactory1.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line">      shape4.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="데코레이터-패턴"><a href="#데코레이터-패턴" class="headerlink" title="데코레이터 패턴"></a>데코레이터 패턴</h3><ul>
<li>생성자를 이용해 객체에 일정한 기능을 추가하는 패턴</li>
</ul>
<p><img src="../../../image/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0%20%ED%8C%A8%ED%84%B4.jpg" alt="데코레이터 패턴"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape: Rectangle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape: Circle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      decoratedShape.draw();</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(decoratedShape);        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      decoratedShape.draw();           </span><br><span class="line">      setRedBorder(decoratedShape);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Border Color: Red&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorPatternDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line"></span><br><span class="line">      Shape redCircle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line"></span><br><span class="line">      Shape redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line">      System.out.println(<span class="string">&quot;Circle with normal border&quot;</span>);</span><br><span class="line">      circle.draw();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;\nCircle of red border&quot;</span>);</span><br><span class="line">      redCircle.draw();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;\nRectangle of red border&quot;</span>);</span><br><span class="line">      redRectangle.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="옵저버-패턴"><a href="#옵저버-패턴" class="headerlink" title="옵저버 패턴"></a>옵저버 패턴</h3><ul>
<li>Observable 객체의 변화를 Observer에서 알 수 있도록 하는 패턴 </li>
</ul>
<p><img src="../../../image/%EC%98%B5%EC%A0%80%EB%B2%84%ED%8C%A8%ED%84%B4.jpg" alt="옵저버패턴"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">      observers.add(observer);        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">        observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Subject subject;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">&quot;Binary String: &quot;</span> + Integer.toBinaryString( subject.getState() ) ); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println( <span class="string">&quot;Octal String: &quot;</span> + Integer.toOctalString( subject.getState() ) ); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">&quot;Hex String: &quot;</span> + Integer.toHexString( subject.getState() ).toUpperCase() ); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> HexaObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;First state change: 15&quot;</span>);    </span><br><span class="line">      subject.setState(<span class="number">15</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Second state change: 10&quot;</span>);    </span><br><span class="line">      subject.setState(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/18/Java/SW_Enginerring/DesignPatterns/" data-id="ckgxjhqdd0026cwu2a2f4gym8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-Annotations" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/18/Java/JavaAdvanced/Java-Annotations/" class="article-date">
  <time datetime="2020-10-18T06:46:06.204Z" itemprop="datePublished">2020-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/18/Java/JavaAdvanced/Java-Annotations/">Java_Annotations</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="애노테이션-Annotation"><a href="#애노테이션-Annotation" class="headerlink" title="애노테이션(Annotation)"></a>애노테이션(Annotation)</h1><h2 id="애노테이션이란"><a href="#애노테이션이란" class="headerlink" title="애노테이션이란"></a>애노테이션이란</h2><ul>
<li>애노테이션의 사전적인 의미는 주석이다,</li>
<li>JVM, 컴파일러, 프레임워크 등에게 전달하는 메타데이터로 사용된다.</li>
<li>프로그램에게 추가적인 정보를 제공하는 메타데이터이다.<ul>
<li>메타데이터란 데이터를 설명하는 데이터를 의미한다.</li>
</ul>
</li>
</ul>
<h2 id="기본-애노테이션"><a href="#기본-애노테이션" class="headerlink" title="기본 애노테이션"></a>기본 애노테이션</h2><table>
<thead>
<tr>
<th>애노테이션</th>
<th>설명</th>
<th>비고</th>
</tr>
</thead>
<tbody><tr>
<td>@Override</td>
<td>상속하여 오버라이드된 메소드</td>
<td></td>
</tr>
<tr>
<td>@Deprecated</td>
<td>앞으로 사라질 예정임을 표기한다.</td>
<td></td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>컴파일러에게 특정 경고 메세지를 무시하도록 한다.</td>
<td>ex- @SuppressWarnings(“unused”)</td>
</tr>
<tr>
<td>@FuntionalInterface</td>
<td>함수형 인터페이스임을 표기(Lambda)</td>
<td></td>
</tr>
</tbody></table>
<h3 id="에노테이션-용도"><a href="#에노테이션-용도" class="headerlink" title="에노테이션 용도"></a>에노테이션 용도</h3><ul>
<li><p>컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공한다.</p>
<ul>
<li>Ex) @Override - 메소드가 재정의 되었는지 확인할 수 있다.<br>(코드를 작성하고 이 코드가 제대로 작성이 되었는지 컴파일러에게 체크할 수 있도록 정보를 제공한다., 뭔가를 지시하는 용도로 사용)</li>
</ul>
</li>
<li><p>소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보를 제공</p>
<ul>
<li>프로그램을 개발하고나서 압축을 할 때가 있는 jar, war상태로 압축할 수 잇는데 어떤 파일명<br> 확장명으로 압축을 해라라고 개발툴에게 지시를 할 때 어노테이션을 통해 할수 있다</li>
<li>Ex) XML 설정 파일을 자동 생성하거나 배포를 위한 JAR 압축 파일을 자동 생성할 수 있다.</li>
</ul>
</li>
<li><p>실행시(런타임시) 특정 기능을 실행하도록 정보를 제공한다.</p>
<ul>
<li>객체를 만들었을 때 다른객체와 달리 특별한 역할을 해야할 경우 그객체에게 어노테이션을 기술해주면<br>어노테이션에 기술되어있는 데이터를 보고 특별한 역할을 할 수 있다.</li>
<li>Ex) 객체가 애플리케이션 내부에서 해야할 역할을 정의할 수 있다(서블릿, 컨트롤러…)</li>
</ul>
</li>
</ul>
<h2 id="애노테이션-타입-정의와-적용"><a href="#애노테이션-타입-정의와-적용" class="headerlink" title="애노테이션 타입 정의와 적용"></a>애노테이션 타입 정의와 적용</h2><ul>
<li><p>애노테이션 타입 정의</p>
<ul>
<li>소스 파일 생성 : AnnotationName.java</li>
<li>소스 파일 내용<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>애노테이션의 작성</p>
<ul>
<li>추상 메소드와 유사한 형태로 구현<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span> <span class="comment">// 메타 애노테이션</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span>                                     <span class="comment">// 메타 애노테이션</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;                                   <span class="comment">// 애노테이션 선언</span></span><br><span class="line">    String [] value();                                                 <span class="comment">// 애노테이션 속성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>애노테이션 타입 적용</p>
<ul>
<li><code>@AnnotationName</code><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> toString()&#123; .. &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>애노테이션의 사용</p>
<ul>
<li>key = value 형태로 애노테이션에 속성의 값 전달<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(value = &#123;&quot;unused&quot;, &quot;rawtypes&quot;&#125;)</span> <span class="comment">// 키 = 값 배열</span></span><br><span class="line"><span class="meta">@SuppressWarnings(value = &quot;unused&quot;)</span>               <span class="comment">// 값이 하나인 경우 배열 생략 가능</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;rawtypes&quot;&#125;)</span>         <span class="comment">// 속성이 value 하나인 경우 키 생략 가능</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation(key1 = &quot;value1&quot;, key2 = &#123;&quot;value2&quot;, &quot;value3&quot;&#125;)</span> <span class="comment">// 속성이 여러개인 경우 키를 여러개 사용</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>애노테이션의 엘리먼트 멤버</p>
<ul>
<li>어노테이션을 코드에 적용할 때 외부의 값(개발자가 입력한 값)을 입력받을 수 있도록 하는 역할</li>
<li>엘리먼트 선언<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">  타입 elementName() [defalut 값(기본값, 생략가능)]; <span class="comment">// 엘리먼트 선언</span></span><br><span class="line">   ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>엘리먼트의 타입은 기본타입과 참조 타입 모두 사용할 수 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">  String elementName1();</span><br><span class="line">  <span class="keyword">int</span> elementName2() <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>어노테이션 적용시 엘리먼트 값을 지정하는 방법<br> @AnnotationName(element=”값”, elementName2 = 3);</p>
</li>
</ul>
<h2 id="기본-엘리먼트-value"><a href="#기본-엘리먼트-value" class="headerlink" title="기본 엘리먼트 value"></a>기본 엘리먼트 value</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">  String value()  <span class="comment">// 기본 엘리먼트 선언</span></span><br><span class="line">  <span class="keyword">int</span> elementName()  <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>애노테이션을 적용할 때 엘리먼트명을 생략가능</p>
<ul>
<li><code>@AnnotationName(&quot;값&quot;);</code> - 기본 엘리먼트인 value에 값이 들어간다<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">&quot;/main&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainServlet</span> &#123;</span> ... &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>두 개 이상의 속성을 기술할 때에는 value =값 형태로 기술해야 한다.</p>
<ul>
<li><code>@AnnotationName(value=&quot;값&quot;, elementName=3);</code></li>
</ul>
</li>
</ul>
<h2 id="애노테이션-적용-대상"><a href="#애노테이션-적용-대상" class="headerlink" title="애노테이션 적용 대상"></a>애노테이션 적용 대상</h2><ul>
<li>코드 상에서 애노테이션을 적용할 수 있는 대상</li>
<li>java.lang.annotation.ElementType. 열거 상수로 정의되어 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>ElementType 열거 상수</th>
<th>적용 대상</th>
</tr>
</thead>
<tbody><tr>
<td>TYPE</td>
<td>클래스, 인터페이스, 열거 타입</td>
</tr>
<tr>
<td>ANNOTATION_TYPE</td>
<td>어노테이션</td>
</tr>
<tr>
<td>FIELD</td>
<td>필드, 열거형 상수</td>
</tr>
<tr>
<td>CONSTRUCTOR</td>
<td>생성자</td>
</tr>
<tr>
<td>METHOD</td>
<td>메소드</td>
</tr>
<tr>
<td>PARAMETER</td>
<td>메소드의 입력 파라미터</td>
</tr>
<tr>
<td>LOCAL_VARIABLE</td>
<td>로컬 변수</td>
</tr>
<tr>
<td>PACKAGE</td>
<td>패키지</td>
</tr>
<tr>
<td>MODULE</td>
<td>모듈</td>
</tr>
</tbody></table>
<ul>
<li>애노테이션 적용 대상 지정 방법<ul>
<li>@Target 애노테이션으로 적용 대상 지정</li>
<li>@Target의 기본 엘리먼트인 value의 타입은 ElementType 배열<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FLELD, ElementTypeMETHOD&#125;) <span class="comment">// TYPE,FELED,METHOD에 적용할 수 있다라는 의미이다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AnnotationName</span> <span class="comment">// 클래스에 사용 가능</span></span><br><span class="line"><span class="keyword">public</span> className&#123;</span><br><span class="line">   <span class="meta">@AnnotationName</span> <span class="comment">// 필드에 사용 가능</span></span><br><span class="line">   <span class="keyword">private</span> String fieldName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AnnotationName</span> x  <span class="comment">// 생성자에는 사용 불가</span></span><br><span class="line">   <span class="keyword">public</span> className()&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AnnotationName</span> <span class="comment">// 메소드에는 사용 가능</span></span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">void</span> methodName()&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="어노테이션-유지-정책"><a href="#어노테이션-유지-정책" class="headerlink" title="어노테이션 유지 정책"></a>어노테이션 유지 정책</h2><ul>
<li><p>어노테이션 적용 코드가 유지되는 시점을 지정하는 것</p>
</li>
<li><p>java.lang.annotation.RetentionPolicy 열거 상수로 정의되어 있다.</p>
<table>
<thead>
<tr>
<th>RetentionPolicy 열거 상수</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>SOURCE</td>
<td>소스상에서만 어노테이션 정보를 유지한다. 소스코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다. 컴파일러가 컴파일 할 때 어노테이션을 바이트코드에서 뺀다,바이트코드에서는 어노테이션이 유지되지 않는 정책이다 개발자가 소스에서 정보를 얻을 목적으로 유지하는 정책</td>
</tr>
<tr>
<td>CLASS</td>
<td>바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다.클래스상에만 존재하고 실제로 실행할 때는 그정보를 읽지못하는 유지 정책.</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임에 어노테이션 정보를 얻을 수 있다. 클래스를 이용할 때 어떤 어노테이션이 적용되었나를 보고 클래스의 역할과 실행방법을 정해줄 수 있기 때문에 대부분 RUNTIME 유지정책을 사용한다</td>
</tr>
</tbody></table>
<ul>
<li>리플렉션(ReFlection) : 런타임에 클래스의 메타 정보를 얻는 기능<ul>
<li>(클래스의 메타정보)클래스가 가지고 있는 필드, 필드의 종류, 필드의 타입 생성자, 메소드, 어노테이션의 정보 등등을 얻을 수 있다.</li>
<li>런타임시에 어노테이션 정보를 얻으려면 유지 정책을 RUNTIME으로 설정해야 한다.</li>
</ul>
</li>
</ul>
</li>
<li><p>유지 정책 지정 방법</p>
<ul>
<li>@Retention 어노테이션으로 유지 정책을 지정</li>
<li>@Retention의 기본 엘리먼트인 value의 타입은 RetentionPolicy<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FLELD, ElementTypeMETHOD&#125;)</span> <span class="comment">// TYPE,FELED,METHOD에 적용할 수 있다라는 의미이다.</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 여기다가 위에 3가지중 하나를 넣어주면 됨. value = RetentionPolicy.RUNTIME과 같다</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="사용자-정의-애노테이션"><a href="#사용자-정의-애노테이션" class="headerlink" title="사용자 정의 애노테이션"></a>사용자 정의 애노테이션</h2><ul>
<li>멤버 변수를 대상으로 하는, Reflection API에서 쓸 수 있ㄴㄴ 애노테이션</li>
<li>애노테이션 속성은 String[]인 value와 “기본값” 기본값을 가지는 valueTwo로 이루어짐</li>
</ul>
<ul>
<li><p>사용자 정의 애노테이션 구현</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    String[] value(); <span class="comment">// 애노테이션 속성 (기본 속성 이름은 value) 첫번째 애노테이션 속성은 value로해주는 게 좋다.</span></span><br><span class="line">    <span class="function">String <span class="title">valueTwo</span><span class="params">()</span> <span class="keyword">default</span> &quot;기본값&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>사용자 정의 애노테이션 사용</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationUsage</span></span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;game&quot;)</span><span class="comment">// 바로밑에 한줄에 적용이된다. 게임네임에는 게임에 대한정보가들어가있다라는 의미이다.</span></span><br><span class="line">    String gameName = <span class="string">&quot;여러분의 틱택토&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//value가 String[]이므로 value = String[]로 넣어 준다.</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;server&quot;,valueTwo = &quot;localhost&quot;)</span> <span class="comment">// value는 원래 배열이다</span></span><br><span class="line">    String serverIP; <span class="comment">// 내용이 들어가도 상관없다. 여기에쓰던지 valueTwo에쓰던지하는 것</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//value가 String[]이지만, 길이가 1이면 String 만 넣어주어도 됨.</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;server&quot;,valueTwo = &quot;8080&quot;)</span></span><br><span class="line">    String serverPort;</span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;game&quot;)</span></span><br><span class="line">    String gameMode = <span class="string">&quot;AI VS. AI&quot;</span>;</span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;db&quot;,valueTwo = &quot;localhost&quot;)</span></span><br><span class="line">    String database;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reflection을 이용하여 애노테이션에 할당된 값 사용</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationUsage obj = <span class="keyword">new</span> AnnotationUsage();</span><br><span class="line">        Map&lt;String, Object&gt; gameProp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Object&gt; serverPrp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Object&gt; dbProp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Field[] fields =AnnotationUsage.class.getDeclaredFields(); // 필드 정보 가져오는 부분 (Reflection API를 사용하여 가져옴)</span><br><span class="line">        <span class="keyword">for</span> (Field filed : fields) &#123;</span><br><span class="line">            MyAnnotation annotation = filed.getDeclaredAnnotation(MyAnnotation.class); // 필드에서 Annotation 정보 가져오는 부분(Reflect API)</span><br><span class="line">            <span class="keyword">if</span>(filed.get(obj) == <span class="keyword">null</span>)&#123; <span class="comment">// 필드 값이 비어있는 경우 valueTwo에서 가져온다.</span></span><br><span class="line">                filed.set(obj, annotation.valueTwo()); <span class="comment">// 값이 없으면 valueTwo를 채워줌</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (annotation.value()[<span class="number">0</span>].equals(<span class="string">&quot;game&quot;</span>))&#123;</span><br><span class="line">                gameProp.put(filed.getName(),filed.get(obj));</span><br><span class="line">            &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (annotation.value()[<span class="number">0</span>].equals(<span class="string">&quot;server&quot;</span>))&#123;</span><br><span class="line">                serverPrp.put(filed.getName(),filed.get(obj));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dbProp.put(filed.getName(),filed.get(obj));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(gameProp);</span><br><span class="line">        System.out.println(serverPrp);</span><br><span class="line">        System.out.println(dbProp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/18/Java/JavaAdvanced/Java-Annotations/" data-id="ckgxjhqcj0017cwu216xgg8vu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-Stream_TerminalOperations" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/Java/JavaAdvanced/Java-Stream_TerminalOperations/" class="article-date">
  <time datetime="2020-10-10T07:45:14.651Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/10/Java/JavaAdvanced/Java-Stream_TerminalOperations/">Java_Stream-최종 처리 메소드(최종 연산자)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="최종-처리-메소드"><a href="#최종-처리-메소드" class="headerlink" title="최종 처리 메소드"></a>최종 처리 메소드</h1><table>
<thead>
<tr>
<th>동작</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>루핑</td>
<td>forEach()</td>
</tr>
<tr>
<td>매칭</td>
<td>allMatch(), anyMatch(), noneMatch()</td>
</tr>
<tr>
<td>집계</td>
<td>count(), max(), min(), average(), sum(), reduce()</td>
</tr>
<tr>
<td>조사</td>
<td>findFirst(), findAny()</td>
</tr>
<tr>
<td>수집</td>
<td>collect()</td>
</tr>
</tbody></table>
<h2 id="루핑"><a href="#루핑" class="headerlink" title="루핑"></a>루핑</h2><h3 id="forEach-메소드로-스트림-요소를-순차적으로-Consumer를-이용해-소비"><a href="#forEach-메소드로-스트림-요소를-순차적으로-Consumer를-이용해-소비" class="headerlink" title="forEach() 메소드로 스트림 요소를 순차적으로 Consumer를 이용해 소비"></a>forEach() 메소드로 스트림 요소를 순차적으로 Consumer<T>를 이용해 소비</h3><ul>
<li>forEach() - 요소들을 계속해서 반복해서 가져와라라는 의미이다.<ul>
<li><code>stream.forEach(name -&gt; System.out.println(name))</code>으로 되어있을 때<br>스트림에 가져온 요소를 name에 넣어서 하나씩 출력되게 하는 것이다.</li>
<li>매개값의 형태는 Consumer 함수형 인터페이스 타입을 갖는다.</li>
</ul>
</li>
<li><code>void forEach(Comsumer&lt;? super T&gt; action)</code> : 스트림의 각 요소를 action으로 소비  </li>
</ul>
<h2 id="매칭"><a href="#매칭" class="headerlink" title="매칭"></a>매칭</h2><h3 id="Predicate-계열을-이용해-스트림-요소들이-특정-조건에-만족하는지-조사하는-메소드"><a href="#Predicate-계열을-이용해-스트림-요소들이-특정-조건에-만족하는지-조사하는-메소드" class="headerlink" title="Predicate 계열을 이용해 스트림 요소들이 특정 조건에 만족하는지 조사하는 메소드"></a>Predicate 계열을 이용해 스트림 요소들이 특정 조건에 만족하는지 조사하는 메소드</h3><ul>
<li><p>boolean allMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 모든 요소가 Predicate를 만족하면 true를 반환</p>
</li>
<li><p>boolean anyMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 요소 중 하나라도 Predicate를 만족하면 true를 반환</p>
</li>
<li><p>boolean noneMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 요소 중 하나라도 Predicate를 만족하지 않으면 true를 반환</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.allMatch(s -&gt; s.equals(<span class="string">&quot;abc&quot;</span>))); <span class="comment">//false</span></span><br><span class="line">st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.anyMatch(s -&gt; s.equals(<span class="string">&quot;cde&quot;</span>))); <span class="comment">//true</span></span><br><span class="line">st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.noneMatch(s -&gt; s.equals(<span class="string">&quot;abcde&quot;</span>)));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="조사"><a href="#조사" class="headerlink" title="조사"></a>조사</h2><h3 id="첫번째-요소-또는-아무-요소를-조사하는-최종-처리-메소드-필터링-등으로-인해-스트림에-요소가-남아있는지-확인할-수-있다"><a href="#첫번째-요소-또는-아무-요소를-조사하는-최종-처리-메소드-필터링-등으로-인해-스트림에-요소가-남아있는지-확인할-수-있다" class="headerlink" title="첫번째 요소 또는 아무 요소를 조사하는 최종 처리 메소드. 필터링 등으로 인해 스트림에 요소가 남아있는지 확인할 수 있다."></a>첫번째 요소 또는 아무 요소를 조사하는 최종 처리 메소드. 필터링 등으로 인해 스트림에 요소가 남아있는지 확인할 수 있다.</h3></li>
<li><p><code>Optional&lt;T&gt; findFirst()</code> : 스트림의 첫 요소 또는 empty Optional 객체를 반환</p>
</li>
<li><p><code>Optional&lt;T&gt; findAny()</code> : 스트림의 아무 요소나 가지는 Optional 객체를 반환 (병렬 스트림일 때 사용한다.)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> firstValue = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line">                .filter(n -&gt; n%<span class="number">3</span> ==<span class="number">0</span>)</span><br><span class="line">                .findFirst()</span><br><span class="line">                .getAsInt();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="집계-통계"><a href="#집계-통계" class="headerlink" title="집계 (통계)"></a>집계 (통계)</h2><ul>
<li><p>최종 처리 기능</p>
<ul>
<li>카운팅, 합계, 평균값, 최대값, 최소값 등과 같이 하나의 값으로 산출한다.</li>
<li>대량의 데이터를 가공해서 축소하는 리덕션이라고 볼 수 있다.</li>
</ul>
</li>
<li><p>기본 집계 메소드</p>
<ul>
<li>기본형 스트림의 통계 : count(), sum(), average(), min(), max()</li>
<li>T 타입 스트림의 통계 : count(), min(), max() (min, max의 경우 Comparator 필요)</li>
</ul>
</li>
</ul>
<h3 id="reduce-메소드-사용자-정의-집계-메소드"><a href="#reduce-메소드-사용자-정의-집계-메소드" class="headerlink" title="reduce() 메소드 : 사용자 정의 집계 메소드"></a>reduce() 메소드 : 사용자 정의 집계 메소드</h3><ul>
<li>모든 자료형에서 사용할 수 있는 집계 메소드이다!</li>
<li>개발자가 프로그램화해서 다양한 집계(리덕션) 결과물을 만들 수 있다.</li>
<li>특정한 값을 집계 할 수 있게 하기 위해서 reduce를 제공한다.</li>
</ul>
<h4 id="세가지-인자를-받아서-처리"><a href="#세가지-인자를-받아서-처리" class="headerlink" title="세가지 인자를 받아서 처리"></a>세가지 인자를 받아서 처리</h4><ul>
<li>accmulator : 각 요소를 처리하는 계산 로직이다. 각 요소가 올 때마다 중간 결과를 생성한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator) </span><br><span class="line"><span class="comment">//accumulator를 수행하고 Optional&lt;T&gt; 타입 반환</span></span><br></pre></td></tr></table></figure></li>
<li>identity : 계산을 위한 초기값이다. stream이 비어서 계산할 값이 없더라도 이 값은 반한된다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator) </span><br><span class="line"><span class="comment">// identity를 초기값으로 하여, accumulator를 이용해 집계 연산</span></span><br></pre></td></tr></table></figure></li>
<li>combiner : 병럴 stream에서 나눠 계산한 결과를 하나로 합쳐 반환한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner) </span><br><span class="line"><span class="comment">// combiner를 이용해 병렬 스트림 결합</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="메소드-형태-및-사용코드"><a href="#메소드-형태-및-사용코드" class="headerlink" title="메소드 형태 및 사용코드"></a>메소드 형태 및 사용코드</h4><table>
<thead>
<tr>
<th>인터페이스</th>
<th>리턴 타입</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Stream</td>
<td>Optional<T></td>
<td>reduce(BinaryOperator<T> accumulator</td>
</tr>
<tr>
<td></td>
<td>T</td>
<td>reduce(T identitiy, BianryOperator<T> accmulator)</td>
</tr>
<tr>
<td>IntStream</td>
<td>OptionalInt</td>
<td>reduce(IntBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>reduce(int indentity, IntBinaryOperator  op)</td>
</tr>
<tr>
<td>LongStream</td>
<td>OptionalLong</td>
<td>reduce(LongBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>reduce(long indentity, LongBinaryOperator  op)</td>
</tr>
<tr>
<td>DoubleStream</td>
<td>OptionalDouble</td>
<td>reduce(DoubleBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>reduce(double indentitiy, DoubleBinaryOperator  op)</td>
</tr>
</tbody></table>
<ul>
<li><p>reduce(BinaryOperator<T> accumulator)</p>
<ul>
<li>이건 연산의 결과가 없으면 예외가 발생한다. NotSuchElementException 요소가 있어야 동작한다.</li>
</ul>
</li>
<li><p>reduce(T identitiy, BianryOperator<T> accmulator) </p>
<ul>
<li>연산의 결과가 없다면, 디폴트로 identity 사용  요소가 없어도 동작한다.</li>
<li>연산의 결과가 없는 것은 요소가 없는 것이다. 그래서 연산의 결과로 디폴트 값으로 identity를 하는 것이다.</li>
</ul>
</li>
<li><p>매개변수</p>
<ul>
<li>XXXBinaryOperator : 두 개의 매개 값을 받아 연산 후 리턴하는 함수적 인터페이스</li>
<li>identity : 스트림에 요소가 전혀 없을 경우 리턴될 디폴트 값   </li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(IntStream.range(<span class="number">0</span>,<span class="number">10</span>).reduce(<span class="number">0</span>,(value1,value2)-&gt;value1+value2)); <span class="comment">//sum()</span></span><br><span class="line"><span class="comment">// 1,2와 더한걸 3이랑 더하고 12 와 3을 더한걸 4 와 더함 .. 누적해서 더하는 것이다.</span></span><br><span class="line"><span class="comment">// identity가 사용이 되는 이유는 처음 identitiy와 1을 더한값과 2를계산하기위해서</span></span><br><span class="line"><span class="comment">// 0 [0,1,2,3,4,5,6,7,8,9] 0+0 =0 -&gt; 0+1-&gt;1 1+2-&gt; 3 과같은 연산 0~9까지 더한 연산</span></span><br><span class="line"><span class="comment">// sum()으로도 나타낼 수 있다 sum,min,max등등 도 reduce로 구현되어 있다</span></span><br><span class="line"></span><br><span class="line">System.out.println(IntStream.range(<span class="number">0</span>,<span class="number">10</span>).reduce(Integer.MAX_VALUE,(value1,value2)-&gt;value1&lt;value2? value1:value2));<span class="comment">// min()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Optional-클래스"><a href="#Optional-클래스" class="headerlink" title="Optional 클래스"></a>Optional<T> 클래스</h3><ul>
<li><p>T 타입 객체의 null 여부에 따라 다르게 동작하는 Wrapper 클래스</p>
</li>
<li><p>자바 8부터 추가된 값을 저장하는 값 기반 클래스</p>
</li>
<li><p>java.util 패키지의 Optional, OptionalDouble, OptionalInt, OptionLong 클래스를 말한다.</p>
</li>
<li><p>집계 메소드의 리턴 타입으로 사용되어 집계 값을 가지고 있다. 이게 핵심이다!!</p>
</li>
<li><p>저장된 값을 얻으려면 get(), getAsDouble(), getAsInt(), getAsLong()를 호출한다. </p>
</li>
<li><p>Optional 클래스의 정적 메소드를 이용해 Optional 객체 생성</p>
<ul>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; of(T value)</code> : value가 null인 경우 NullPointerException을 발생시키는 Wrapping 메소드</li>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code> : value가 null인 경우 empty()의 결과를 리턴하는 Wrapping 메소드</li>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; empty()</code> : 값이 비어있는 Optional 객체를 리턴</li>
</ul>
</li>
<li><p>Optional 객체를 처리하는 메소드</p>
<ul>
<li><code>public T get()</code> : Optional의 값을 리턴하며, null일 경우 NullPointerException 발생</li>
<li><code>public void ifPresent(Consumer&lt;? super T&gt; consumer)</code> : Optional 값이 null이 아닐 경우 consumer를 이용해 소비한다, 값이 저장되어 있지 않을 경우 디폴트 값(매개변수가 디폴트 값이 된다)<ul>
<li>consumer로 집계 값을 받아서 처리하는 코드를 람다식으로 작성한다</li>
</ul>
</li>
<li><code>public T orElse(T other)</code> : Optional의 값이 null일 경우 other를 반환한다, 값이 저장되어 있을 경우 Consumer 에서 처리</li>
<li><code>public T orElseGet(Supplier&lt;? extends T&gt; other)</code> : Optional의 값이 null일 경우 Supplier를 통해 공급받은 값을 반환한다.</li>
<li><code>public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</code> : Optional의 값이 null일 경우 exceptionSupplier에서 공급받은 예외를 throw</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">double</span> avg = list.stream()</span><br><span class="line">            .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">            .average()</span><br><span class="line">            .getAsDouble();</span><br><span class="line">    System.out.println(avg); <span class="comment">//NotSuchElementException</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// isPresent()</span></span><br><span class="line">    OptionalDouble optionalDouble = list.stream()</span><br><span class="line">            .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">            .average()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optionalDouble.isPresent())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;값이 있는 경우 : &quot;</span> + optionalDouble.getAsDouble());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;방법 1-값이 없는 경우 : &quot;</span> + <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// orElse()</span></span><br><span class="line">    <span class="keyword">double</span> avg = list.stream()</span><br><span class="line">            .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">            .average()</span><br><span class="line">            .orElse(<span class="number">0.0</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;방법 2 : &quot;</span> + avg);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ifPresent()</span></span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    list.stream()</span><br><span class="line">            .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">            .average()</span><br><span class="line">            .ifPresent(i-&gt; System.out.println(<span class="string">&quot;방법 3 : &quot;</span>+ i));</span><br><span class="line">    <span class="comment">// 값이 없을 경우 false가 되서 종료가 된다. consumer로 했기 때문에 바로 값 출력</span></span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">## 수집</span><br><span class="line">### 필요한 요소를 수집하여 새로운 Collection으로 구성하여 반환하는 메소드</span><br><span class="line">* 최종 처리 기능으로 요소들을 수집 또는 그룹핑한다.</span><br><span class="line">    * 필터링 또는 매핑된 요소들로 최종적으로 얻은요소들로 새로운 컬렉션 생성하는 것.</span><br><span class="line">    * 요소들을 그룹핑하고, 집계를 할 수 있다. </span><br><span class="line">* Stream API는  JCF-&gt; STREAM -&gt; 처리 -&gt; 결과</span><br><span class="line">* 결과가 출력일 수도 있고 값일 수도 있고, 다시 컬렉션으로 만들고 싶을 수 있다.</span><br><span class="line">* 요소가 여러개 있는 프레임워크 혹은 Arrays에서 스트림을 생성한 다음에 스트림에서 중간 처리를 쭉쭉한 다음에 마지막에 출력이나 값을 낼 수 있지만</span><br><span class="line"> 다음 중 <span class="number">3</span>가지중 하나의 조건은 꼭 선택해야 한다.</span><br><span class="line">  * 조건<span class="number">1.</span> foreach()를 사용하거나</span><br><span class="line">  * 조건<span class="number">2.</span> 특정한 값을 리턴을 받거나(reduce())</span><br><span class="line">  * 조건<span class="number">3.</span> count,min,max 스트림을 간추려서 통계를 낼 수 있는 값들을 가져오던지 다시 컬렉션으로 만들어 주던지 해야한다.</span><br><span class="line"></span><br><span class="line">### 보통 수집을 하기 위해서 필터링을 한다.</span><br><span class="line">* 스트림에서 필요한 요소만 필터링해서 별도의 컬렉션으로 만든다</span><br><span class="line">* collect라는 메소드 사용 collect(Collector &lt;T,A,R&gt; collector)</span><br><span class="line">* collect가  요소를 어떤 컬렉션에 수집할 것인지를 결정한다.</span><br><span class="line"></span><br><span class="line">* collect()메소드</span><br><span class="line">  * `&lt;R,A&gt; R collect(Collector&lt;? super T,A,R) collector)` : collector를 이용해 새로운 Collection R에 담아 반환</span><br><span class="line">     * Collectors의 `정적 메소드` : toList(), toSet(), toCollection(), toMap(), toConcurrentMap()</span><br><span class="line">     </span><br><span class="line">  * `&lt;R, A&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)` </span><br><span class="line">  : supplier를 통해 공급된 컨테이너 R에 accumulator를 이용해 T값을 저장. 병렬처리 스트림에 사용될 경우 combiner를 이용해 스레드별 컨테이너 R을 통합</span><br><span class="line"></span><br><span class="line">* Collector의 타입 파라미터</span><br><span class="line">   * <span class="attr">T :</span> 요소                                </span><br><span class="line">   * <span class="attr">A :</span> 누적기(accumulator) 요소를 컬렉션에 수집하는 역할을한다.</span><br><span class="line">   * <span class="attr">R :</span> 요소가 저장될 새로운 컬렉션 </span><br><span class="line">     * T 요소를 A 누적기가 R에 저장한다.</span><br><span class="line"></span><br><span class="line">| 리턴 타입 | 메소드 | 설명 |</span><br><span class="line">| ------- | ----- | ---- |</span><br><span class="line">| Collector&lt;T,?,Collection&lt;T&gt;&gt; | Collectors.toCollection&#123;Supplier&lt;T&gt;&#125; | Supplier가 제공한 Collection에 저장 |</span><br><span class="line">| Collector&lt;T,?,ConcurrentMap&lt;K,U&gt;&gt; |Collectors.toConcurrentMap(...) |ConcurrentMap에 저장한다. |</span><br><span class="line">| Collector&lt;T,?,List&lt;T&gt;&gt; |  Collectors.toList() | List에 저장 |</span><br><span class="line">| Collector&lt;T,?,Map&lt;K,U&gt;&gt; | Collectors.toMap() | Map에 저장 |</span><br><span class="line">| Collecotr&lt;T,?,Set&lt;T&gt;&gt; | Collectors.toSet() | Set에 저장 |</span><br><span class="line"></span><br><span class="line">* Collectors.toConcurrentMap(...) - 멀티쓰레드 환경에서 쓰레드의 안전한 concurrentmap을 만들어서 거기에 요소를 수집하는 Collector를 얻는다. </span><br><span class="line">* A가 ? 인 이유</span><br><span class="line">   * List, Set, Map 컬렉션에 누적할 경우 별도의 누적기가 필요 없다. </span><br><span class="line">   * 컬렉터내부에서 이들 컬렉션에 저장하는 방법을 알고 있기 때문에 별도의 누적기가 필요 없음.</span><br><span class="line"></span><br><span class="line">  ```groovy</span><br><span class="line">    String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line">    List&lt;String&gt; list = Arrays.stream(array)</span><br><span class="line">            .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">            .collect(Collectors.toList()); <span class="comment">// ArrayList</span></span><br><span class="line">            <span class="comment">// .collect(Collectors.toCollection(LinkedList::new))</span></span><br><span class="line">    System.out.println(list.getClass().getName() + <span class="string">&quot;:&quot;</span> + list);</span><br><span class="line">      </span><br><span class="line">    Set&lt;String&gt; set = Arrays.stream(array)</span><br><span class="line">            .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">            .collect(Collectors.toSet()); <span class="comment">// HashSet</span></span><br><span class="line">            <span class="comment">// .collect(Collectors.toCollection(HashSet::new))</span></span><br><span class="line">    System.out.println(set.getClass().getName() + <span class="string">&quot;:&quot;</span> + set);</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Integer&gt; map = Arrays.stream(array)</span><br><span class="line">            .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">            .collect(Collectors.toMap(s -&gt; s, String::length)); <span class="comment">// HashMap</span></span><br><span class="line">            <span class="comment">// .collect(Collectors.toCollection(s -&gt; s, String::length, (oldVal, newVal) -&gt; newVal, TreeMap::new))</span></span><br><span class="line">    System.out.println(map.getClass().getName() + map);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Collectors의 정적 메소드를 이용한 그룹화와 분리</p>
</li>
<li><p>partitioningBy는 어떤 기준으로 무더기로 나누는 것 (2가지 true or false)</p>
</li>
<li><p>groupingBy는 어떤 기준으로 여러개 묶어 내는 것  (여러개)</p>
<ul>
<li><dl><dt><code>public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code></dt><dd>classifier를 key값으로, 해당하는 값의 목록을 List인 value로 가지는 Map으로 스트림을 수집하는 Collector를 반환</dd></dl><ul>
<li><code>public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)</code> : List 대신 downstream collector로 수집</li>
<li>groupingBy(R Function<T>) - Map&lt;R, List<T>&gt;입력받은게 function으로 출력됨 R타입에 따라 그룹이 됨 그래서 R이 키가 된다.</li>
<li>T를 String..length 로 해주면 R은 Integer</li>
<li>결과 - 1: [………..], 2: [………..], 3: [………..]</li>
<li>키를 기준으로 그룹화 하는 것이다 다 대 다 형태 n:m이면 m이 조금 작을 것이다</li>
</ul>
</li>
<li><p><code>public static &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate)</code> : predicate 결과를 key로, 해당하는 값의 목록을 List value로 가지는 Map으로 스트림을 수집하는 Collector를 반환</p>
<ul>
<li><code>public static &lt;T, A, D&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream))</code> : List 대신 downstream collector로 수집</li>
<li>partitionBy(predciate)- Map&lt;Boolean, List<T>&gt; 왜냐하면 이건 두가지로 나누는 것이기 때문에 predicate 계열을 가지고 참인지 거짓인지 판단을 해야 해서</li>
<li>결과 - true :[……] , false: [……]  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> Map&lt;Character, List&lt;String&gt;&gt; map1 = Arrays.stream(array)</span><br><span class="line">         .collect(Collectors.groupingBy(s -&gt; s.charAt(<span class="number">0</span>)));</span><br><span class="line"> System.out.println(map1);</span><br><span class="line"> </span><br><span class="line"> Map&lt;Boolean, List&lt;String&gt;&gt; map2 = Arrays.stream(array)</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.length() &gt;= <span class="number">3</span>));</span><br><span class="line"> System.out.println(map2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>집계를 위한 Collector</p>
<ul>
<li>Downstream collector로 집계를 위한 Collector를 사용할 경우 유용하다.</li>
<li>counting(), summingP(), averagingP(), maxBy(), minBy(), reducing()</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  Map&lt;Character, Long&gt; map = Arrays.stream(array)</span><br><span class="line">          .collect(Collectors.groupingBy(s -&gt; s.charAt(<span class="number">0</span>),</span><br><span class="line">                                         Collectors.counting()));</span><br><span class="line">  System.out.println(map);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/10/Java/JavaAdvanced/Java-Stream_TerminalOperations/" data-id="ckgxjhqd0001rcwu2fzzfgewk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-Stream_IntermediateOperations" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/Java/JavaAdvanced/Java-Stream_IntermediateOperations/" class="article-date">
  <time datetime="2020-10-10T07:25:15.662Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/10/Java/JavaAdvanced/Java-Stream_IntermediateOperations/">Java_Stream-중간 처리 메소드(중간 연산자)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="중간-처리-메소드-중간-연산자"><a href="#중간-처리-메소드-중간-연산자" class="headerlink" title="중간 처리 메소드(중간 연산자)"></a>중간 처리 메소드(중간 연산자)</h1><ul>
<li>중간 처리 메소드 이후에 최종 처리 메소드를 붙여서 사용한다.</li>
<li>값을 원하는 형태로 처리하기 위한 연산자이다. 중간 연산자들은 lazy하게 실행되고 결과로 stream을 반환한다.<ul>
<li>lazy한 처리는 최종처리메소드가 실행되기전까지 연산이 실행되지 않음,결과가 필요하기 전까지 실행되지 않는다, 연산의 시점을 최대한 늦춘다는 의미이다.</li>
</ul>
</li>
<li>그렇기 때문에 중간연산자는 연쇄적으로 연결하여 연산을 처리할 수 있다. (Ex - list.stream().filter(…).map(…))</li>
</ul>
<table>
<thead>
<tr>
<th>동작</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>필터링</td>
<td>dinstict(), filter()</td>
</tr>
<tr>
<td>자르기</td>
<td>skip(), limit()</td>
</tr>
<tr>
<td>정렬</td>
<td>sorted()</td>
</tr>
<tr>
<td>매핑</td>
<td>flatMap(), flatMapToP(), map(), mapToP(), asDoubleStream(), asLongStream()</td>
</tr>
<tr>
<td>조회</td>
<td>peek()</td>
</tr>
</tbody></table>
<h2 id="필터링"><a href="#필터링" class="headerlink" title="필터링"></a>필터링</h2><h3 id="필터링은-스트림의-일부-요소를-제거하는-역할을-한다"><a href="#필터링은-스트림의-일부-요소를-제거하는-역할을-한다" class="headerlink" title="필터링은 스트림의 일부 요소를 제거하는 역할을 한다."></a>필터링은 스트림의 일부 요소를 제거하는 역할을 한다.</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Is&quot;</span>,<span class="string">&quot;Fun&quot;</span>,<span class="string">&quot;Isn&#x27;t&quot;</span>,<span class="string">&quot;It&quot;</span>,<span class="string">&quot;?&quot;</span>,<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stringStream.forEach(System.<span class="attr">out:</span>:println); <span class="comment">// 기본형 중복이 포함되서 출력됨.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>distinct() : 스트림에 같은 요소가 있을 경우 하나만 남기고 삭제하는 메소드(중복 제거)<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringStream.distinct().forEach(System.<span class="attr">out:</span>:println);</span><br><span class="line"><span class="comment">// stringStream.distinct() 여기까지 중간처리메소드, foreach는 최종처리 메소드</span></span><br><span class="line">```        </span><br><span class="line">* filter() : Predicate 계열을 입력을 받아, <span class="literal">true</span>인 요소만 남긴다.</span><br><span class="line">```groovy</span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Is&quot;</span>,<span class="string">&quot;Fun&quot;</span>,<span class="string">&quot;Isn&#x27;t&quot;</span>,<span class="string">&quot;It&quot;</span>,<span class="string">&quot;?&quot;</span>);</span><br><span class="line">stringStream.filter(s-&gt;s.length()&gt;=<span class="number">3</span>).forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="자르기"><a href="#자르기" class="headerlink" title="자르기"></a>자르기</h2><h3 id="자르기는-스트림의-일부-요소를-한번에-생략한다"><a href="#자르기는-스트림의-일부-요소를-한번에-생략한다" class="headerlink" title="자르기는 스트림의 일부 요소를 한번에 생략한다."></a>자르기는 스트림의 일부 요소를 한번에 생략한다.</h3><ul>
<li><p>skip(long n) : 스트림의 처음부터 n개의 요소를 생략하는 메소드, n개 자른다. n+1부터 끝까지 반환</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().skip(<span class="number">5</span>).forEach(n-&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
</li>
<li><p>limit(long maxsize) : 스트림의 최대 요소 개수를 maxsize를 제한한다, maxsize의 요소보다 뒤에 있는 값들은 짤린다. 0부터 n개까지 반환</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().limit(<span class="number">5</span>).forEach(n-&gt; System.out.println(s));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="정렬"><a href="#정렬" class="headerlink" title="정렬"></a>정렬</h2><h3 id="스트림-요소의-compareTo-또는-입력받은-Comparator를-이용해-정렬한다"><a href="#스트림-요소의-compareTo-또는-입력받은-Comparator를-이용해-정렬한다" class="headerlink" title="스트림 요소의 compareTo() 또는 입력받은 Comparator를 이용해 정렬한다."></a>스트림 요소의 <code>compareTo()</code> 또는 입력받은 <code>Comparator</code>를 이용해 정렬한다.</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparable 객체를 정렬한 스트림 반환</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line">stringStream.sorted().forEach(System.<span class="attr">out:</span>:println); <span class="comment">// 사전순으로 정렬됨</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator 인터페이스를 람다식으로 구현하여 정렬한다.</span></span><br><span class="line"><span class="comment">// Comparator를 이용하여 정렬된 스트림 반환</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line">stringStream.sorted((o1, o2) -&gt; o1.length() - o2.length()).forEach(System.<span class="attr">out:</span>:println); </span><br><span class="line"><span class="comment">//compreator를 람다식으로 작성해줄 수 있다, 길이가 짧은 것부터 나온다.</span></span><br></pre></td></tr></table></figure>

<h2 id="매핑"><a href="#매핑" class="headerlink" title="매핑"></a>매핑</h2><h3 id="Function-인터페이스를-이용해-요소의-값을-변환한다"><a href="#Function-인터페이스를-이용해-요소의-값을-변환한다" class="headerlink" title="Function 인터페이스를 이용해 요소의 값을 변환한다."></a>Function 인터페이스를 이용해 요소의 값을 변환한다.</h3><ul>
<li>map 계열 - 입력 1 : 1 출력<ul>
<li><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code> : 기존 스트림의 T 타입 요소를 R 타입으로 변환하여 새로운 스트림 반환<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function 계열의 인터페이스를 사용하여 스트림의 각 요소를 매핑(Operator 계열도 사용)</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line"><span class="comment">// Function 계열로 string -&gt; integer 로 변환하는 매핑 Function&lt;String,Intger&gt;와 같은 형식을 람다식에 넣어준 것이다.</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = stringStream.map(s-&gt;s.length()) ;<span class="comment">//입력은 string 출력은 원하는대로 할수 있다</span></span><br><span class="line">stream2.forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure></li>
<li><code>PStream mapToP(ToPFunction&lt;? super T&gt; mapper)</code> : R(return)이 기본형 타입으로 제한된 map()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PStream (기본형 타입의 스트림)은 Operator 계열로 처리(자료형 반환x)</span></span><br><span class="line"><span class="comment">// 입출력 값이 똑같기 때문에</span></span><br><span class="line">IntStream intStream3 = IntStream.of(<span class="number">5</span>,<span class="number">2</span>,<span class="number">30</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">-34</span>);</span><br><span class="line">IntStream intStream4 = intStream3.map(value -&gt; value * <span class="number">10</span>); <span class="comment">// 형 변환이 되지 않고 입력이 출력이 된다.</span></span><br><span class="line">intStream4.forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>flatMap 계열 - 입력 1 : n 출력(스트림 형태로 출력한다.)(Function 계열만 사용)<ul>
<li><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code> : 스트림의 T 타입 요소가 n개의 R 타입 요소로 매핑된 새로운 스트림을 반환</li>
<li><code>PStream flatMapToP(Function&lt;? super T, ? extends PStream&gt; mapper)</code> : R이 기본형 타입으로 제한된 flatMap()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s.split(&quot;&quot;) : &quot;java&quot; -&gt; &#123;&quot;j&quot;,&quot;a&quot;,&quot;v&quot;,&quot;a&quot;&#125;</span></span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;backend&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;course&quot;</span>);</span><br><span class="line">list2.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(s.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;).forEach(System.<span class="attr">out:</span>:println); <span class="comment">//foreach를 사용하면 스트림이 끝나게 된다.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="조회"><a href="#조회" class="headerlink" title="조회"></a>조회</h2><h3 id="스트림-처리-과정에-영향을-미치지-않으며-중간-결과를-확인할-수-있으며-입력받은-스트림과-동일한-스트림을-반환한다"><a href="#스트림-처리-과정에-영향을-미치지-않으며-중간-결과를-확인할-수-있으며-입력받은-스트림과-동일한-스트림을-반환한다" class="headerlink" title="스트림 처리 과정에 영향을 미치지 않으며, 중간 결과를 확인할 수 있으며 입력받은 스트림과 동일한 스트림을 반환한다."></a>스트림 처리 과정에 영향을 미치지 않으며, 중간 결과를 확인할 수 있으며 입력받은 스트림과 동일한 스트림을 반환한다.</h3><ul>
<li>Stream<T> peek(Consumer&lt;? super T&gt; action)<ul>
<li>peek() -&gt; Consumer 계열의 람다식 입력을 받아 입력 요소를 소비</li>
<li>peek()는 입력받아 스트림과 동일한 스트림을 다시 출력<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(list2.stream().flatMap(s -&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> Arrays.stream(s.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;).peek(s-&gt; System.out.println(<span class="string">&quot;flatMap():&quot;</span>+s))</span><br><span class="line">           .distinct().peek(s-&gt; System.out.println(<span class="string">&quot;distinct():&quot;</span>+s))</span><br><span class="line">           .count()); <span class="comment">// 함수형 프로그래밍은 선언형이어서 어떻게 해라라고 말해야한다.</span></span><br><span class="line"><span class="comment">// flatmap은 모든 요소를 다 나타내고 distinct는 중복된것을 없애고 하나만 출력됨.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/10/Java/JavaAdvanced/Java-Stream_IntermediateOperations/" data-id="ckgxjhqd1001scwu22gik9bzn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/31/Java/JavaAdvanced/Java-MultiThread/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/31/Java/JavaAdvanced/Java-RegularExpression/">Java_RegularExpression(정규표현식)</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-StockPrice/">AlgorithmSolution_StockPrice(주식가격)</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-NotFinishedPlayer/">AlgorithmSolution_완주하지 못한 선수</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-PhoneNumberList/">AlgorithmSolution_전화 번호 목록</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>