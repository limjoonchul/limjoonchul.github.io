<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java I&#x2F;OI&#x2F;O와 스트림 I&#x2F;O 입출력(Input&#x2F;Output)을 함께 부르는 것 자바의 I&#x2F;O는 스트림을 이용해 데이터를 주고 받는 형식으로 이루어졌다. 데이터의 소스와 목적지를 노드(Node)라고 부른다. 노드는 키보드(입력), 모니터(출력,터치스크린은 입력가능), 파일(입출력), 메모리에 적혀있는걸 읽는것(입출력둘다 해당), 데이터베이스(입출력)">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://limjoonchul.github.io/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java I&#x2F;OI&#x2F;O와 스트림 I&#x2F;O 입출력(Input&#x2F;Output)을 함께 부르는 것 자바의 I&#x2F;O는 스트림을 이용해 데이터를 주고 받는 형식으로 이루어졌다. 데이터의 소스와 목적지를 노드(Node)라고 부른다. 노드는 키보드(입력), 모니터(출력,터치스크린은 입력가능), 파일(입출력), 메모리에 적혀있는걸 읽는것(입출력둘다 해당), 데이터베이스(입출력)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://limjoonchul.github.io/2020/10/07/image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg">
<meta property="og:image" content="https://limjoonchul.github.io/2020/10/07/image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC2.jpg">
<meta property="og:image" content="https://limjoonchul.github.io/2020/10/07/image/%EB%B0%94%EC%9D%B4%ED%8A%B8%EB%AC%B8%EC%9E%90%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg">
<meta property="og:image" content="https://limjoonchul.github.io/2020/10/07/image/%EA%B8%B0%EB%B0%98%EB%B3%B4%EC%A1%B0%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg">
<meta property="og:image" content="https://limjoonchul.github.io/2020/10/07/image/%EC%8A%A4%EC%BA%90%EB%84%88%ED%81%B4%EB%9E%98%EC%8A%A4.jpg">
<meta property="og:image" content="https://limjoonchul.github.io/2020/10/07/image/%EC%BD%98%EC%86%94%ED%81%B4%EB%9E%98%EC%8A%A4.jpg">
<meta property="article:published_time" content="2020-10-07T11:31:56.495Z">
<meta property="article:modified_time" content="2020-10-13T04:08:34.116Z">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://limjoonchul.github.io/2020/10/07/image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java/JavaAdvanced/Java-JavaInputOutput" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/" class="article-date">
  <time datetime="2020-10-07T11:31:56.495Z" itemprop="datePublished">2020-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h1><h2 id="I-O와-스트림"><a href="#I-O와-스트림" class="headerlink" title="I/O와 스트림"></a>I/O와 스트림</h2><ul>
<li>I/O 입출력(Input/Output)을 함께 부르는 것</li>
<li>자바의 I/O는 스트림을 이용해 데이터를 주고 받는 형식으로 이루어졌다.<ul>
<li>데이터의 소스와 목적지를 노드(Node)라고 부른다.</li>
<li>노드는 키보드(입력), 모니터(출력,터치스크린은 입력가능), 파일(입출력), 메모리에 적혀있는걸 읽는것(입출력둘다 해당), 데이터베이스(입출력),다른 프로그램 등이 될 수 있다.</li>
</ul>
</li>
<li>장치하고는 상관없이 자바의 입출력을 추상화해놓은 스트림이다.</li>
<li>자바 응용프로그램과 입출력 자료사이에 데이터를 입출력하는 통로라고 생각하면 된다!!</li>
</ul>
<h2 id="입출력-스트림이란"><a href="#입출력-스트림이란" class="headerlink" title="입출력 스트림이란?"></a>입출력 스트림이란?</h2><ul>
<li>네트워크에서 자료의 흐름이 물과같다는 의미에서 유래되었다.</li>
<li>다양한 입출력 장치에 독립적으로 일관성있는 입출력 방식을 제공한다.</li>
<li>가상 경로가 있다고 가정하고 입출력이 이뤄진다.</li>
<li>입출력이 구현 되는 곳에서는 모두 I/O 스트림을 사용<ul>
<li>키보드, 파일 디스크, 메모리 등</li>
</ul>
</li>
</ul>
<p><img src="../../../image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="입출력스트림"></p>
<h2 id="입출력-스트림-구분"><a href="#입출력-스트림-구분" class="headerlink" title="입출력 스트림 구분"></a>입출력 스트림 구분</h2><ul>
<li>I/O 대상 기준 : 입력 스트림, 출력 스트림</li>
<li>자료의 종류 : 바이트 스트림, 문자 스트림<ul>
<li>동영상이나 음악파일은 한 바이트씩 쓰인다.</li>
<li>문자, 한글 파일등은 멀티 파이트로 쓰인다.</li>
</ul>
</li>
<li>스트림의 기능 : 기반 스트림(메인 스트림), 보조 스트림</li>
</ul>
<h3 id="기반-스트림-메인스트림-과-보조스트림"><a href="#기반-스트림-메인스트림-과-보조스트림" class="headerlink" title="기반 스트림(메인스트림)과 보조스트림"></a>기반 스트림(메인스트림)과 보조스트림</h3><ul>
<li><p>자바의 I/O는 디자인 패턴 중에 데코레이터 패턴으로 구현되어 있는데 보조스트림은 읽거나 쓰는 기능은 없다.</p>
</li>
<li><p>데코레이터 패턴에서 원래 컴포넌트가 가지는 기능 읽거나 쓰는 기능은 기반 스트림에서 가지고 있고,<br>보조스트림은 기반스트림을 보조하는 기능을 추가하는 것이다.</p>
<ul>
<li>자바 I/O는 데코레이터 패턴 기반이다.</li>
<li>원래 어떤 클래스 기능이 확장되면 상속을 쓰는 경우가 있는데,<br>데코레이터 패턴은 더 유연하게 기능을 확장할 수 있는 그런 디자인 패턴이다.</li>
</ul>
</li>
<li><p>바이트를 문자로 바꿔준다던가 버퍼링기능을 제공한다던가 직렬화 같은 것들이 보조 스트림에서 제공이 된다.</p>
</li>
<li><p>하나의 스트림은 입력이나 출력이냐, 바이트냐 문자냐, 기반이냐 보조냐로 구분해서 보면 스트림을 이해하는데 도움이 된다.</p>
</li>
</ul>
<h3 id="입출력-스트림과-출력-스트림"><a href="#입출력-스트림과-출력-스트림" class="headerlink" title="입출력 스트림과 출력 스트림"></a>입출력 스트림과 출력 스트림</h3><ul>
<li>입력 스트림 : 대상으로부터 자료를 읽어 들이는 스트림</li>
<li>출력 스트림 : 대상으로 자료를 출력하는 스트림</li>
</ul>
<p><img src="../../../image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC2.jpg" alt="입출력스트림"></p>
<h4 id="입출력-스트림과-출력-스트림의-종류"><a href="#입출력-스트림과-출력-스트림의-종류" class="headerlink" title="입출력 스트림과 출력 스트림의 종류"></a>입출력 스트림과 출력 스트림의 종류</h4><ul>
<li>입력 스트림 : FileInputStream, FileReader, BufferedInputStream, BufferedReader 등</li>
<li>출력 스트림 : FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등<ul>
<li>끝에 Stream이 붙은 것은 Byte 단위로 처리하고, Reader/writer는 문자 단위로 처리한다.</li>
<li>Buffered는 버퍼링을 제공하는 보조스트림이다.</li>
</ul>
</li>
</ul>
<h3 id="바이트-단위-스트림과-문자-스트림"><a href="#바이트-단위-스트림과-문자-스트림" class="headerlink" title="바이트 단위 스트림과 문자 스트림"></a>바이트 단위 스트림과 문자 스트림</h3><ul>
<li>바이트 단위 스트림 :  바이트 단위로 자료를 읽고 쓴다(동영상, 음악파일등)</li>
<li>문자 단위 스트림 : 문자는 2바이트씩 처리해야한다!!(char형 나왔을 때 2바이트라는거 생각해!!)</li>
</ul>
<p><img src="../../../image/%EB%B0%94%EC%9D%B4%ED%8A%B8%EB%AC%B8%EC%9E%90%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="바이트문자스트림"></p>
<h4 id="바이트-단위-스트림과-문자-스트림의-종류"><a href="#바이트-단위-스트림과-문자-스트림의-종류" class="headerlink" title="바이트 단위 스트림과 문자 스트림의 종류"></a>바이트 단위 스트림과 문자 스트림의 종류</h4><ul>
<li>바이트 스트림 : FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream 등</li>
<li>문자 스트림 : FileReader, FileWriter, BufferedReader, BufferedWriter 등</li>
</ul>
<h2 id="기반-스트림과-보조-스트림"><a href="#기반-스트림과-보조-스트림" class="headerlink" title="기반 스트림과 보조 스트림"></a>기반 스트림과 보조 스트림</h2><ul>
<li>기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림</li>
<li>보조 스트림 : 직접 읽고 쓰는 기능은 없고 추가적인 기능을 제공해 주는 스트림<br>기반 스트림이나 또 다른 보조 스트림을 생성자의 매개변수로 포함시킨다.</li>
</ul>
<p><img src="../../../image/%EA%B8%B0%EB%B0%98%EB%B3%B4%EC%A1%B0%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="기반보조스트림"></p>
<h3 id="기반-스트림과-보조-스트림의-종류"><a href="#기반-스트림과-보조-스트림의-종류" class="headerlink" title="기반 스트림과 보조 스트림의 종류"></a>기반 스트림과 보조 스트림의 종류</h3><ul>
<li>기반 스트림 : FileInputStream, FileOutputStream, FileReader, FileWriter 등</li>
<li>보조 스트림 : InputStreamReader, OutputStreamReader, BufferedInputStream, BufferedOutputStream 등</li>
</ul>
<h2 id="표준-입출력"><a href="#표준-입출력" class="headerlink" title="표준 입출력"></a>표준 입출력</h2><h3 id="Sytem-in"><a href="#Sytem-in" class="headerlink" title="Sytem.in"></a>Sytem.in</h3><ul>
<li>한바이트 씩 읽어 들인다.</li>
<li>한글과 같은 여러 바이트로 된 문자를 읽기 위해서는 InputStreamReader 와 같은 보조 스트림을 사용해야 한다.</li>
</ul>
<h3 id="Scanner-클래스"><a href="#Scanner-클래스" class="headerlink" title="Scanner 클래스"></a>Scanner 클래스</h3><ul>
<li>java.util 패키지에 있는 입력 클래스</li>
<li>문자뿐 아니라 정수, 실수등 다양한 자료형을 읽을 수 있다.</li>
<li>생성자가 다양하여 여러 소스로부터 자료를 읽을 수 있다.</li>
</ul>
<p><img src="../../../image/%EC%8A%A4%EC%BA%90%EB%84%88%ED%81%B4%EB%9E%98%EC%8A%A4.jpg" alt="스캐너클래스"></p>
<h3 id="Console-클래스"><a href="#Console-클래스" class="headerlink" title="Console 클래스"></a>Console 클래스</h3><ul>
<li><p>System.in 을 사용하지 않고 콘솔에서 표준 입출력이 가능</p>
</li>
<li><p>Console 클래스의 메소드<br><img src="../../../image/%EC%BD%98%EC%86%94%ED%81%B4%EB%9E%98%EC%8A%A4.jpg" alt="콘솔클래스"></p>
</li>
</ul>
<h2 id="노드-스트림"><a href="#노드-스트림" class="headerlink" title="노드 스트림"></a>노드 스트림</h2><h3 id="InputStream과-Reader"><a href="#InputStream과-Reader" class="headerlink" title="InputStream과 Reader"></a>InputStream과 Reader</h3><ul>
<li>InputStream의 주요 메소드(byte 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>byte 하나를 읽어서 int로 반환. 읽을 값이 없으면 -1</td>
</tr>
<tr>
<td>int read(byte b[])</td>
<td>데이터를 읽어 b를 채우고, 읽은 바이트 수를 반환</td>
</tr>
<tr>
<td>int read(byte b[], int offset, int len)</td>
<td>최대 len개의 바이트를 읽어 b의 offset 위치부터 채운다.</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납</td>
</tr>
<tr>
<td>int available()</td>
<td>읽을 수 있는 데이터의 크기를 반납</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>스트림에서 n만큼 건너 뛴다.</td>
</tr>
<tr>
<td>void mark(int readLimit)</td>
<td>reset()으로 돌아갈 위치를 표시한다. readLimit은 돌릴 수 있는 최대 바이트 수</td>
</tr>
<tr>
<td>void reset()</td>
<td>mark()가 호출된 지점으로 돌아간다.</td>
</tr>
<tr>
<td>boolean markSupported()</td>
<td>mark, reset 메소드의 지원 여부를 반환</td>
</tr>
</tbody></table>
<ul>
<li><p>기본 코드</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 여기서는 값을 계속 입력받게 무한루프에 빠지게 된다.(강제 종료를 시켜야한다.)</span></span><br><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123; <span class="comment">//autocloseable 자동으로 close 호출</span></span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span>((read = input.read()) != <span class="number">-1</span>) &#123; <span class="comment">//read는 1바이트를 읽어온다.</span></span><br><span class="line">     <span class="comment">//-1이나오면 더이상 읽을게 없다라고 의미하는 것이다.</span></span><br><span class="line">         System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>버퍼를 사용한 코드</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// byte[] bytes = new byte[2];</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">// 일단 read()안에 버퍼 bytes라고 매개값을 주게 되면, 이 버퍼의 길이만큼 배열안에 입력받은 값들이 담겨져</span></span><br><span class="line">    <span class="comment">// 그 값들의 개수를 반환 시킨다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 512의 크기를 준 것 처럼 한번에 담을 수 없는 큰 크기를 줬을 때 이것 또한 무한 루프에 빠지게 된다.</span></span><br><span class="line">    <span class="comment">// 근데 만약 2 같은 작은 크기를 줬을 때는 2개씩 짤려서 반환시켜서 read에 넣어주다가 마지막에 1개인 값만 남게 되면 반복문이 종료됨</span></span><br><span class="line">    <span class="comment">// 예로 abcd를 입력하고 엔터를치면 ab 두개를 짤라서 read넣으면 2 != 1이니깐 반복문을 한번더 돌고 cd도 2!=1이니깐</span></span><br><span class="line">    <span class="comment">// 한번더 도는데 엔터도 \n라고 값이 있는 것이기 때문에 1개의 값이 되서 종료된다.</span></span><br><span class="line">    <span class="comment">// 그래서 이렇게 작은 버퍼를 주게 되었을 때는 밑에 while문 안에 조건문을 주는 것이 의미가 없게 된다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// input.read(bytes)를 하게 되면 bytes의 크기만큼의 데이터를 읽어서 길이를 반환해주고, bytes안에 입력된 값들이 저장된다.</span></span><br><span class="line">    <span class="keyword">while</span>((read = input.read(bytes)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)bytes[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">// 버퍼를 사용할 때는 입력 받은 글자의 길이를 반환해주는 것이기 때문에</span></span><br><span class="line">    <span class="comment">// 버퍼를 사용할 경우에 어떠한 글자들을 입력해도 계속해서 입력 받을 수 있다.(0과 같지 않을 때라고 조건을 해놨기 때문에)</span></span><br><span class="line">    <span class="keyword">while</span>((read = input.read(bytes)) != <span class="number">0</span>) &#123;  <span class="comment">// 읽은 개수가 0이면 읽을게 없다라는 의미이다</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)bytes[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Stream의 mark/reset 기능</p>
<ul>
<li><p>mark - 스트림이 있고 내용이 차있을 때 하나씩 가져오는게 스트림의 read인데 마크를 호출하게 되면 해당 인덱스에 마킹이 된다<br>그다음 쭉쭉 진행이되다가 reset을하면 마크를 해놓은 부분을 기억해놨다가 마킹되어있는 부분으로 돌아가게 되는 기능이다.</p>
</li>
<li><p>System.out.println(System.in.markSupported()); // mark/reset 가능?하다는 의미 true/fase로 출력</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123; <span class="comment">//autocloseable 자동으로 close 호출</span></span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>((read = input.read()) != <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)read == <span class="string">&#x27;m&#x27;</span>)&#123; <span class="comment">// m은 포함되지 않는다. 다음부터 마크가 된다.</span></span><br><span class="line">            input.mark(<span class="number">32</span>); <span class="comment">//몇개까지 기억을 할것이냐 32개를 기억함.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>)read == <span class="string">&#x27;r&#x27;</span>)&#123; <span class="comment">// r이 입력이 되면 reset이 호출된다.</span></span><br><span class="line">            input.reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Reader의 주요 메소드 (char 단위)<ul>
<li>stream과 유사하나, Reader는 char 단위로 읽어서 int로 반환</li>
<li>stream을 이용해서 Reader를 초기화할 수 있다.</li>
<li>char 단위로 동작하기때문에 한글도 깨지지 않고 잘 동작한다.</li>
<li>byte단위로 하면 한글은 읽어서 조합을 해줘야 한다.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>char 하나를 읽어서 int로 반환. 읽을 값이 없으면 -1</td>
</tr>
<tr>
<td>int read(char cbuf[])</td>
<td>데이터를 읽어 cbuf를 채우고, 읽은 char 수를 반환</td>
</tr>
<tr>
<td>int read(char cbuf[], int off, int len)</td>
<td>최대 len개의 char를 읽어 cbuf의 offset 위치부터 채운다.</td>
</tr>
<tr>
<td>int read(java.nio.CharBuffer target)</td>
<td>NIO target에 데이터를 저장한다.</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납</td>
</tr>
<tr>
<td>int available()</td>
<td>읽을 수 있는 데이터의 크기를 반납</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>스트림에서 n만큼 건너 뛴다.</td>
</tr>
<tr>
<td>void mark(int readAheadLimit)</td>
<td>reset()으로 돌아갈 위치를 표시한다. readLimit은 돌릴 수 있는 최대 바이트 수</td>
</tr>
<tr>
<td>void reset()</td>
<td>mark()가 호출된 지점으로 돌아간다.</td>
</tr>
<tr>
<td>boolean markSupported()</td>
<td>mark, reset 메소드의 지원 여부를 반환</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>))&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>((read = reader.read()) != <span class="number">1</span>) &#123;  </span><br><span class="line">          System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>))&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charbuffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>((read = reader.read(charbuffer)) != <span class="number">-1</span>) &#123;  </span><br><span class="line">        System.out.println(Arrays.toString(charbuffer));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OutputStream과-Writer"><a href="#OutputStream과-Writer" class="headerlink" title="OutputStream과 Writer"></a>OutputStream과 Writer</h3><ul>
<li>OutputStream의 주요 메소드(byte 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>b 내용을 byte로 출력</td>
</tr>
<tr>
<td>void write(byte b[])</td>
<td>b를 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(byte b[], int off, int len)</td>
<td>b의 off부터 (off + len - 1)만큼을 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납. close() 내부적으로 flush() 호출</td>
</tr>
<tr>
<td>void flush()</td>
<td>버퍼 스트림에서 버퍼의 내용을 출력하고 비운다.</td>
</tr>
</tbody></table>
<ul>
<li>Writer의 주요 메소드 (char 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>c 내용을 char로 출력</td>
</tr>
<tr>
<td>void write(char cbuf[])</td>
<td>cbuf를 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(char cbuf[], int off, int len)</td>
<td>cbuf의 off부터 (off + len - 1)만큼을 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>str을 출력한다.</td>
</tr>
<tr>
<td>void write(String str, int off, int len)</td>
<td>str의 off부터 (off + len - 1)만큼을 출력</td>
</tr>
<tr>
<td>Writer append(CharSequence csq)</td>
<td>csq를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>Writer append(CharSequence csq, int start, int end)</td>
<td>csq의 start부터 end까지를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>Writer append(char c)</td>
<td>c를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납. close() 내부적으로 flush() 호출</td>
</tr>
<tr>
<td>void flush()</td>
<td>버퍼 스트림에서 버퍼의 내용을 출력하고 비운다.</td>
</tr>
</tbody></table>
<h3 id="다양한-입출력-처리"><a href="#다양한-입출력-처리" class="headerlink" title="다양한 입출력 처리"></a>다양한 입출력 처리</h3><ul>
<li><p>메모리 기반의 입/출력</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> [] memory = <span class="string">&quot;메모리 입출력 테스트 입력&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">char</span> [] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]; <span class="comment">//버퍼는 단순해야 단순하지 않으면 오히려 속도가 떨어진다.</span></span><br><span class="line"><span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 리소스를 두개 사용하는 방법 ;을 사용하여 나누면됨</span></span><br><span class="line"><span class="keyword">try</span> (CharArrayReader reader = <span class="keyword">new</span> CharArrayReader(memory);</span><br><span class="line">     CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter())&#123;</span><br><span class="line">     <span class="keyword">while</span> ((read = reader.read(cbuf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//writer.write(cbuf, 0,read); // (buffer, offset, len)</span></span><br><span class="line">          <span class="comment">// read 길이만큼 들어있는데 이때 몇개를 스킵할 수 있다 그때 사용하는게 offset</span></span><br><span class="line">          <span class="comment">// 1를 첫번째거빼고 2번째거 부터 하게된다는 의미이다. 0은 스킵없이 처음부터 한다는 것이고</span></span><br><span class="line">          <span class="comment">// len은 몇개까지 한다는 것  개수를 정해줘야 한다.</span></span><br><span class="line">          writer.write(cbuf); <span class="comment">//개수를 지정해주지 않으면 메모리에 남아있는게 마지막 문자뒤에 전에 문자가 붙어서 출력됨</span></span><br><span class="line">          <span class="comment">// 여기서는 [메,모,리, ,입,출,력, ,테,스,트, ,입, 력, 트, ] 이런식으로 출력이 된다.</span></span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(Arrays.toString(writer.toCharArray()));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>파일 기반의 입출력</p>
<ul>
<li><p>생성자 및 생성/삭제 메소드</p>
<table>
<thead>
<tr>
<th>생성자 및 메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>pathname에 해당하는 파일 생성. 기본 경로는 애플리케이션의 시작 경로</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>parent 경로 아래 child 파일 생성</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td>parent 경로 아래 child 파일 생성</td>
</tr>
<tr>
<td>File(URI uri)</td>
<td>file로 시작하는 URI 객체를 이용해 파일 생성</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>새로운 파일을 생성</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>새로운 디렉토리를 생성</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>경로상의 모든 디렉토리를 생성</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>파일/디렉토리 삭제</td>
</tr>
<tr>
<td>void deleteOnExit()</td>
<td>애플리케이션 종료시 자동으로 삭제</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String filePath = <span class="string">&quot;D:&quot;</span> + File.separator + <span class="string">&quot;Temp&quot;</span> + File.separator + <span class="string">&quot;MyTemp&quot;</span>;</span><br><span class="line"></span><br><span class="line">File fileOne = <span class="keyword">new</span> File(filePath);</span><br><span class="line">fileOne.mkdir(); <span class="comment">// 가장 하위 폴더만 생성 상위폴더가 없으면 실패</span></span><br><span class="line">fileOne.mkdirs(); <span class="comment">// 경로에 있는 모든 폴더를 생성한다.</span></span><br><span class="line">File fileTwo = <span class="keyword">new</span> File(filePath, <span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line">fileTwo.createNewFile(); <span class="comment">//성공 True 실패 false</span></span><br><span class="line"></span><br><span class="line">File fileThree = <span class="keyword">new</span> File(fileOne, <span class="string">&quot;file3.txt&quot;</span>);</span><br><span class="line">fileThree.createNewFile(); <span class="comment">// fileOne이 path이기 때문에 이것도 사용가능하다.</span></span><br><span class="line"></span><br><span class="line">File fileFour = <span class="keyword">new</span> File(<span class="keyword">new</span> URI(<span class="string">&quot;file:///d:/Temp/MyTemp/file4.txt&quot;</span>));</span><br><span class="line">fileFour.createNewFile();</span><br><span class="line">fileFour.deleteOnExit();</span><br><span class="line"><span class="comment">// Temp 파일을 사용할 때 유용하다, 4번파일을 생성했다가 프로그램이 종료될때 바로 삭제를 한다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>File 클래스의 주요 메소드</p>
<ul>
<li>getName(), getParent(), getParentFile(), getPath()</li>
<li>isAbsolute(), getAbsolutePath(), getCanonicalPath(), toURI()</li>
<li>canRead(), canWrite()</li>
<li>isDirectory(), isFile()</li>
<li>length(), list(), listFiles(), lastModified(), renameTo()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(fileTwo.getName()); <span class="comment">// 파일이름출력</span></span><br><span class="line">System.out.println(fileTwo.getParent()); <span class="comment">// parent에 해당하는 path 출력</span></span><br><span class="line">System.out.println(fileTwo.isAbsolute()); <span class="comment">// 절대 경로를 사용 하는지?</span></span><br><span class="line"><span class="comment">// 상대 경로는 프로그램을 실행하면 그위치에 파일을 만든다던지 그 내부에 만든다던지 할 수 있다</span></span><br><span class="line">    <span class="comment">// 파일을 실행하는 위치로부터 찾아가는 것</span></span><br><span class="line"><span class="comment">// 절대 경로 어디에서 찾아가도 똑같은 경로</span></span><br><span class="line">System.out.println(fileTwo.getAbsolutePath());</span><br><span class="line"><span class="comment">// 시작위치만 정해주고 그내부에서는 ..을 이용하던 다양한 방식으로 표현이가능하다.</span></span><br><span class="line"><span class="comment">// 절대경로라고 해서 우리가 알고있는 d:Temp/MyTemp 이런 형식의 깔끔한 경로가 반드시 나온다고 할 수 는 없다</span></span><br><span class="line"><span class="comment">// 절대 경로이지 표준형은 아닐 수 있다 그래서 깔끔한 경로만 표현해주는게 getCanonicalPath()</span></span><br><span class="line">System.out.println(fileTwo.getCanonicalPath()); <span class="comment">// 깔끔한 경로만 사용한다 , .. 등을 모두 배제한 표준 표현 법 사용</span></span><br><span class="line"><span class="comment">// 두개의 큰 차이는 없다.앱솔루트가 지저분해 질 수 있다 5:07</span></span><br><span class="line">System.out.println(fileOne.isDirectory()); <span class="comment">// 디렉토리를 가리키는지 윈도우즈 이전 도스에서 사용하던 표현 디렉토리</span></span><br><span class="line">System.out.println(fileTwo.isFile()); <span class="comment">// 파일을 가리키는지</span></span><br><span class="line">    </span><br><span class="line">System.out.println(Arrays.toString(fileOne.list())); <span class="comment">// 리스트를 이용해서 그안에 잇는 파일이름들을 다 출력함 String Array로 출력</span></span><br><span class="line"><span class="comment">// [files.txt,files2.txt...]</span></span><br><span class="line">System.out.println(Arrays.toString(fileOne.listFiles())); <span class="comment">// 파일의 경로까지 출력됨 File 객체로 출력이 나옴</span></span><br><span class="line"><span class="comment">// [D:/Temp/MyTemp/files.txt,D:/Temp/MyTemp/files2.txt ...]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>FileInputStream, FileOutputStream</p>
<ul>
<li>파일명이나 File 객체를 이용하여 입출력 스트림 생성 가능</li>
<li>FileOutputStream에서 boolean append를 true로 하면 기존 파일에 이어서 쓴다.</li>
</ul>
</li>
<li><p>FileReader, FileWriter</p>
<ul>
<li>파일명이나 File 객체를 이용하여 입출력 Reader 생성 가능</li>
<li>FileWriter에서 boolean append를 true로 하면 기존 파일에 이어서 쓴다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="보조-스트림"><a href="#보조-스트림" class="headerlink" title="보조 스트림"></a>보조 스트림</h2><h3 id="보조-스트림의-특징"><a href="#보조-스트림의-특징" class="headerlink" title="보조 스트림의 특징"></a>보조 스트림의 특징</h3><ul>
<li>스트림에 부가적인 기능 제공</li>
<li>노드(데이터 소스/목적지)와 직접 연결되지 않고, 다른 스트림과 연결</li>
<li>Stream Chaining : 스트림을 여러개 연결하여 사용</li>
</ul>
<h3 id="보조-스트림의-종류"><a href="#보조-스트림의-종류" class="headerlink" title="보조 스트림의 종류"></a>보조 스트림의 종류</h3><p>| 보조 스트림 | 기능 |<br>| InputStreamReader | byte 스트림을 char 스트림으로 변환 |<br>| OutputStreamWriter |    byte 스트림을 char 스트림으로 변환 |<br>| BufferedReader | 버퍼링을 통해 스트림 속도 향상 |<br>| BufferedWriter | 버퍼링을 통해 스트림 속도 향상 |<br>| BufferedInputStream |    버퍼링을 통해 스트림 속도 향상 |<br>| BufferedOutputStream | 버퍼링을 통해 스트림 속도 향상 |<br>| DataInputStream |    기본 데이터형 전송 |<br>| DataOutputStream | 기본 데이터형 전송 |<br>| ObjectInputStream | 객체 전송 |<br>| ObjectOuputStream | 객체 전송 |<br>| PrintWriter |    문자열 표현으로 출력 |<br>| PrintStream |    문자열 표현으로 출력 |</p>
<h3 id="스트림-자료형-변경"><a href="#스트림-자료형-변경" class="headerlink" title="스트림 자료형 변경"></a>스트림 자료형 변경</h3><ul>
<li>캐릭터셋: utf-8, ms949, euc-kr<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader readerOne = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>);</span><br><span class="line">InputStreamReader readerTwo = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">OutputStreamWriter writerOne = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line">OutputStreamWriter writerTwo = <span class="keyword">new</span> OutputStreamWriter(System.out, <span class="string">&quot;ms949&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="버퍼를-이용한-스트림"><a href="#버퍼를-이용한-스트림" class="headerlink" title="버퍼를 이용한 스트림"></a>버퍼를 이용한 스트림</h3><ul>
<li><p>기본 버퍼 크기: 8192 bytes</p>
</li>
<li><p>버퍼링을 사용하는 원리 </p>
<ul>
<li>입출력장치에 입력을받고출력을받고 해주면 기기를 사용하는데 있어서</li>
<li>한번 입력을 해주고 출력을해줄때 약간의 오버헤드가 발생한다.</li>
<li>키보드의 입력을 눌렀을 때 컴퓨터는 폴링방식을 이용하는데 계속해서 키보드에 있는 버퍼에 접근을 해서</li>
<li>우리가 가져올 데이터가 있는지 계속확인을 한다 매번하게될 경우 성능이 떨어진다 이게 평균전송속도측면에서 떨어지는 것이다.</li>
<li>대신 반응성은 빨라지게 된다. 두개 delay와 throughput은 tradeoff 관계에 있다,</li>
<li>우리가 동작이 빠르게 일어날 필요가 없다면 throughput을 향상시키는게 좋다</li>
<li>예로 파일의 입출력을 하게 될 경우 파일에 넣어서 작성을 할때 파일 즉 하드디스크에 계속 접근을 해서</li>
<li>쓰는 것보다 메모리에 일정량을 써놓고 한번에 하드디스크에 입력을 하는게 더 효율적이다</li>
<li>딜레이가 생겨도 througput이 더 좋은게 이득이여서 버퍼링을 사용하는게 더 이득이다.</li>
</ul>
</li>
<li><p>반응성이 중요한 경우 : 네트워크에서 게임을 한다했을 때 커멘드를 하나하입력할 때 반응성이 더 중요한 경우이다.</p>
</li>
<li><p>반응성이 중요하지 않은 경우(파일입출력, 네트워크 일부 경우(다운로드, 업로드…), 등등)</p>
</li>
<li><p>BufferedReader         ┬ 스트림에 버퍼링을 적용하여 스트림 throughput 형성</p>
</li>
<li><p>BuuferedWriter         ┤ throughput : 평균 전송 속도</p>
</li>
<li><p>BufferedInputStream    ┤ delay :반응성, 버퍼링을 쓸 경우 오히려 안좋아짐(딜레이시간이 길어지는 것이다) (네트워크에서 핑)</p>
</li>
<li><p>BuuferedOutputStream   ┘  서로 트레이드오프 관계에있다.</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> copyStream(InputStream input, OutputStream output) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">byte</span> [] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> ((read = input.read(buff) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    output.write(buff, <span class="number">0</span>, read);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">  File src = <span class="keyword">new</span> File(<span class="string">&quot;C:/Windows/explorer.exe&quot;</span>);</span><br><span class="line">  File dst = <span class="keyword">new</span> File(<span class="string">&quot;C:/temp/explorer.exe&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> (FileInputStream <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">       FileOutputStream out = <span class="keyword">new</span> FileOutputStream(dst);</span><br><span class="line">       BufferedInputStream buffIn = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">in</span>);</span><br><span class="line">       BufferedOutputStream buffOut = <span class="keyword">new</span> BufferedOutputStream(out)) &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    copyStream(<span class="keyword">in</span>, out);</span><br><span class="line">    System.out.println(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    copyStream(buffIn, buffOut);</span><br><span class="line">    System.out.println(System.nanoTime() - start);</span><br><span class="line">    <span class="comment">// 버퍼를 사용하면 throughput이 향상된다.</span></span><br><span class="line">    <span class="comment">// 반응성이 중요하지 않은 경우 거의 반드시 써야한다고 생각하면 된다.</span></span><br><span class="line">    <span class="comment">// 반응성이 중요하면 버퍼를 사용하지 않으면 좋겠다라고 생각하면 됨.</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BufferedReader는 readLine() 메소드를 사용할 수 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File src = <span class="keyword">new</span> File(<span class="string">&quot;./src.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (BufferedReader buffReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));) &#123;</span><br><span class="line">  String line = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="기본-데이터형-전송-스트림"><a href="#기본-데이터형-전송-스트림" class="headerlink" title="기본 데이터형 전송 스트림"></a>기본 데이터형 전송 스트림</h3><ul>
<li>byte, char 외에 다른 기본 데이터형도 전송 가능한 스트림<ul>
<li>읽은 후에는 자료형을 알 수 없으므로 쓴 순서대로 읽어야 함</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>클래스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>DataInputStream</td>
<td>boolean readBoolean()</td>
</tr>
<tr>
<td></td>
<td>byte readByte()</td>
</tr>
<tr>
<td></td>
<td>short readShort()</td>
</tr>
<tr>
<td></td>
<td>int readInt()</td>
</tr>
<tr>
<td></td>
<td>long readLong()</td>
</tr>
<tr>
<td></td>
<td>float readFloat()</td>
</tr>
<tr>
<td></td>
<td>double readDouble()</td>
</tr>
<tr>
<td></td>
<td>char readChar()</td>
</tr>
<tr>
<td></td>
<td>String readUTF()</td>
</tr>
<tr>
<td>DataOutputStream</td>
<td>void writeBoolean(bool v)</td>
</tr>
<tr>
<td></td>
<td>void writeByte(byte v)</td>
</tr>
<tr>
<td></td>
<td>void writeShort(short v)</td>
</tr>
<tr>
<td></td>
<td>void writeInt(int v)</td>
</tr>
<tr>
<td></td>
<td>void writeLong(long v)</td>
</tr>
<tr>
<td></td>
<td>void writeFloat(float v)</td>
</tr>
<tr>
<td></td>
<td>void writeDouble(double v)</td>
</tr>
<tr>
<td></td>
<td>void writeChar(char v)</td>
</tr>
<tr>
<td></td>
<td>void writeUTF(String v)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">File src = <span class="keyword">new</span> File(<span class="string">&quot;c:/Temp/data.dat&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(src))) &#123;</span><br><span class="line">  out.writeUTF(<span class="string">&quot;김자바&quot;</span>);</span><br><span class="line">  out.writeInt(<span class="number">15</span>);</span><br><span class="line">  out.writeFloat(<span class="number">14.23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 중요!! 읽어올 때는 위에 쓴 순서대로 읽어와야한다 그렇지않으면 디코딩이 제대로 이뤄지지 않음</span></span><br><span class="line"><span class="keyword">try</span> (DataInputStream <span class="keyword">in</span> = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(src))) &#123;</span><br><span class="line">  String string = <span class="keyword">in</span>.readUTF();</span><br><span class="line">  <span class="keyword">int</span> integer = <span class="keyword">in</span>.readInt();</span><br><span class="line">  <span class="keyword">float</span> floatNum = <span class="keyword">in</span>.readFloat();</span><br><span class="line">  System.out.println(string + <span class="string">&quot; &quot;</span> + integer + <span class="string">&quot; &quot;</span> + floatNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="객체-저장을-위한-스트림"><a href="#객체-저장을-위한-스트림" class="headerlink" title="객체 저장을 위한 스트림"></a>객체 저장을 위한 스트림</h3><ul>
<li>일반적인 참조형 객체를 저장하기 위한 스트림</li>
<li>직렬화(Serialization)와 역직렬화(Deserialization) 사용<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span> <span class="comment">// has-a 관계의 모든 클래스가 Serializable이어야 함</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L; <span class="comment">// 객체의 버전 관리</span></span><br><span class="line"></span><br><span class="line">  String userName;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">transient</span> String passWord;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> userName + <span class="string">&quot; &quot;</span> + id + <span class="string">&quot; &quot;</span> + passWord;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main (String [] args) &#123;</span><br><span class="line">    File dst = <span class="keyword">new</span> File(<span class="string">&quot;C:/Temp/obj.data&quot;</span>);</span><br><span class="line">    Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">    foo.userName = <span class="string">&quot;김사탕&quot;</span>;</span><br><span class="line">    foo.id = <span class="number">142</span>;</span><br><span class="line">    foo.passWord = <span class="string">&quot;qwer1234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(dst));</span><br><span class="line">        ObjectInputStream <span class="keyword">in</span> = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(dst));) &#123;</span><br><span class="line">      out.writeObject(foo);</span><br><span class="line">      Object read = <span class="keyword">in</span>.readobject();</span><br><span class="line">      <span class="keyword">if</span> (read != <span class="literal">null</span> &amp;&amp; read <span class="keyword">instanceof</span> Foo) &#123;</span><br><span class="line">        Foo readFoo = (Foo)read;</span><br><span class="line">        System.out.println(readFoo);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>부모 클래스가 Serializable이 아닌 경우 자식 클래스에서 직접 처리<ul>
<li>writeObject(), readObject()를 자식 클래스에서 직접 구현<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentFoo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> memVarOne;</span><br><span class="line">  <span class="keyword">double</span> memVarTwo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildFoo</span> <span class="keyword">extends</span> <span class="title">ParentFoo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> writeObject(ObjectOutputStream out) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    out.writeInt(memVarOne);</span><br><span class="line">    out.writeDouble(memVarTwo);</span><br><span class="line">    out.defaultWriteObject();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> readObject(ObjectInputStream <span class="keyword">in</span>) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    memVarOne = <span class="keyword">in</span>.readInt();</span><br><span class="line">    memVarTwo = <span class="keyword">in</span>.readDouble();</span><br><span class="line">    <span class="keyword">in</span>.defaultReadObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/" data-id="ckgm2mncn002mvwu286y639id" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/10/10/Java/JavaAdvanced/Java-Stream_IntermediateOperations/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java_Stream-중간 처리 메소드(중간 연산자)
        
      </div>
    </a>
  
  
    <a href="/2020/09/29/Java/JavaAdvanced/Java-Java_langPackage/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java_Java-lang Package</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-StockPrice/">AlgorithmSolution_StockPrice(주식가격)</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-NotFinishedPlayer/">AlgorithmSolution_완주하지 못한 선수</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-PhoneNumberList/">AlgorithmSolution_전화 번호 목록</a>
          </li>
        
          <li>
            <a href="/2020/10/21/Algorithm/Solution-NumberKth/">AlgorithmSolution_K번째 수</a>
          </li>
        
          <li>
            <a href="/2020/10/18/Java/SW_Enginerring/DesignPatterns/">SW_Enginerring-DesignPatterns</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>