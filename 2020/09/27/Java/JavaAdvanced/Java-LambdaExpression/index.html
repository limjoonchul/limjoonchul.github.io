<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java_LambdaExpression | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="람다식(Lambda Expression)람다식 Java1.8에서 추가된 함수형 프로그래밍 기법이다. 객체지향 프로그래밍과 다르게, 비즈니스 로직만을 빠르게 구현하는 특징. 객체지향 언어인 Java에서 메소드를 함수처럼 사용하는 형식.  함수적 프로그래밍 y &#x3D; f(x) 형태의 함수로 구성된 프로그래밍 기법 x에 어떤 값을 주면 y가 얻어지는 함수형 기법 데">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_LambdaExpression">
<meta property="og:url" content="https://limjoonchul.github.io/2020/09/27/Java/JavaAdvanced/Java-LambdaExpression/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="람다식(Lambda Expression)람다식 Java1.8에서 추가된 함수형 프로그래밍 기법이다. 객체지향 프로그래밍과 다르게, 비즈니스 로직만을 빠르게 구현하는 특징. 객체지향 언어인 Java에서 메소드를 함수처럼 사용하는 형식.  함수적 프로그래밍 y &#x3D; f(x) 형태의 함수로 구성된 프로그래밍 기법 x에 어떤 값을 주면 y가 얻어지는 함수형 기법 데">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-27T12:35:58.485Z">
<meta property="article:modified_time" content="2020-10-02T11:30:31.725Z">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java/JavaAdvanced/Java-LambdaExpression" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/Java/JavaAdvanced/Java-LambdaExpression/" class="article-date">
  <time datetime="2020-09-27T12:35:58.485Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java_LambdaExpression
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="람다식-Lambda-Expression"><a href="#람다식-Lambda-Expression" class="headerlink" title="람다식(Lambda Expression)"></a>람다식(Lambda Expression)</h1><h2 id="람다식"><a href="#람다식" class="headerlink" title="람다식"></a>람다식</h2><ul>
<li>Java1.8에서 추가된 함수형 프로그래밍 기법이다.</li>
<li>객체지향 프로그래밍과 다르게, 비즈니스 로직만을 빠르게 구현하는 특징.</li>
<li>객체지향 언어인 Java에서 메소드를 함수처럼 사용하는 형식.</li>
</ul>
<h3 id="함수적-프로그래밍"><a href="#함수적-프로그래밍" class="headerlink" title="함수적 프로그래밍"></a>함수적 프로그래밍</h3><ul>
<li>y = f(x) 형태의 함수로 구성된 프로그래밍 기법 x에 어떤 값을 주면 y가 얻어지는 함수형 기법<ul>
<li>데이터를 매개값으로 전달하고 결과를 받는 코드들로 구성</li>
<li>객체 지향 프로그래밍 보다는 효율적인 경우<ul>
<li>대용량 데이터의 처리시에 유리<br>객체를  생성후 처리하는 것보다, 데이터를 바로 처리하는 것이 속도에 유리</li>
<li>이벤트 지향 프로그래밍(이벤트가 발생하면 핸들러 함수 실행)에 적합<br>반복적인 이벤트 처리는 핸들러 객체보다는 핸들러 함수가 적합</li>
</ul>
</li>
</ul>
</li>
<li>현대적 프로그래밍 기법<ul>
<li>객체 지향 프로그래밍 <code>+</code> 함수적 프로그래밍</li>
</ul>
</li>
</ul>
<h3 id="자바에서-람다식을-수용한-이유"><a href="#자바에서-람다식을-수용한-이유" class="headerlink" title="자바에서 람다식을 수용한 이유"></a>자바에서 람다식을 수용한 이유</h3><ul>
<li>코드가 매우 간결해진다,</li>
<li>컬렉션 요소(대용량 데이터)를 필터링 또는 매핑해서 쉽게 집계할 수 있다.</li>
</ul>
<h3 id="자바는-람다식을-함수적-인터페이스의-익명-구현-객체로-취급한다"><a href="#자바는-람다식을-함수적-인터페이스의-익명-구현-객체로-취급한다" class="headerlink" title="자바는 람다식을 함수적 인터페이스의 익명 구현 객체로 취급한다."></a>자바는 람다식을 함수적 인터페이스의 익명 구현 객체로 취급한다.</h3><ul>
<li>람다식은 매개변수를 가진 코드블록이다. -&gt; 익명 구현 객체</li>
<li>어떤 인터페이스를 구현할지는 대입되는 인터페이스에 달려있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Runnable runnable  = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 위의 코드처럼 있다 가정할 때, 익명 구현 객체는 아래 부분에 해당한다.</span></span><br><span class="line"><span class="comment">//  이것과 똑같은 효과를 내게 하는것이 람다식이다.</span></span><br><span class="line"><span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;...&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="함수적-인터페이스"><a href="#함수적-인터페이스" class="headerlink" title="함수적 인터페이스"></a>함수적 인터페이스</h4><ul>
<li><p>하나의 추상 메소드로 선언된 인터페이스만 타켓 타입이 될 수 있다</p>
</li>
<li><p>@FuntionalInterface 어노테이션</p>
<ul>
<li>하나의 추상 메소드만을 가지는지 컴파일러가 체크하도록 한다.</li>
<li>두 개 이상의 추상 메소드가 선언되어 있으면 컴파일 오류가 발생한다.<h2 id="람다식의-예"><a href="#람다식의-예" class="headerlink" title="람다식의 예"></a>람다식의 예</h2><h3 id="배열의-정렬"><a href="#배열의-정렬" class="headerlink" title="배열의 정렬"></a>배열의 정렬</h3></li>
</ul>
</li>
<li><p>기본 정렬 방식을 이용한 정렬</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String [] strings = &#123;<span class="string">&quot;fast&quot;</span>,<span class="string">&quot;campus&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;backend&quot;</span>,<span class="string">&quot;choigo&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;people&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br><span class="line">Arrays.sort(strings);<span class="comment">// 정렬할 수 있다. 사전순으로 Arrays로 정렬하는거 하나 새로 배움</span></span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Comparator 클래스를 만들고, 객체를 생성하여 전달하는 방식</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// string을 비교하기 위한 메소드를 인터페이스가 가지고 있어서</span></span><br><span class="line">   <span class="comment">// 인터페이스를 구현하면 sort에 넘겨주면 사전순으로 되어있던걸</span></span><br><span class="line">   <span class="comment">// 추가로 객체를 생성해서 메소드를 새롭게 구현하여 넣어서 새로 구현한 메소드가 정렬하는 방식을 다르게 할 수 있다.</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> compare(String o1, String o2) &#123;</span><br><span class="line">       <span class="keyword">return</span> o1.substring(<span class="number">1</span>).compareTo(o2.substring(<span class="number">1</span>));</span><br><span class="line">       <span class="comment">// 둘다 짤라서 시작문자가 1번 두번째 인덱스 자리를 서로 비교하는 것</span></span><br><span class="line">       <span class="comment">// compareto는 comparable 인터페이스에 있는 것을 가져옴, 이미 스트링에 정의되어 있음</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 기준을 바꾸고 싶을 때 방법은 새로운 comparator를 넣어줘서</span></span><br><span class="line"> <span class="comment">// 객체를 정렬하는 방법을 할 수 있다.</span></span><br><span class="line"> Arrays.sort(strings, <span class="keyword">new</span> MyComparator());</span><br><span class="line"> System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure></li>
<li><p>익명 내부 클래스를 이용할 수 있다.</p>
<ul>
<li>상속하고 싶은 인터페이스든 클래스를 적어준 다음에 블록을 열어서 재정의 해주면 작성할 수 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> compare(String o1, String o2) &#123;</span><br><span class="line">          <span class="keyword">return</span> o1.substring(<span class="number">2</span>).compareTo(o2.substring(<span class="number">2</span>)); <span class="comment">//필요한 내용은 이것이다.</span></span><br><span class="line">     &#125;</span><br><span class="line">);</span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>람다식을 이용한 방법</p>
<ul>
<li>클래스없이 작성이 가능한 익명내부클래스를 한번 더 줄임</li>
<li>람다식을 이용하는게 가장 간단하고 하기 편함</li>
<li>sort를 보면 하나만 입력을 받으면 자체를 비교하게 되고 두개를 입력받으면 comparator??<br>두번째 파라미터는 comparator를 구현한 람다식이라는 것을 알고 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, (o1, o2) -&gt; o1.substring(<span class="number">3</span>).compareTo(o2.substring(<span class="number">3</span>)));</span><br><span class="line">       <span class="comment">// 이게 비즈니스로직 동작했으면 하는 코드만 작성하는 것</span></span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Comparable 인터페이스를 이용한 방법</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hansol</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Hansol</span>&gt;&#123;</span></span><br><span class="line">     <span class="comment">//String 을 상속이 안되서 따로 컴포지션해서 사용했다?</span></span><br><span class="line">     String value;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">public</span> Hansol(String value) &#123;</span><br><span class="line">           <span class="built_in">this</span>.value = value;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> compareTo(Hansol o) &#123;</span><br><span class="line">         <span class="keyword">return</span> value.substring(<span class="number">1</span>).compareTo(o.value.substring(<span class="number">1</span>));</span><br><span class="line">         <span class="comment">// 자기자신이갖고있는 value랑 외부에서들어온 객체 value랑 비교를 함.</span></span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;                      <span class="comment">//스트링이 됬다면 이런 부부느 안해도 됬다.</span></span><br><span class="line">Hansol[] hansols = &#123;<span class="keyword">new</span> Hansol(<span class="string">&quot;fast&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;campus&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;backend&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;java&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;choigo&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;best&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;people&quot;</span>)&#125;;</span><br><span class="line">Arrays.sort(hansols);</span><br><span class="line">System.out.println(Arrays.toString(hansols));</span><br></pre></td></tr></table></figure></li>
<li><p>String 이 상속이 가능했다면 이용한 방법</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 밑에 코드만 구현했으면 됬는데 string은 final로 되어있어서 상속이 안됨</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fansol</span> <span class="keyword">extends</span> <span class="title">String</span>&#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> compareTo(String o)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="람다식을-사용하기-위한-조건"><a href="#람다식을-사용하기-위한-조건" class="headerlink" title="람다식을 사용하기 위한 조건"></a>람다식을 사용하기 위한 조건</h2></li>
<li><p>위의 코드는는 Comparator 인터페이스를 구현 했는데 이번엔 직접 작성한 것이다.</p>
</li>
<li><p>람다식으로 사용하기 위해서는 단 하나의 추상 메소드를 가지고 있어야 한다.</p>
<ul>
<li>추상메소드가 2개이상이면 오류가 발생한다.</li>
<li>디폴트 메소드는 구현이 되어 있더라도 상관이 없다.</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 필수는 아니다. 하지만 적어주면 interface가 적합한지 확인해준다.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runner</span>&lt;<span class="title">T</span>&gt;&#123;</span></span><br><span class="line">    T run(); <span class="comment">// 추상메소드는 단 하나만 있어야 한다. runner라는 객체를 넣어줬을 때</span></span><br><span class="line">    <span class="comment">// run()을 실행할 때 우리가 값을 하나만 넣어서 보낼 때 하나만 있어야 밑에 문장이 run()라고 확신 할수있다.</span></span><br><span class="line">    <span class="comment">// T runTwo() // 추상메소드가 2개 이상이면 오류 발생</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> method()&#123;&#125; <span class="comment">// 디폴트 메소드가 구현이 되어 있더라도 상관이 없다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">                          <span class="comment">// ? 라고 적어주면 어떤 것이든 상관이 없다.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> useRunner(Runner&lt;?&gt; runner)&#123;</span><br><span class="line">        System.out.println(runner.run());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">                                 <span class="comment">//? 랑 같은 타입이여야 하는데 ?로써지면 뭐가 들어오든 상관 없음</span></span><br><span class="line"><span class="comment">//         class MyRun implements Runner&lt;String&gt;&#123; 익명 내부 클래스</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//             @Override</span></span><br><span class="line"><span class="comment">//             public String run() &#123;</span></span><br><span class="line"><span class="comment">//                 return null;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         useRunner(new MyRun());</span></span><br><span class="line">        useRunner(() -&gt; <span class="string">&quot;This is how to use runner.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="다양한-람다식-표현-형식"><a href="#다양한-람다식-표현-형식" class="headerlink" title="다양한 람다식 표현 형식"></a>다양한 람다식 표현 형식</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runner</span>&#123;</span></span><br><span class="line">    String run(String x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RunnerTwo</span>&#123;</span></span><br><span class="line">    String run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> useRunner(String x, Runner runner)&#123;</span><br><span class="line">        System.out.println(runner.run(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> useRunnerTwo(RunnerTwo runner)&#123;</span><br><span class="line">        System.out.println(runner.run());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">         <span class="comment">// 람다식의 표준 형식</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// --------------------- 제대로 이해가지 않음------------- 아이러니해</span></span><br><span class="line">         <span class="comment">// 여기서 메소드를 정의해준 것을 위에 run()에서 호출해서 프린트로 정의해주면 useRunner을 다시 여기서 호출해서 그 프린트값을 출력------------</span></span><br><span class="line">        useRunner(<span class="string">&quot;안녕하세요!&quot;</span>,(String x) -&gt; &#123;<span class="keyword">return</span> x;&#125;); <span class="comment">//입력 파라미터의 자료형 입력 (String x) = Runner run &#123;run(String x)&#125; , &#123;return x;&#125; = run(String x)??&#123; return x;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 입력 파라미터가 1개면 () 생략하는 형식</span></span><br><span class="line">        useRunner(<span class="string">&quot;안녕하세요!&quot;</span>, x -&gt; &#123;<span class="keyword">return</span> x;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  입력 파라미터가 없으면 () 생략불가 형식</span></span><br><span class="line">        useRunnerTwo(() -&gt; &#123;<span class="keyword">return</span> <span class="string">&quot;안녕&quot;</span>;&#125;); </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 여러 줄 작성할 때 중괄호 필수이다. 이 때 return도 필요하다.</span></span><br><span class="line">        useRunner(<span class="string">&quot;안녕하세요!&quot;</span>,(x)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> x; </span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Expression을 바로 쓰면 알아서 return을 해준다.(expression labmda)</span></span><br><span class="line">        <span class="comment">// 한 줄로만 처리되는 expression이라면 세미콜론 없이 처리 가능.</span></span><br><span class="line">        useRunner(<span class="string">&quot;안녕&quot;</span>,x-&gt;x); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="람다식과-익명-클래스-객체가-동일한-것은-아니다라는-것의-증명"><a href="#람다식과-익명-클래스-객체가-동일한-것은-아니다라는-것의-증명" class="headerlink" title="람다식과 익명 클래스 객체가 동일한 것은 아니다라는 것의 증명"></a>람다식과 익명 클래스 객체가 동일한 것은 아니다라는 것의 증명</h2><ul>
<li>람다식과 익명 내부 클래스가 비슷한 것이라고 했는데 각각 구현을 해서 this를 출력해보니 결과 값이 다르게 나온다.<ul>
<li>이유는 익명 내부 클래스로 구현을 하면 익명 내부 클래스의 객체가 생성이 되서 this가 그 객체를 가리키지만,<br>람다식은 다르게 객체가 만들어지지 않아 Main의 객체가 만들어진다. </li>
</ul>
</li>
<li>이 부분만 다르고 완전히 똑같다고 생각하면 된다.  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFoo</span>&#123;</span></span><br><span class="line">    String method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> funtionalMethod(IFoo foo)&#123;</span><br><span class="line">        System.out.println(foo.method());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> methodA()&#123;</span><br><span class="line">        <span class="comment">// 그외에는 둘이 완전히 똑같다고 생각하면된다 this만 다르다고 생각하면 된다.</span></span><br><span class="line">        funtionalMethod(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this&quot;</span>+ <span class="built_in">this</span>); <span class="comment">// 이 this가 왜 Main의 객체?</span></span><br><span class="line">            <span class="comment">// 익명클래스와 다르게 람다식은 익명클래스와 달리 클래스가 만들어지지 않는다.</span></span><br><span class="line">            <span class="comment">// 함수형 인터페이스로 동작을 한다.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;OuterClass.this&quot;</span>+Main.<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Lambad expression used.&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">       <span class="comment">// 위 아래 출력 값이 다르다. this의 출력값이 다르다</span></span><br><span class="line">        funtionalMethod(<span class="keyword">new</span> IFoo() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String method() &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;this&quot;</span>+ <span class="built_in">this</span>); <span class="comment">// 익명 클래스의 객체가 this가 된다.</span></span><br><span class="line">                <span class="comment">// 익명클래스를사용할 때 실제로 익명클래스가 만들어지고 사용이되서 넣어진다는게 증명이된다.</span></span><br><span class="line">                System.out.println(<span class="string">&quot;OuterClass.this&quot;</span>+Main.<span class="built_in">this</span>); <span class="comment">//외부 클래스인 Main 객체의 this</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Anonymous local inner class used.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">new</span> Main().methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="표준-함수형-인터페이스"><a href="#표준-함수형-인터페이스" class="headerlink" title="표준 함수형 인터페이스"></a>표준 함수형 인터페이스</h2></li>
<li>자바 8부터 표준 API로 제공되는 함수형 인터페이스<ul>
<li>java.util.function 패키지에 포함되어 있다.</li>
<li>매개타입으로 사용되어 람다식을 매개값으로 대입할 수 있도록 해준다.</li>
</ul>
</li>
<li>자주 사용되는 함수형 인터페이스를 정의해 둔 API</li>
<li>Consumer, Supplier, Function, Operation, Predicate 계열이 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>계열</th>
<th>입력</th>
<th>출력</th>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer</td>
<td>O</td>
<td>X</td>
<td>void accept(T)</td>
<td>입력을 소비</td>
</tr>
<tr>
<td>Supplier</td>
<td>X</td>
<td>O</td>
<td>T get()</td>
<td>출력을 공급</td>
</tr>
<tr>
<td>Function</td>
<td>O</td>
<td>O</td>
<td>T apply(R)</td>
<td>입력 -&gt; 출력 함수 매핑</td>
</tr>
<tr>
<td>Operation</td>
<td>O</td>
<td>O</td>
<td>T apply(T)</td>
<td>입력을 연산하여 동일 타입의 출력으로 리턴</td>
</tr>
<tr>
<td>Predicate</td>
<td>O</td>
<td>boolean</td>
<td>boolean test(T)</td>
<td>입력을 판단</td>
</tr>
</tbody></table>
<h3 id="표준-함수형-인터페이스의-종류"><a href="#표준-함수형-인터페이스의-종류" class="headerlink" title="표준 함수형 인터페이스의 종류"></a>표준 함수형 인터페이스의 종류</h3><h4 id="Consumer-계열"><a href="#Consumer-계열" class="headerlink" title="Consumer 계열"></a>Consumer 계열</h4><ul>
<li>파라미터 입력을 받아서 그것을 소비하는 Funtional Interface이다.<ul>
<li>소비라는 것은 함수가 이용된다 라고 생각하면 된다. 리턴이 되지 않고<br>함수 내에서 사용이 되고 새로운 출력으로 되는게 아니고 없어진다.<br>그래서 소비라고 의미를 부여한 것이다.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T></td>
<td>void accept(T t)</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>void accept(T t, U u)</td>
</tr>
<tr>
<td>IntConsumer</td>
<td>void accept(int value)</td>
</tr>
<tr>
<td>LongConsumer</td>
<td>void accept(long value)</td>
</tr>
<tr>
<td>DoubleConsumer</td>
<td>void accept(double value)</td>
</tr>
<tr>
<td>ObjIntConsumer<T></td>
<td>void accept(T t, int value)</td>
</tr>
<tr>
<td>ObjLongConsumer<T></td>
<td>void accept(T t, long value)</td>
</tr>
<tr>
<td>ObjDoubleConsumer<T></td>
<td>void accept(T t, double value)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = (s)-&gt; System.out.println(s);</span><br><span class="line">        <span class="comment">// &lt;String&gt;이므로 매개값 s는 String</span></span><br><span class="line">        consumer.accept(<span class="string">&quot;A String.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiConsumer&lt;String, String&gt; biConsumer = (t,u) -&gt; System.out.println(t+<span class="string">&quot;,&quot;</span>+u);</span><br><span class="line">        <span class="comment">// &lt;String,String&gt; 이므로 매개값 t와 u는 모두 String 타입</span></span><br><span class="line">        biConsumer.accept(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 오토박싱/ 언방식 사용하면 비효율적이다.</span></span><br><span class="line">        Consumer&lt;Integer&gt; integerConsumer = (x) -&gt; System.out.println(x);</span><br><span class="line">        integerConsumer.accept(<span class="number">10</span>); <span class="comment">// 값이 들어갈 땐 오토박싱 출력할 때 언박싱</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 효율적으로 하기 위해서 IntConsumer 제네릭이 아니다 기본형 타입</span></span><br><span class="line">        <span class="comment">// 기본형 입력을 하려고 할 경우, PConsumber (p: primitive type)을 사용 가능.</span></span><br><span class="line">        <span class="comment">// 주의! 오버로딩이 아니고 별도의 인터페이스이다. 최적화를 위해서 불편하더라도 별도로 만들어 놓은 것이다.</span></span><br><span class="line">        IntConsumer intConsumer = (x) -&gt; System.out.println(x);</span><br><span class="line">        intConsumer.accept(<span class="number">5</span>); <span class="comment">// 객체가 아니라 값을 입력을 받는 것이다. 기본자료형이니깐</span></span><br><span class="line">        <span class="comment">//LongConsumer, DoubleConsumer</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// t는 &lt;&gt;안에 값 x는 objIntconsumber의 int의 자료형이 들어간다.</span></span><br><span class="line">        ObjIntConsumer&lt;String&gt; objIntConsumer = (t,x) -&gt; System.out.println(t + <span class="string">&quot;: &quot;</span>+ x);</span><br><span class="line">        objIntConsumer.accept(<span class="string">&quot;x&quot;</span>,<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// ObjLongConsumer,ObjDoubleConsumer</span></span><br><span class="line">        <span class="comment">// 총 4가지 타입이 있다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Supplier-계열"><a href="#Supplier-계열" class="headerlink" title="Supplier 계열"></a>Supplier 계열</h4><ul>
<li>아무런 입력을 받지 않고, 값을 하나 반환하는 함수형 인터페이스이다.</li>
<li>자료를 ‘공급’하는 공급자 역학을 한다.</li>
<li>외부로 데이터를 리턴해주는 역할을 한다.<ul>
<li>getXXX() 메소드 사용</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Supplier<T></td>
<td>T get()</td>
</tr>
<tr>
<td>BooleanSupplier</td>
<td>boolean getAsBoolean()</td>
</tr>
<tr>
<td>IntSupplier</td>
<td>int getAsInt()</td>
</tr>
<tr>
<td>LongSupplier</td>
<td>long getAsLong()</td>
</tr>
<tr>
<td>DoubleSupplier</td>
<td>double getAsDouble()</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.BooleanSupplier;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntSupplier;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;A String&quot;</span>;<span class="comment">//입력을 받지 않기때문에 ()이 필요하다.</span></span><br><span class="line">        System.out.println(supplier.get()); <span class="comment">// get()을 해서 출력을 한다.</span></span><br><span class="line">        <span class="comment">// BiSupperlier는 입력은 여러 개 할 수 있지만, 출력은 하나 밖에 못하기 때문에 없다.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Supplier는 P Type 계엘에서 getAsP 메소드로 정의가 된다. primitive</span></span><br><span class="line">        <span class="comment">// 메소드가 다르다. getAsInt()...</span></span><br><span class="line">        BooleanSupplier boolsup = () -&gt; <span class="literal">true</span>;</span><br><span class="line">        System.out.println(boolsup.getAsBoolean()); <span class="comment">// 이것은 getAsBoolean()으로 출력한다.</span></span><br><span class="line">        <span class="comment">// IntSupplier, LongSupplier, DoubleSupplier</span></span><br><span class="line"></span><br><span class="line">        IntSupplier rollDice = () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//0~6까지 나와서 6은 나오지 않음 0~5까지만 실제 값이 나온다.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(rollDice.getAsInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        IntSupplier intSupp = () -&gt; x; <span class="comment">//로컬변수에도 접근할 수 있다.</span></span><br><span class="line">        <span class="comment">// 람다식을 활용할 때 모든 변수에 접근하여 활용할 수 있다.</span></span><br><span class="line">        <span class="comment">// 고정되어있는 값뿐만아니라 동적으로도 주변 값들을 공급할 수 있다.</span></span><br><span class="line">        <span class="comment">// 그래서 supplier가 나름대로의 의미가 있다??</span></span><br><span class="line">        System.out.println(intSupp.getAsInt());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Funtion-계열"><a href="#Funtion-계열" class="headerlink" title="Funtion 계열"></a>Funtion 계열</h4><ul>
<li>Mapping : 입력 -&gt;  출력을 연결하는 함수형 인터페이스</li>
<li>입력 타입과 출력 타입은 다를 수 있다.(다를 수 있다라는건 같을 수도 있다는 말도 된다.)</li>
<li>매개값을 리턴값으로 매핑(타입변환)하는 역할을 한다.<ul>
<li>applyXXXX() 메소드 사용.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Function&lt;T, R&gt;</td>
<td>R apply(T t)</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U, R&gt;</td>
<td>R apply(T t, U u)</td>
</tr>
<tr>
<td>PFunction<R></td>
<td>R apply(p value)</td>
</tr>
<tr>
<td>PtoQFunction</td>
<td>q applyAsQ(p value)</td>
</tr>
<tr>
<td>ToPFunction<T></td>
<td>p applyAsP(T t)</td>
</tr>
<tr>
<td>ToPBiFunction&lt;T, U&gt;</td>
<td>p applyAsP(T t, U u)</td>
</tr>
</tbody></table>
<ul>
<li><p>P, Q 는 기본 자료형(Primitive Type) : Int, Long, Double</p>
</li>
<li><p>p, q 는 기본 자료형(Primitive Type) : int, long, double</p>
</li>
<li><p>Funtion&lt;Student, String&gt; funtion = t-&gt; {return t.getName()};</p>
<ul>
<li>&lt;Student,String&gt;이므로 매개값 t는 Student 타입이고 리턴 값은String 타입이다.</li>
<li>Student 객체를 String으로 매핑한 예제</li>
</ul>
</li>
<li><p>ToIntFuntion<Student> funtion = t -&gt; {return t.getScore();}</p>
<ul>
<li><Student> 이므로 매개값 t는 Student 타입이고 리턴값은 int 타입 고정</li>
<li>Student 객체를 int로 매핑한 예제 </li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Function&lt;String,Integer&gt; func = (s) -&gt; s.length();</span><br><span class="line">        <span class="comment">// s 는 String타입, s.length() 는 Integer</span></span><br><span class="line">        System.out.println(func.apply(<span class="string">&quot;Strings&quot;</span>)); <span class="comment">//이것은 apply로 출력한다</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bi가 붙으면 &#x27;입력&#x27;을 2개 받을 수 있다는 의미이다.</span></span><br><span class="line">        BiFunction&lt;String,String,Integer&gt; biFunction = (s,u) -&gt; s.length() + u.length();</span><br><span class="line">        System.out.println(biFunction.apply(<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>)); <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// IntFunction&lt;R&gt;은 리턴 자료형</span></span><br><span class="line">        <span class="comment">// P type Funtion은 입력을 P타입으로 받는다.</span></span><br><span class="line">        IntFunction&lt;String&gt; intFunction = (value) -&gt; String.valueOf(value);<span class="comment">// &quot;&quot; + value도 가능.</span></span><br><span class="line">        System.out.println(intFunction.apply(<span class="number">512</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ToP Type Function은 출력을 P타입으로 한다.</span></span><br><span class="line">        ToIntFunction&lt;String&gt; funcFour = (s) -&gt; s.length(); <span class="comment">// 4:21</span></span><br><span class="line">        System.out.println(funcFour.applyAsInt(<span class="string">&quot;abcde&quot;</span>));</span><br><span class="line">        <span class="comment">// 출력이 P타입인 경우에는 AsP가 들어간다.!!!</span></span><br><span class="line">        <span class="comment">//ToIntBiFunction&lt;String,String&gt;// int 출력을 하는 Bi 함수</span></span><br><span class="line">        <span class="comment">// P: Int, Long, Double</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int 에서 double로 바꾸는 함수 PToQFunction : P -&gt; Q로 매핑하는 함수</span></span><br><span class="line">        IntToDoubleFunction funcfive;</span><br><span class="line">        <span class="comment">// IntToIntFunction은 없다. 동일한 것에 대해서는 다른게 있다 4:23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Operator-계열"><a href="#Operator-계열" class="headerlink" title="Operator 계열"></a>Operator 계열</h4><ul>
<li>입력받은 타입과 동일한 타입의 출력을 하는 함수형 인터페이스</li>
<li>Funtion 계열과 달리 입출력 타입이 다를 수 없다.</li>
<li>applyXXX() 메소드를 가지고 있고 매개값을 리턴값으로 매핑하는 역할보다는<br>매개값을 이용해서 연산을 수행한 후 동일한 타입으로 리턴값을 제공하는 역할을 한다.</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>UnaryOperator<T></td>
<td>T apply(T t)</td>
</tr>
<tr>
<td>BinaryOperator<T></td>
<td>T apply(T t1, T t2)</td>
</tr>
<tr>
<td>IntUnaryOperator</td>
<td>int applyAsInt(int value)</td>
</tr>
<tr>
<td>LongUnaryOperator</td>
<td>long applyAsLong(long value)</td>
</tr>
<tr>
<td>DoubleUnaryOperator</td>
<td>double applyAsDouble(double value)</td>
</tr>
<tr>
<td>IntBinaryOperator</td>
<td>int applyAsInt(int value1, int value2)</td>
</tr>
<tr>
<td>LongBinaryOperator</td>
<td>long applyAsLong(long value, long value2)</td>
</tr>
<tr>
<td>DoubleBinaryOperator</td>
<td>double applyAsDouble(double value, double value2)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.BinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntUnaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">// 그냥 operator는 없다.</span></span><br><span class="line">        <span class="comment">//입력이 1개 인 것을 Unary를 붙여서 표현</span></span><br><span class="line">        UnaryOperator&lt;String&gt; operator = s -&gt; s+<span class="string">&quot;.&quot;</span>; <span class="comment">//리턴타입을 따로 입력받지 않는다 입출력이 같으니깐</span></span><br><span class="line">        System.out.println(operator.apply(<span class="string">&quot;왔다&quot;</span>)); <span class="comment">// apply() 사용.</span></span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;String&gt; operator1 = (s1,s2) -&gt; s1 + s2;<span class="comment">//타입은 하나만 입력받게 되어있다. 출력은 동일한 타입이여야 하니깐?</span></span><br><span class="line">        System.out.println(operator1.apply(<span class="string">&quot;나&quot;</span>,<span class="string">&quot;왔다&quot;</span>));</span><br><span class="line"></span><br><span class="line">        IntUnaryOperator op = value -&gt; value*<span class="number">10</span>; <span class="comment">//타입을 받지 않는다 어차피 int입력 int출력이니</span></span><br><span class="line">        System.out.println(op.applyAsInt(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">// LongUnaryOperator, DoubleUnaryOperator</span></span><br><span class="line"></span><br><span class="line">        IntBinaryOperator ibo = (v1,v2) -&gt; v1 * v2;</span><br><span class="line">        System.out.println(ibo.applyAsInt(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">        <span class="comment">//LongBinaryOperator, DoubleBinaryOperator</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Predicate-계열"><a href="#Predicate-계열" class="headerlink" title="Predicate 계열"></a>Predicate 계열</h4><ul>
<li>논리 판단을 해주는 함수형 인터페이스</li>
<li>입력을 받아서 boolean 타입 출력을 반환한다.</li>
<li>매개변수와 boolean 리턴값이 있는 testXXX() 메소드를 가지고 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate<T></td>
<td>boolean test(T t)</td>
</tr>
<tr>
<td>BiPredicate&lt;T, U&gt;</td>
<td>boolean test(T t, U u)</td>
</tr>
<tr>
<td>IntPredicate</td>
<td>boolean test(int value)</td>
</tr>
<tr>
<td>LongPredicate</td>
<td>boolean test(long value)</td>
</tr>
<tr>
<td>DoublePredicate</td>
<td>boolean test(double value)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.BiPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = (s) -&gt; s.length() == <span class="number">4</span>; <span class="comment">// 조건식이 들어가야 한다.</span></span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;Four&quot;</span>)); <span class="comment">// test()를 사용한다 true or false 값 출력</span></span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;six&quot;</span>));</span><br><span class="line"></span><br><span class="line">        BiPredicate&lt;String, Integer&gt; pred2 = (s,v) -&gt; s.length() ==v;</span><br><span class="line">        System.out.println(pred2.test(<span class="string">&quot;abcd&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        System.out.println(pred2.test(<span class="string">&quot;abc&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        IntPredicate pred3 = x -&gt; x &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//LongPredicate, DoublePredicate asP출력은 존재하지 않는다.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="표준-함수형-인터페이스의-메소드"><a href="#표준-함수형-인터페이스의-메소드" class="headerlink" title="표준 함수형 인터페이스의 메소드"></a>표준 함수형 인터페이스의 메소드</h3><h4 id="andThen-compose"><a href="#andThen-compose" class="headerlink" title="andThen(), compose()"></a>andThen(), compose()</h4><ul>
<li><p>두 개 이상의 함수형 인터페이스를 연결하기 위해서 사용한다.</p>
<ul>
<li><p><code>A.andThen(B)</code> : A를 먼저 실행하고 B를 실행, Consumer, Function, Operator 계열의 default method로 구현</p>
</li>
<li><p>Consumer의 순차적 연결</p>
<ul>
<li>Consumer 종류의 함수적 인터페이스는 처리 결과를 리턴하지 않기 때문에<br>andThen()과 compose() 디폴트 메소드는 함수적인터페이스의 호출 순서만 정한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c0 = s -&gt; System.out.println(<span class="string">&quot;c0 :&quot;</span> + s);</span><br><span class="line">Consumer&lt;String&gt; c1 = s -&gt; System.out.println(<span class="string">&quot;c1 :&quot;</span> + s);</span><br><span class="line">Consumer&lt;String&gt; c2 = c0.andThen(c1);</span><br><span class="line">c2.accept(<span class="string">&quot;String&quot;</span>); <span class="comment">//동일한 스트링을 출력한다.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>A.compose(B)</code> : B를 먼저 실행하고 A를 실행, Function, Operator 계열의 default method로 구현</p>
</li>
<li><p>Function의 순차적 연결</p>
<ul>
<li>Function과 Operator 종류의 함수적 인터페이스는 먼저 실행한 함수적 인터페이스의<br>결과를 다음 함수적 인터페이스의 매객밧으로 넘겨주고, 최종처리결과를 리턴한다.</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function 계열은 입력-&gt;출력 ==&gt; 입력-&gt; 출력 타입이 연쇄 되어야 한다.</span></span><br><span class="line">Function&lt;String, Integer&gt; func1 = s -&gt; s.length();</span><br><span class="line">Function&lt;Integer, Long&gt; func2 = value -&gt; (<span class="keyword">long</span>)value;</span><br><span class="line"><span class="comment">// func1의 입력이 String, 출력이 Integer이니깐, andThen()의 입력은 Integer여야 한다.</span></span><br><span class="line">Function&lt;String,Long&gt; func3 = func1.andThen(func2);</span><br><span class="line">System.out.println(func3.apply(<span class="string">&quot;four&quot;</span>));</span><br><span class="line"></span><br><span class="line">Function&lt;String, Long&gt; func4 = func2.compose(func1);</span><br><span class="line">System.out.println(func4.apply(<span class="string">&quot;four&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="and-or-negeate-isEqual"><a href="#and-or-negeate-isEqual" class="headerlink" title="and(), or(), negeate(), isEqual()"></a>and(), or(), negeate(), isEqual()</h4></li>
<li><p>Predicate 계열의 기본 메소드</p>
<ul>
<li>and(), or(), negate()</li>
<li>&amp;&amp; , ||, ! 연산자의 동작을 한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체에서 메소드로 접근한다.</span></span><br><span class="line">DoublePredicate p0 = x -&gt; x &gt; <span class="number">0.5</span>;</span><br><span class="line">DoublePredicate p1 = x -&gt; x &lt; <span class="number">0.7</span>;</span><br><span class="line">DoublePredicate p2 = p0.and(p1);</span><br><span class="line">DoublePredicate p3 = p0.or(p1); </span><br><span class="line">DoublePredicate p4 = p0.negate();</span><br><span class="line">System.out.println(p0.test(<span class="number">0.9</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(p1.test(<span class="number">0.9</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(p2.test(<span class="number">0.9</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(p3.test(<span class="number">0.9</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(p4.test(<span class="number">0.9</span>)); <span class="comment">// false not p0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Predicate 계열의 클래스 메소드</p>
<ul>
<li>isEqual()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; eq = Predicate.isEqual(<span class="string">&quot;String&quot;</span>);</span><br><span class="line"><span class="comment">// 함수형 인터페이스를 사용할 수 있다. 람다식 사용 x</span></span><br><span class="line"><span class="comment">// 들어오는 String이랑 eq랑 같은지 테스트해주는 함수형 인터페이스를 리턴해줌</span></span><br><span class="line">System.out.println(eq.test(<span class="string">&quot;String&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(eq.test(<span class="string">&quot;String!&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="minBy-maxBy"><a href="#minBy-maxBy" class="headerlink" title="minBy(), maxBy()"></a>minBy(), maxBy()</h4></li>
</ul>
</li>
<li><p>BinaryOperator 클래스의 클래스 메소드</p>
<ul>
<li>Comparator<T>를 파라미터로 받아 최소값/최대값을 구하는 BinaryOperator<T>를 리턴<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        BinaryOperator&lt;String&gt; minBy = BinaryOperator.minBy((o1,o2)-&gt; o1.length() &gt; o2.length() ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        BinaryOperator&lt;String&gt; maxBy = BinaryOperator.maxBy((o1,o2)-&gt; o1.length() &gt; o2.length() ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BinaryOperator.minBy((String o1,String o2)-&gt; o1.length()+o2.length()); 이것도 가능</span></span><br><span class="line">        <span class="comment">// 어떤걸 받아 줄건지 써줘야 한다.</span></span><br><span class="line">        <span class="comment">// 앞에 String 타입을 넣어주면 뒤에서 o1,o2가 String 이라는 것을 추론할 수 있다.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(minBy.apply(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cd&quot;</span>)); <span class="comment">// 더 작은게 출력됨</span></span><br><span class="line">        System.out.println(maxBy.apply(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cd&quot;</span>)); <span class="comment">// 더 큰게 출력됨</span></span><br><span class="line">        System.out.println(minBy.apply(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>)); <span class="comment">// abc가 출려됨</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="람다식에-메소드-생성자-사용하는-예"><a href="#람다식에-메소드-생성자-사용하는-예" class="headerlink" title="람다식에 메소드/ 생성자 사용하는 예"></a>람다식에 메소드/ 생성자 사용하는 예</h4></li>
</ul>
</li>
<li><p>람다식에 기존에 구현되어 있는 내용을 재사용하고자 할 때 사용</p>
<ul>
<li>함수형 인터페이스를 재사용하지 못하는 단점을 보완하기 위해서 사용한다.<h5 id="ClassName-instanceMethod"><a href="#ClassName-instanceMethod" class="headerlink" title="ClassName::instanceMethod"></a>ClassName::instanceMethod</h5></li>
</ul>
</li>
<li><p>첫번째 파라미터를 객체로, 두번째 파라미터를 메소드 입력으로 사용한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(strings, <span class="attr">String:</span>:compareTo);</span><br></pre></td></tr></table></figure>
<h5 id="ClassName-classMethod"><a href="#ClassName-classMethod" class="headerlink" title="ClassName::classMethod"></a>ClassName::classMethod</h5></li>
<li><p>클래스 메소드의 입력으로 모든 파라미터가 사용됨</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; parser = <span class="attr">Integer:</span>:parseInt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="instance-instanceMethod"><a href="#instance-instanceMethod" class="headerlink" title="instance::instanceMethod"></a>instance::instanceMethod</h5><ul>
<li>주어진 객체의 메소드를 호출<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">&quot;StringA&quot;</span>;</span><br><span class="line">Predicate&lt;String&gt; pred = <span class="attr">string:</span>:equals;</span><br><span class="line">System.out.println(pred.apply(<span class="string">&quot;StringA&quot;</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="ClassName-new"><a href="#ClassName-new" class="headerlink" title="ClassName::new"></a>ClassName::new</h5><ul>
<li>생성자를 이용하여 객체를 생성하는 람다식<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;String&gt; func = <span class="attr">String:</span>:<span class="keyword">new</span>;</span><br><span class="line">String string = func.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="ClassName-new-1"><a href="#ClassName-new-1" class="headerlink" title="ClassName[]::new"></a>ClassName[]::new</h5><ul>
<li>배열을 생성하는 람다식<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;String[]&gt; func = String[]::<span class="keyword">new</span>;</span><br><span class="line">String [] strings = func.apply(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>


</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/27/Java/JavaAdvanced/Java-LambdaExpression/" data-id="ckfze6ipc002f1ku27vcx19ec" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/27/Java/JavaAdvanced/Java-StreamAPI/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java_StreamAPI
        
      </div>
    </a>
  
  
    <a href="/2020/09/25/Java/Subject/Homework10/GenericList/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Subject_Day10_GenericRect</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/29/Java/JavaAdvanced/Java-Java_langPackage/">Java_Java-lang Package</a>
          </li>
        
          <li>
            <a href="/2020/09/27/Java/JavaAdvanced/Java-StreamAPI/">Java_StreamAPI</a>
          </li>
        
          <li>
            <a href="/2020/09/27/Java/JavaAdvanced/Java-LambdaExpression/">Java_LambdaExpression</a>
          </li>
        
          <li>
            <a href="/2020/09/25/Java/Subject/Homework10/GenericList/">Subject_Day10_GenericRect</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>