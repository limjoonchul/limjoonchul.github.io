<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java_Collections Framework | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="자바 컬렉션 프레임워크(Java Collections Framework)컬렉션 프레임워크란 프로그램 구현에 필요한 자료구조와 알고리즘을 구현해 놓은 라이브러리 개발에 소요되는 시간을 절약하고 최적화된 라이브러리를 사용할 수 있다. java.utils에 속한 일련의 클래스로, 자료구로를 담당 잘 짜여진 인터페이스를 기반으로 다양한 자료구조를 구현한다. 제네릭">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_Collections Framework">
<meta property="og:url" content="https://limjoonchul.github.io/2020/09/08/Java/JavaAdvanced/Java-CollectionFramework/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="자바 컬렉션 프레임워크(Java Collections Framework)컬렉션 프레임워크란 프로그램 구현에 필요한 자료구조와 알고리즘을 구현해 놓은 라이브러리 개발에 소요되는 시간을 절약하고 최적화된 라이브러리를 사용할 수 있다. java.utils에 속한 일련의 클래스로, 자료구로를 담당 잘 짜여진 인터페이스를 기반으로 다양한 자료구조를 구현한다. 제네릭">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://limjoonchul.github.io/2020/09/08/image/%EC%BB%AC%EB%A0%89%EC%85%98%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC.jpg">
<meta property="og:image" content="https://limjoonchul.github.io/2020/09/08/image/map%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4.jpg">
<meta property="article:published_time" content="2020-09-08T10:27:34.729Z">
<meta property="article:modified_time" content="2020-10-11T06:15:58.524Z">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://limjoonchul.github.io/2020/09/08/image/%EC%BB%AC%EB%A0%89%EC%85%98%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java/JavaAdvanced/Java-CollectionFramework" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/08/Java/JavaAdvanced/Java-CollectionFramework/" class="article-date">
  <time datetime="2020-09-08T10:27:34.729Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java_Collections Framework
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="자바-컬렉션-프레임워크-Java-Collections-Framework"><a href="#자바-컬렉션-프레임워크-Java-Collections-Framework" class="headerlink" title="자바 컬렉션 프레임워크(Java Collections Framework)"></a>자바 컬렉션 프레임워크(Java Collections Framework)</h1><h2 id="컬렉션-프레임워크란"><a href="#컬렉션-프레임워크란" class="headerlink" title="컬렉션 프레임워크란"></a>컬렉션 프레임워크란</h2><ul>
<li>프로그램 구현에 필요한 자료구조와 알고리즘을 구현해 놓은 라이브러리</li>
<li>개발에 소요되는 시간을 절약하고 최적화된 라이브러리를 사용할 수 있다.</li>
<li>java.utils에 속한 일련의 클래스로, 자료구로를 담당</li>
<li>잘 짜여진 인터페이스를 기반으로 다양한 자료구조를 구현한다.</li>
<li>제네릭 클래스로 되어 있어, 다양한 객체를 요소로 담을 수 있다.</li>
<li>Collection 인터페이스와 Map 인터페이스로 구성된다</li>
<li>자료구조를 담당하는 API라고 할 수 있다.</li>
<li>인터페이스가 상속이되서 클래스에서 구현이된다. 비슷한 구조가 자료구조쪽에도 있는데 추상자료형(abstract data type)이라는게 있다.<br>이걸 실제로 코드 같은 것으로 특정한 요소들까지 구현을 하면 자료구조(DS, data structure)라고 부른다.<ul>
<li>추상 자료형은 어떤 자료구조 같은 특정 자료형이 어떤 기능들을 가지고 있는지 어떤 메소드들을 가지고 있는지 메소도들의 행동이 어떤지 정의하는 것이다.</li>
<li>요소: 자료구조를 구성하는 하나하나의 자료<h3 id="자료-구조와-알고리즘"><a href="#자료-구조와-알고리즘" class="headerlink" title="자료 구조와 알고리즘"></a>자료 구조와 알고리즘</h3></li>
</ul>
</li>
<li>메모리 위에 데이터들이 있는데 데이터들을 어떤 구조로 관리를 할 것이냐<br>어떤 구조로 데이터를 관리했을 때 가장 효율적인 알고리즘을 적용해서 수행능력이 잘 나고 효율적으로 시스템이 돌아갈 수 있게 하느냐 이다.</li>
<li>자료구조와 알고리즘은 수행속도나 최적의 솔루션을 찾는 것이 평가기준이 된다.</li>
<li>자료구조 <ul>
<li>자료의 집합 또는 그 집합의 동작을 정의하는 수학적 모델</li>
<li>자료가 어떻게 모여있는지 모여있는 자료에 대해 동작을 정의하는거 sort나 w자료의 입력이나 제거</li>
<li>두개의 자료의 자리를 바꾸는 것 등등 맵 셋 등등이 동작에 해당한다.</li>
</ul>
</li>
</ul>
<h2 id="JCF-인터페이스"><a href="#JCF-인터페이스" class="headerlink" title="JCF 인터페이스"></a>JCF 인터페이스</h2><h3 id="Collection-인터페이스"><a href="#Collection-인터페이스" class="headerlink" title="Collection 인터페이스"></a>Collection 인터페이스</h3><ul>
<li>Collection 인터페이스는 하나의 객체에 대한 자료구조이다. 딱 하나씩을 어떻게 관리할 것이냐 이다.</li>
<li>하나의 객체의 관리를 위해 선언된 인터페이스로 필요한 기본 메서드가 선언되어 있다.</li>
<li>Collection 인터페이스 하위에 list인터페이스, set인터페이스가 있는데 여기에 많은 클래스들이 있다.<ul>
<li>List 인터페이스와 Set 인터페이스는 제네릭 클래스로 되어있다. </li>
<li>자료들을 효율적으로 다루기 위한 것이다.이 하나 하나가 정수일 것이냐 아니면 클래스의 인스턴스인 객체일 것이냐</li>
<li>이런 것 들을 제네릭으로 되어있으면 우리가 선택을 할 수 있다. 정수면 Integer을 사용할 수 있는 등 선택을 할 수 있다.</li>
</ul>
</li>
</ul>
<p><img src="../../../image/%EC%BB%AC%EB%A0%89%EC%85%98%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC.jpg" alt="collection"></p>
<ul>
<li>Collection 인터페이스의 주요 메소드</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>요소 e를 컬렉션에 추가한다.</td>
</tr>
<tr>
<td>boolean addAll(Collection &lt; ? extends E &gt; c)</td>
<td>다른 컬렉션 c의 모든 요소를 컬렉션에 추가한다.</td>
</tr>
<tr>
<td>void clear()</td>
<td>컬렉션의 모든 요소를 제거한다.</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>컬렉션에 요소 o가 존재하는지 확인한다.</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c)</td>
<td>컬렉션 c의 모든 요소가 컬렉션에 포함되는지 확인한다.</td>
</tr>
<tr>
<td>boolean equals(Object o)</td>
<td>컬렉션 o와 같은 내용을 포함하는지 비교한다.</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>컬렉션이 비어있는지 확인한다.</td>
</tr>
<tr>
<td>Iterator<E> iterator()</td>
<td>컬렉션의 Iterator를 반환한다.</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>컬렉션에서 요소 o를 제거한다.</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td>컬렉션 c에 속한 모든 요소를 컬렉션에서 제거한다.</td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c)</td>
<td>컬렉션 c에 포함된 객체만 남기고 나머지 요소를 제거한다.</td>
</tr>
<tr>
<td>int size()</td>
<td>컬렉션에 속한 요소의 개수를 반환한다.</td>
</tr>
<tr>
<td>T[] toArray(T[] a)</td>
<td>컬렉션의 요소들을 T[] 배열로 반환한다.</td>
</tr>
</tbody></table>
<ul>
<li><p>remove() - 요소를 제거하는것이다, 요소는 element이다.</p>
<ul>
<li>여러개 데이터를 묶은게 컬렉션인데 이 하나 하나가 element, 요소이다.</li>
</ul>
</li>
<li><p>iterator - 컬렉션에 데이터가 있을 때 순회하기 위한 인터페이스</p>
</li>
<li><p>Iterator</p>
<ul>
<li><p><code>iterator()</code> 로 반환되는 객체로, Collection에 저장된 요소에 접근하기 위해 사용</p>
</li>
<li><p>컬렉션 자료들을 묶어놨을 때 자료 하나 하나에 접근하고 싶을 때 iterator</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>다음 요소가 있는지 확인</td>
</tr>
<tr>
<td>E next()</td>
<td>다음 요소가 있을 경우, 요소 값 반환</td>
</tr>
<tr>
<td>void remove()</td>
<td>현재 위치의 요소를 삭제</td>
</tr>
</tbody></table>
<ul>
<li>hasNext()로 다음 요소가 있는지 확인하고 next()로 다음 요소를 반환한다.<br>컬렉션에 있는 자료를 쭉 순회하는 방법이다.</li>
</ul>
</li>
<li><p>Iterator의 활용</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iter = collection.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    String string = iter.next();</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String <span class="attr">string:</span> collection) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreach 문에서 바로 출력이 가능 하게 할 수 있다.<br>while문에서 값을 변수에 넣었다가 출력하는 부분을 줄일 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li><p>Collection 인터페이스에 add()메서드와 List 인터페이스 add()메이서드는 출력값하고<br>입력파라미터가 다른데 오버라딩한 경우이다.</p>
</li>
</ul>
<h3 id="List-인터페이스"><a href="#List-인터페이스" class="headerlink" title="List 인터페이스"></a>List 인터페이스</h3><ul>
<li><p>Collection 인터페이스를 상속 받았으며, 추가 메소드가 구현되어 있다.</p>
</li>
<li><p>순서가 있는 데이터의 집합으로, 인덱스를 이용해 요소를 구분할 수 있어 데이터의 중복을 허용</p>
</li>
<li><p>순서가 있기 때문에 순서로 데이터가 정의 되어서 동일한 데이터가 여러 개 있더라도<br>순서가 다르면 다른 데이터로 인식 데이터 그래서 데이터 중복을 허용한다.</p>
</li>
<li><p>list는 ADT에 해당하고, Collection 인터페이스를 기본으로하고 있다.</p>
</li>
<li><p>구현체: ArrayList, LinkedList(Vector,Stack 잘 사용x, 1.5버전 이전에 사용)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 가장 많이 쓰이는, 배열 기반의 리스트</span></span><br><span class="line">List&lt;String&gt; stringList2 = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 노드의 연결로 구성된 리스트 자료를 하나 넣을 때 노드형태로 넣는다</span></span><br><span class="line"><span class="comment">// 양방향이어서 앞의 노드와 뒤의 노드를 기리킨다.</span></span><br><span class="line">List&lt;String&gt; stringList3 = <span class="keyword">new</span> Vector&lt;&gt;(); <span class="comment">// 싱크로나이즈드 - 멀티스레드 환경에서 안전하게 동작하게 되어있는 것, 무지 느리다( 잘 안쓴다)</span></span><br><span class="line">List&lt;String&gt; stringList4 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// Stack 자료구조 구현 -&gt; 자료구조 때 봅시다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Stack 대신에 ArrayList를 많이 씀</p>
</li>
<li><p>Vector는 제네릭이 아니고 오브젝트를 받게 되어있다. ArrayList와 동기화 부분만 다르다.<br>구현 자체는 둘다 Array로 되어있다. 제네릭이 없기 때문에 오브젝트로 되어 있다.<br>내부 구현은 완전히 같은지는 모른다. 비슷한 구조이긴 하다</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, E element)</td>
<td>index 위치에 요소 element를 삽입한다.</td>
</tr>
<tr>
<td>boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td>index위치부터 컬렉션 c의 모든 요소를 추가 한다.</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>index 위치에 저장된 요소를 반환한다.</td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td>객체 o가 저장된 첫번째 인덱스를 반환한다. 없을 경우 -1을 반환한다.</td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td>객체 o가 저장된 마지막 인덱스를 반환한다. 없을 경우 -1을 반환한다.</td>
</tr>
<tr>
<td>ListIterator<E> listIterator()</td>
<td>ListIterator 객체를 반환한다.</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>index에 위치한 객체를 제거하고 반환한다.</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>index에 위치한 요소를 element로 대체한다.</td>
</tr>
<tr>
<td>List<E> subList(int fromIndex, int toIndex)</td>
<td>fromIndex에 위치한 요소부터 toIndex의 직전에 위치한 요소까지 포함한 List를 반환한다.</td>
</tr>
</tbody></table>
<ul>
<li>add()<ul>
<li>2번에 새로운 값이 들어가면 2번부터 뒤에 값들이 한칸씩 뒤로 밀린다.<br>e라는 요소를 찾기위해서 동일한 요소로 찾는다는 것은 있을 수 없다.<br>컬렉션에는 일반적으로 특정 요소를 리턴받는게 없다.<br>리스트에는 인덱스를 이용해 요소를 구분할 수 있기 때문에 특정 요소를 반환 받을 수 있다.<br>그래서 순서가 있는것이 매우 유용하다.(장점이자 단점)</li>
</ul>
</li>
<li>remove() : 꺼내서 쓴다라는 의미로 받아 들일 수 있다.</li>
<li>add()와 달리 set()은 특정 인덱스의 값만 대체한다. 한자리만 데이터를 대체한다.<br>sublist는 fromindex부터 toindex까지라할 때 toindex직전까지만 포함한다. (toindex는 포함 x)</li>
</ul>
<ul>
<li>오버헤드(Overhead) <ul>
<li>어떤동작을 하기위해서 들어가는 우리가 하고자하는 동작이 있을 때<br>부수적으로 발생하는 추가적인 계산이나, 추가적으로 메모리를 사용한다던지 이런 것들을 오버헤드라고 말한다.</li>
</ul>
</li>
</ul>
<ul>
<li><p>List 인터페이스의 구현체</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 동일 인터페이스로 다른 구현체를 사용 가능</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>ArrayList&lt;E&gt;</code></p>
<ul>
<li>제네릭 클래스로 구현된 자료구조</li>
<li>배열을 기반으로 구현된 클래스로, 가장 자주 활용되며 활용도가 높다.</li>
<li>ArrayList의 생성자는 세 종류가 주어진다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList()</span><br><span class="line"><span class="keyword">public</span> Arraylist(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="keyword">public</span> ArrayList(Collection&lt;? extends E&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li>Arraylist () 생성자는 내부적으로 grow()라는 메소드가 내재되어있다.<br>배열의 크기를 입력을 받으면 배열을 키우기 위해 오버헤드가 발생하는데 이정도의 크기를 미리 정해줌<br>initalcopacity를 입력 받는 것이다</li>
</ul>
</li>
</ul>
</li>
<li><p>LinkedList<E></p>
<ul>
<li><p>제네릭 클래스로 구현된 자료구조</p>
</li>
<li><p>연결리스트를 기반으로 구현된 클래스로, 배열의 단점을 극복하기 위한 구현체</p>
</li>
<li><p>ArrayList vs. LinkedList</p>
<table>
<thead>
<tr>
<th>구현체</th>
<th>순차 추가/수정/삭제</th>
<th>비순차 추가/수정/삭제</th>
<th>조회</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>빠름</td>
<td>느림</td>
<td>빠름</td>
</tr>
<tr>
<td>LinkedList</td>
<td>느림</td>
<td>빠름</td>
<td>느림</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>ArrayList, LinkedList</p>
<ul>
<li>Object를 요소로 가지는 List 구현체 (Java5 이전)</li>
<li>링크드 리스트의 조회는 인덱스들을 타고 타고 들어가야 해서 느리다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">       List&lt;Integer&gt; intList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">       for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">           intList.add(i); &#x2F;&#x2F; List의 맨 뒤에 자료를 추가한다.</span><br><span class="line">                           &#x2F;&#x2F; List는 맨 뒤에 자료 추가(순차 처리)가 가장 빠르다.</span><br><span class="line">                           &#x2F;&#x2F; o(1) 뒤에 하나하나넣으니 앞에서 넣는건 o(n) 그래서 뒤에 넣는게 더 빠르다.</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       System.out.println(intList.size()); &#x2F;&#x2F;intList의 길이를 나타내준다.</span><br><span class="line">       intList.add(2,678493); &#x2F;&#x2F;  인덱스에 해당하는 위치에 값을 넣게되고 그위치에있던 값들은 뒤로 밀림</span><br><span class="line">       &#x2F;&#x2F; 중간 index에 add할 경우 자료를 뒤로 한칸씩 민다.</span><br><span class="line">       List&lt;Integer&gt; intList2 &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">       for (int i &#x3D; 5; i &lt; 10; i++) &#123;</span><br><span class="line">          intList2.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(intList2);</span><br><span class="line">  </span><br><span class="line">       &#x2F;&#x2F; 입력된 컬렉션 내용 전체를 한번에 add하는 메소드</span><br><span class="line">       &#x2F;&#x2F; index를 입력받아 위치도 지정 가능.</span><br><span class="line">       intList.addAll(intList2); &#x2F;&#x2F;컬렉션에 있느낸용을 통째로 집어넣는것이다</span><br><span class="line">       System.out.println(&quot;ind 3: &quot; + intList.get(3)); &#x2F;&#x2F; 인덱스의 값을 가져올 수 있다.</span><br><span class="line">       System.out.println(intList.indexOf(9)); &#x2F;&#x2F;객체를 입력해서 리스트의 어느 위치에 있는지 리턴해준다</span><br><span class="line">       &#x2F;&#x2F; 객체를 찾아 가장 첫번째 인덱스를 반환한다.</span><br><span class="line">       </span><br><span class="line">       System.out.println(intList.lastIndexOf(9)); &#x2F;&#x2F; 객체를 찾아 가장 마지막 인덱스를 리턴한다.</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; remove()메소드는 index에서 obj를 제거하고 그것을 반환한다.</span><br><span class="line">       &#x2F;&#x2F; 요소가 제거되면, 그 뒤 요소들은 모두 index가 하나씩 앞으로 당겨진다. 중간이 비어있지 않는다.(순서가 있기 때문에 빈칸이 있을 수 없다)</span><br><span class="line">       System.out.println(&quot;index 9 was: &quot;+ intList.remove(9)); &#x2F;&#x2F; 인덱스를 입력해서 해당 인덱스의 값을 &#96;제거하고&#96; 반환해준다.</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 배열처럼 index의 값을 value로 대체한다.</span><br><span class="line">       intList.set(1,100); &#x2F;&#x2F; 인덱스의 위치의 값을 입력받는 값으로 대체한다</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 앞에껀 inclusive, 뒤는 exclusive 2번 인덱스 에서 4번 인덱스까지 가져옴</span><br><span class="line">       List&lt;Integer&gt; list3 &#x3D; intList.subList(2,5);</span><br><span class="line">  </span><br><span class="line">       &#x2F;&#x2F; fori를 이용한 접근</span><br><span class="line">       for (int i &#x3D; 0; i &lt; list3.size(); i++) &#123;</span><br><span class="line">           System.out.println(list3.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; foreach를 이용한 접근</span><br><span class="line">       for (int value: list3) &#123;</span><br><span class="line">           System.out.println(value);</span><br><span class="line">       &#125;</span><br><span class="line">     &#96;&#96;&#96;&#96;     </span><br><span class="line">          </span><br><span class="line">* List의 정렬</span><br><span class="line">  * Collections 클래스의 sort() 메소드 사용</span><br><span class="line">     * public static &lt;T extends Comparable&lt;? super T&gt; void sort(List&lt;T&gt; list)</span><br><span class="line">        * 객체에 선언된 public int compareTo(T t) 메소드로 비교하여 정렬</span><br><span class="line">     * public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</span><br><span class="line">        * Comparator 객체 c에 정의된 public int compare(T o1, T o2) 메소드로 비교하여 정렬</span><br><span class="line"></span><br><span class="line">* ListIterator</span><br><span class="line">  * listIterator()로 반환되는 객체로, 양방향 사용이 가능</span><br><span class="line">  * listiterator는 listiterator()로 반환하는 객체, 양방향 사용이 가능하다.</span><br><span class="line">    순서가 있어서 previous도 가능함  앞으로도가고 뒤로도 가는게 가능함</span><br><span class="line">  * Iterator를 상속받은 클래스</span><br><span class="line">  </span><br><span class="line">  | 메소드 |    설명 |</span><br><span class="line">  | ----- | ---- |</span><br><span class="line">  | boolean hasPrevious() |    이전 요소가 있는지 확인 |</span><br><span class="line">  | E previous() | 이전 요소가 있을 경우 반환 |</span><br><span class="line">    *  linkedlist 앞뒤의 주소를 가리킬수있다.</span><br><span class="line">      노드 형태로 되어 있다. 그래프에서 사용하는 용어로 데이터 하나하나가 떨어져 있다.</span><br><span class="line">      떨어져 있는 것의 previous와 next가 있어서 이전순서와 뒤순서를 참조하게 된다.</span><br><span class="line">      이런 것들(previous와 next)이 오버헤드가 된다. </span><br><span class="line">      배열의 단점(중간에있는 데이터를 추가제거 할 때 밀거나 당겨야 하는 것)을 보완하기 위해서 나타남</span><br><span class="line">      </span><br><span class="line">&#96;&#96;&#96;groovy</span><br><span class="line">&#x2F;&#x2F; listIterator를 이용한 접근 - foreach문은 사실 이것을 짧게 쓴 것</span><br><span class="line">ListIterator&lt;Integer&gt; iter &#x3D; list3.listIterator(); &#x2F;&#x2F;iterator에 스트림처럼 값이 담겨져있다.</span><br><span class="line">&#x2F;&#x2F; 다만 값을 복사해오지 않는다 원본 컬렉션에 잇는 자료를 그대로 가져오는 역할을 한다.</span><br><span class="line">&#x2F;&#x2F; 스트림 api는 원본을 보존한다.</span><br><span class="line">while (iter.hasNext())&#123;&#x2F;&#x2F; true일 때만 다음 요소가 있음</span><br><span class="line">   Integer integer &#x3D; iter.next(); &#x2F;&#x2F; 다음 요소를 반환. 값을 가져오는데 더가져오지않으면 exceptiio이 발생한다</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Set-인터페이스"><a href="#Set-인터페이스" class="headerlink" title="Set 인터페이스"></a>Set 인터페이스</h3><ul>
<li>Collection 인터페이스를 상속 받아 메소드를 구현하고 있다.</li>
<li>순서가 없는 데이터의 집합으로,말그대로 집합이다. 데이터의 중복을 허용하지 않는다.</li>
<li>순서가 없기 때문에 데이터 중복 x 데이터가 있는 상태에서 동일한 값이 들어오면<br> 오류가 나는게 아니고 무시를 한다. 중복되는 개체를 없애고 유니크한 개체만 남긴다. </li>
<li>구현체는 hashset 일반적인 집합, treeset은 이진트리를 기반으로 하는 재밌는 특성을 가진 자료구조</li>
</ul>
<ul>
<li><p>Set의 구현체</p>
<ul>
<li>HashSet<E><ul>
<li>Set의 대표적인 구현체로, 기본적인 기능이 구현되어 있다.</li>
<li>많이 사용이 됨 객체의 해쉬값을 이용해서 객체들을 구분하는 자료 구조<br>해쉬 값만으로 구분하는게 아니라 이용해서 빠르게 동작을 한다.</li>
</ul>
</li>
<li>TreeSet<E><ul>
<li>NavigableSet<E> 인터페이스를 구현하며, 이진 탐색 트리 자료 구조이다.</li>
<li>객체를 삽입하는 동시에 정렬되는 특성상 비교가 가능해야 한다.</li>
<li>객체의 정렬에 사용되는 클래스</li>
<li>중복을 허용하지 않으면서 오름차순이나 내림차순으로 객체를 정렬함</li>
<li>내부적으로 이진 탐색 트리로 구현되어 있다. 이진 탐색 트리에 자료가 저장될 때 비교하여 저장될 위치를 정한다.</li>
<li>객체를 비교하기 위해 Comparable이나 Comparator 인터페이스를 구현 해야 한다.</li>
</ul>
</li>
<li>이진 탐색 트리<ul>
<li>부모 하위에 자식이 두개거나 작은 값들이다. BST는 바이너리트리의 약자 데이터가 중복해서 들어갈 수 없다. </li>
<li>항상 데이터를 넣을 때 비교해서 비교조건에 의해서 작은건 왼쪽 큰건 오른쪽사이드에 들어감</li>
<li>10이 중심일 때  작은 4,5,8은 다 왼쪽사이드에 큰 11,13,15는 오른쪽 사이드에 들어간다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeSet() <span class="comment">// Comparable 구현체의 경우</span></span><br><span class="line"><span class="keyword">public</span> TreeSet(Comparator&lt;? super E&gt; comparator) <span class="comment">// 별도로 비교 객체 삽입</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>TreeSet의 메소드</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>public E first()</td>
<td>정렬된 첫 요소를 반환</td>
</tr>
<tr>
<td>public E last()</td>
<td>정렬된 마지막 요소를 반환</td>
</tr>
<tr>
<td>public E lower(E e)</td>
<td>e 객체의 바로 이전 객체를 반환</td>
</tr>
<tr>
<td>public E higher(E e)</td>
<td>e 객체의 바로 다음 객체를 반환</td>
</tr>
<tr>
<td>public E floor(E e)</td>
<td>e 또는 e 보다 이전 객체를 반환</td>
</tr>
<tr>
<td>public E ceiling(E e)</td>
<td>e 또는 e 보다 이후 객체를 반환</td>
</tr>
<tr>
<td>public E pollFirst()</td>
<td>정렬된 첫 요소를 제거하고 반환</td>
</tr>
<tr>
<td>public E pollLast()</td>
<td>정렬된 마지막 요소를 제거하고 반환</td>
</tr>
<tr>
<td>public NavigableSet<E> descendingSet()</td>
<td>내림차순으로 정렬하는 객체를 반환</td>
</tr>
<tr>
<td>public NavigableSet<E> headSet(E toElement, boolean inclusive)</td>
<td>toElement 이전 요소로 구성된 객체 반환</td>
</tr>
<tr>
<td>public NavigableSet<E> tailSet(E fromElement, boolean inclusive)</td>
<td>fromElement 이후 요소로 구성된 객체 반환</td>
</tr>
<tr>
<td>public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)</td>
<td>fromElement 이후, toElement 이전 요소로 구성된 객체 반환</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; stringSet1 = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 기본적인 집합</span></span><br><span class="line">stringSet1.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">stringSet1.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">stringSet1.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">stringSet1.add(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">System.out.println(stringSet1);</span><br><span class="line"><span class="comment">// List에 있는것 중 중복되는 것을 제거하고싶을 때</span></span><br><span class="line"><span class="comment">// 이중 for문을 이용해서 모두 비교해서 같은게 있으면 삭제한다 O(n^2)</span></span><br><span class="line"><span class="comment">// Set을 이용하면 List에 있는걸 Set으로 한번씩만 옮기면 중복이 제거가 된다.</span></span><br><span class="line"><span class="comment">// 1중 for문을 이용해서 비교할 필요 없이 알아서 삭제 됨 O(n)</span></span><br><span class="line"></span><br><span class="line">NavigableSet&lt;String&gt; stringSet2 = <span class="keyword">new</span> TreeSet&lt;&gt;(); <span class="comment">// 이진 탐색 트리</span></span><br><span class="line"><span class="comment">// 정렬을 자동으로 해주는 기능이 있다.</span></span><br><span class="line"><span class="comment">// 네비게이블셋으로 받아주면 모든 기능을 받을 수 있고</span></span><br><span class="line"><span class="comment">// 셋으로 받으면 모든 기능을 받지 못함 셋이 네비게이션셋의 부모여서</span></span><br><span class="line"><span class="comment">// 네비게이션셋에 정의되어있는건 셋에서 사용못함</span></span><br><span class="line"><span class="comment">// 자료를 넣어놓고 내가원하는 자료를 빨리 찾고싶을 때 사용한다.</span></span><br><span class="line"><span class="comment">// 들어오는 값을 Comparable 한던지, Comparator를 구현해서 넣어주던지 해야한다</span></span><br><span class="line"><span class="comment">// 값이 어떤것이 더 큰지 판단해서 정렬해서 넣어줄 수 있다 - 이진 탐색 트리</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Foo(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="string">&quot;, &quot;</span>+ y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NavigableSet&lt;Foo&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(Comparator.comparingInt(o -&gt; o.x));</span><br><span class="line"><span class="comment">// 자동으로 소팅이되서 값이 들어가게 된다 따로 소팅할 필요 없음</span></span><br><span class="line"><span class="comment">// 여기서 x를 비교해서 넣게 구현해놨음</span></span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> Foo(<span class="number">1</span>,<span class="number">100</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Foo(<span class="number">4</span>,<span class="number">50</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Foo(<span class="number">0</span>,<span class="number">170</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Foo(<span class="number">-2</span>,<span class="number">3300</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(set.first()); <span class="comment">// 정렬된것중 가장 첫번째 요소가 출력됨</span></span><br><span class="line">System.out.println(set.last()); <span class="comment">// 정렬된것중 가장 마지막번째 요소가 출력됨</span></span><br><span class="line">System.out.println(set.lower(<span class="keyword">new</span> Foo(<span class="number">1</span>,<span class="number">500</span>)));</span><br><span class="line"><span class="comment">// 1보다 작은 값을 찾는다 1가없어도 작은 값을 찾는다? 이거보다 하나 작은걸 찾아서 반환한다.</span></span><br><span class="line"></span><br><span class="line">System.out.println(set.higher(<span class="keyword">new</span> Foo(<span class="number">2</span>,<span class="number">500</span>)));</span><br><span class="line"><span class="comment">// 2보다 하나 큰 거를 반환</span></span><br><span class="line"></span><br><span class="line">System.out.println(set.floor(<span class="keyword">new</span> Foo(<span class="number">1</span>,<span class="number">500</span>)));</span><br><span class="line"><span class="comment">// floor는 같은 값이 있으면 같은 값을 반환해준다 lower는 하나 작은걸 반환</span></span><br><span class="line"></span><br><span class="line">System.out.println(set.ceiling(<span class="keyword">new</span> Foo(<span class="number">1</span>,<span class="number">500</span>)));</span><br><span class="line"><span class="comment">// ceiling도 같은게 있으면 같은 값을 반환해주고 없으면 위에거반환</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// poll은 셋에서 삭제도 같이한다. 처음거를 가져오는데 처음걸 가져오면서 삭제한다.</span></span><br><span class="line"><span class="comment">// 더 지울게 없으면 null이 나온다. 보통 객체를 반환할 때 없으면 null이나오고 자연수는 -1이 반환</span></span><br><span class="line">System.out.println(set.pollFirst());</span><br><span class="line">System.out.println(set.pollFirst());</span><br><span class="line">System.out.println(set.pollFirst());</span><br><span class="line"><span class="comment">// log n - 원래는 일자로 0-0-0-0-0 이렇게 되어있는걸 이진탐색트리 그림처럼</span></span><br><span class="line"><span class="comment">// 일자가 logn 이라면 이진탐색트리는 log2 n 이된다 선택에 의해서 더 짧은 길이를 가게 된다</span></span><br></pre></td></tr></table></figure>

<h4 id="Comparable-인터페이스와-Comparator-인터페이스"><a href="#Comparable-인터페이스와-Comparator-인터페이스" class="headerlink" title="Comparable 인터페이스와 Comparator 인터페이스"></a>Comparable 인터페이스와 Comparator 인터페이스</h4><ul>
<li>정렬 대상이 되는 클래스가 구현해야하는 인터페이스 </li>
<li>Comparable 은 compareTo() 메소들 구현해야하고 객체 자신(this)와 매개변수를 비교해야 한다.</li>
<li>Comparator는 compare() 메소드를 구현<ul>
<li>TreeSet 생성자에 Comparator 가 구현된 객체를 매개변수로 전달</li>
<li>TreeSet<Member> treeSet = new TreeSet<Member>(new Member());</li>
</ul>
</li>
<li>이미 Comparable 이 구현된 경우 Comparator을 이용하여 다른 정렬 방식을 정의할 수 있다.<ul>
<li>new Member() 이걸 넣어줘서 이 클래스의 compare()메소드로 구현을 하겠다라고 선언을 해준다. <h3 id="Map-인터페이스"><a href="#Map-인터페이스" class="headerlink" title="Map 인터페이스"></a>Map 인터페이스</h3></li>
</ul>
</li>
</ul>
<p><img src="../../../image/map%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4.jpg" alt="Map"></p>
<ul>
<li>Map은 ADT Map이라는 이름으로 인터페이스를 갖고 있는 것, Hash는 DS이다.</li>
<li>Key-Value 쌍으로 이루어진 데이터의 집합<ul>
<li>key는 유일 해야 한다. 중복될 수 없다. 검색을 위한 자료구조이다.</li>
<li>key를 이용하여 값을 저장하거나 검색, 삭제할 때 사용하면 편리하다.</li>
<li>데이터를 저장할 때 키 Value 쌍으로 저장하는데, Key를 검색해서 Value 쌍을 찾아 낼 수 있다.</li>
</ul>
</li>
<li>구현체 : HashMap, TreeMap, HashTable, Properties</li>
<li>내부적으로 hash방식으로 구현 된다.<ul>
<li>hash은 여러 언어에서 구현된 라이브러리들이 있다. 자료를 쌍으로 관리해야 할 일들이 종종있다.</li>
</ul>
</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><ul>
<li><p>hash는 검색을 위한 자료구조이다. hash(key)처럼 해쉬함수에 key에 해당하는 값을 주면 위치를 반환해준다.</p>
</li>
<li><p>해쉬테이블 - 키를 주면 메모리가 있으면 몇번째에 집어넣어라하는 인덱스를 알려준다.</p>
</li>
<li><p>해쉬 함수가 산술 연산이 되기 때문에 굉장히 빠르다. 산술 연산은 검색에 대한 속도가 굉장히 빨라서 검색에 사용이 된다.</p>
</li>
<li><p>예)<br>극장에 좌석이 0<del>99까지 있는데 표를 300장을 팔았다 1</del>300까지 15번이 영화를 보러왔다하면<br>자리가 100개여서 나머지연산을 써서 15%100으로해서 15번째에 앉힌다<br>115은 115%100으로 해서 나머지가 15 여서 같은자리가 앉아있다 이래서<br>콜리전이 발생한다 충돌이 발생한다 라고한다<br>해쉬테이블은 이렇게 사용하는 것이다? 나머지연산으로쓰는것을 해쉬함수라고 한다.–&gt; 먼소리야<br>해쉬테이블은 꽉차게 쓰지 않는다 해쉬셋 해쉬맵이라는 자료구조를 배우는데 다 해쉬구조로되어있음<br>약 75%차면 해쉬테이블을 뻥튀기 시킨다.</p>
</li>
</ul>
<h4 id="HashMap-클래스"><a href="#HashMap-클래스" class="headerlink" title="HashMap 클래스"></a>HashMap 클래스</h4><ul>
<li><p>Map 인터페이스를 구현한 클래스 중 가장 일반적으로 사용하는 클래스</p>
</li>
<li><p>HashTable 클래스는 자바2부터 제공된 클래스로 vector 처럼 동기화를 제공함 pair 자료를<br>쉽고 빠르게 관리할 수 있음</p>
</li>
<li><p>해쉬테이블을 많이 사용했지만 이제는 해쉬맵 클래스를 사용하면 됨 </p>
</li>
<li><p>keySet() - 모든 key객체를 반환해준다. 중복이 안되므로 set타입으로 반환</p>
</li>
<li><p>key.Set().iterator()는 iterator객체가 key로 순환을 한다.</p>
</li>
<li><p>values() - 모든 value를 반환해준다. 중복될 수 있어서 collection으로 반환</p>
</li>
<li><p>values().iterator() -value를 쭉 순환하면서 반환한다.</p>
</li>
</ul>
<h4 id="TreeMap클래스"><a href="#TreeMap클래스" class="headerlink" title="TreeMap클래스"></a>TreeMap클래스</h4><ul>
<li>key 객체를 정렬하여 key-value를 pair로 관리하는 클래스</li>
<li>key에 사용되는 클래스에 comparable, comparator 인터페이스를 구현</li>
<li>java에 많은 클래스들은 이미 comparable이 구현되어 있다,</li>
<li>구현된 클래스를 key로 사용하는 경우는 구현할 필요 없음(Integer, String)<br>만약에 그렇지 않고 다른 클래스들이 사용한다하며 key에 대한 인터페이스 비교하는 방법을 구현을 해야 한다!!</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// NavigableMap&lt;String, Integer&gt; map2 = new TreeMap&lt;&gt;(); // 트리셋과 비슷함</span></span><br><span class="line"><span class="comment">// 키를 기준으로봤을 때 맵이랑 셋이 거의 비슷하다.</span></span><br><span class="line"><span class="comment">// 해쉬가 비교대상이 되고 벨류가 붙여서 이루어진다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// put은 기존에 동일 키 값이 있었으면 기존 value를 반환, 없었으면 null</span></span><br><span class="line">System.out.println(map.put(<span class="string">&quot;ABCDE&quot;</span>,<span class="number">5</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(map.put(<span class="string">&quot;CDEF&quot;</span>,<span class="number">1023</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(map.put(<span class="string">&quot;ABCDE&quot;</span>,<span class="number">1023</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">System.out.println(map.get(<span class="string">&quot;CDEF&quot;</span>)); <span class="comment">// 키라는 기준으로 검색을해서 값을 찾아온다 이런걸 쿼리(query,질의)라고 부름</span></span><br><span class="line">System.out.println(map.getOrDefault(<span class="string">&quot;CDEF&quot;</span>,<span class="number">0</span>)); <span class="comment">// 가져올 키가 있으면 기존 값을 가져오고 없으면 defaultValue를 반환</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 이렇게 기존 값이 없을 때 0 등으로 기본 값을 설정하고 싶으면 편리함</span></span><br><span class="line">map.put(<span class="string">&quot;ABCDE&quot;</span>, map.getOrDefault(<span class="string">&quot;ABCDE&quot;</span>,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 값이 있으면 기존 값 +1 알고리즘 할 때 도움이 많이 된다. 꿀팁!!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// keySet 사용 키로 구성된 셋을 받아온다</span></span><br><span class="line"><span class="keyword">for</span> (String <span class="attr">key :</span> map.keySet())&#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot; : &quot;</span>+ map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entrySet 사용 키와 벨류를 같이 받아와서 함 속도가 조금 더 빠름 이게 더 좋은 방법</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; <span class="attr">entry :</span> map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NavigableMap&lt;String, Integer&gt; map2 = <span class="keyword">new</span> TreeMap&lt;&gt;(); <span class="comment">//Comparator를 구현해서 넣어주면 된다 비교할 때</span></span><br><span class="line">map2.put(<span class="string">&quot;a&quot;</span>,<span class="number">10</span>);</span><br><span class="line">map2.put(<span class="string">&quot;g&quot;</span>,<span class="number">12</span>);</span><br><span class="line">map2.put(<span class="string">&quot;z&quot;</span>,<span class="number">14</span>);</span><br><span class="line">map2.put(<span class="string">&quot;z&quot;</span>,<span class="number">114</span>);</span><br><span class="line">map2.put(<span class="string">&quot;c&quot;</span>,<span class="number">165</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(map2.ceilingKey(<span class="string">&quot;b&quot;</span>)); <span class="comment">//b보다 큰것 키 값만 반환</span></span><br><span class="line">System.out.println(map2.ceilingEntry(<span class="string">&quot;b&quot;</span>).getValue());<span class="comment">// 엔트리 전체를 받아와서 value를 찾는다.</span></span><br><span class="line">System.out.println(map2.pollFirstEntry().getValue());</span><br><span class="line">System.out.println(map2.pollFirstEntry().getValue());</span><br><span class="line">System.out.println(map2.pollFirstEntry().getValue());</span><br><span class="line">System.out.println(map2.pollFirstEntry().getValue());</span><br><span class="line"><span class="comment">// 메모리상에서도 삭제한다 값을 삭제</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 중복이 허용되지 않아서 값을 뒤에 넣은 값으로 넣어서 출력이됨</span></span><br><span class="line">System.out.println(map2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 번외로 알아두세요</span></span><br><span class="line">Map&lt;String,Integer&gt; map3 = <span class="keyword">new</span> Hashtable&lt;&gt;(); <span class="comment">// Vector처럼 옛날 구현 싱크로나이즈드</span></span><br><span class="line">Properties prop = <span class="keyword">new</span> Properties(); <span class="comment">// 해쉬테이블&lt;String,String&gt; 을 상속하고 있다.</span></span><br><span class="line">System.getProperties(); <span class="comment">// System의 property가 이 형식으로 제공됨.</span></span><br></pre></td></tr></table></figure>




















      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/08/Java/JavaAdvanced/Java-CollectionFramework/" data-id="ckgeuesax002gbsu2a43677e2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/09/Java/PreCourseEx/ClassEx3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          PreCourse-Singleton_patternEx
        
      </div>
    </a>
  
  
    <a href="/2020/09/08/Java/JavaAdvanced/Java-Variable/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java_Variable</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/18/Java/SW_Enginerring/DesignPatterns/">SW_Enginerring-DesignPatterns</a>
          </li>
        
          <li>
            <a href="/2020/10/18/Java/JavaAdvanced/Java-Annotations/">Java_Annotations</a>
          </li>
        
          <li>
            <a href="/2020/10/10/Java/JavaAdvanced/Java-Stream_TerminalOperations/">Java_Stream-최종 처리 메소드(최종 연산자)</a>
          </li>
        
          <li>
            <a href="/2020/10/10/Java/JavaAdvanced/Java-Stream_IntermediateOperations/">Java_Stream-중간 처리 메소드(중간 연산자)</a>
          </li>
        
          <li>
            <a href="/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>