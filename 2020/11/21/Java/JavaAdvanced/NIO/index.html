<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java_NIO | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="NIO(New Input Output)NIO 의 특징 채널을 이용해서 입&#x2F;출력을 모두 처리한다.(동시에 처리하는 것은 안된다)  IO와 달리 기본적으로 버퍼를 사용한다.  NIO는 Blocking 및 Nonblocking을 모두 지원한다.  Non-blocking은 비동기식으로 읽기&#x2F;쓰기를 시켜놓고 다른 작업을 진행 가능하다(멀티 쓰레드)경로와 파일 jav">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_NIO">
<meta property="og:url" content="https://limjoonchul.github.io/2020/11/21/Java/JavaAdvanced/NIO/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="NIO(New Input Output)NIO 의 특징 채널을 이용해서 입&#x2F;출력을 모두 처리한다.(동시에 처리하는 것은 안된다)  IO와 달리 기본적으로 버퍼를 사용한다.  NIO는 Blocking 및 Nonblocking을 모두 지원한다.  Non-blocking은 비동기식으로 읽기&#x2F;쓰기를 시켜놓고 다른 작업을 진행 가능하다(멀티 쓰레드)경로와 파일 jav">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-21T05:36:07.836Z">
<meta property="article:modified_time" content="2020-11-21T05:45:27.172Z">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java/JavaAdvanced/NIO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/21/Java/JavaAdvanced/NIO/" class="article-date">
  <time datetime="2020-11-21T05:36:07.836Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java_NIO
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NIO-New-Input-Output"><a href="#NIO-New-Input-Output" class="headerlink" title="NIO(New Input Output)"></a>NIO(New Input Output)</h1><h2 id="NIO-의-특징"><a href="#NIO-의-특징" class="headerlink" title="NIO 의 특징"></a>NIO 의 특징</h2><ul>
<li><p>채널을 이용해서 입/출력을 모두 처리한다.(동시에 처리하는 것은 안된다)</p>
</li>
<li><p>IO와 달리 기본적으로 버퍼를 사용한다.</p>
</li>
<li><p>NIO는 Blocking 및 Nonblocking을 모두 지원한다.</p>
<ul>
<li>Non-blocking은 비동기식으로 읽기/쓰기를 시켜놓고 다른 작업을 진행 가능하다(멀티 쓰레드)<h2 id="경로와-파일"><a href="#경로와-파일" class="headerlink" title="경로와 파일"></a>경로와 파일</h2><ul>
<li>java.nio.file.path</li>
<li>Path::get() 메소드</li>
<li>public static Path get(String first, Stirng … more)</li>
<li>public static Path get(URI uri)<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">Path path1 = Paths.get(<span class="string">&quot;USERS&quot;</span>,<span class="string">&quot;jeyoung&quot;</span>,<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">Path path2 = Paths.get(<span class="keyword">new</span> URI(<span class="string">&quot;file:///users/jeyoung/1.txt&quot;</span>)); </span><br><span class="line"><span class="comment">// file도 프로토콜이다? 로컬에 접근하는 프로토콜이다 그래서 네트워크는 아니다. 네트워크에서 사용불가 ftp를 사용한다       </span></span><br></pre></td></tr></table></figure></li>
<li>Path의 주요 메소드</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>getFileName()</td>
<td>파일 또는 마지막 디렉토리의 이름을 갖는 Path를 반환</td>
</tr>
<tr>
<td>getNameCount()</td>
<td>루트 경로 이후의 경로의 개수를 반환</td>
</tr>
<tr>
<td>getName()</td>
<td>특정 인덱스의 경로의 이름을 반환</td>
</tr>
<tr>
<td>subpath()</td>
<td>beginIndex부터 endIndex로 구성된 Path를 반환</td>
</tr>
<tr>
<td>getParent()</td>
<td>상위 Path 객체를 반환</td>
</tr>
<tr>
<td>getRoot()</td>
<td>최상위 Path 객체를 반환</td>
</tr>
<tr>
<td>toAbsolutePath()</td>
<td>상대경로의 Path를 절대경로의 Path로 반환</td>
</tr>
<tr>
<td>normalize()</td>
<td>표준화된 경로 표현으로 변환하여 Path로 반환</td>
</tr>
<tr>
<td>toFile()</td>
<td>Path를 File 객체로 반환</td>
</tr>
<tr>
<td>toUri()</td>
<td>URI 객체로 반환</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>java.nio.files.Files</p>
<ul>
<li>Files의 주요 정적 메소드</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>newInputStream()</td>
<td>InputStream을 반환</td>
</tr>
<tr>
<td>newOutputStream()</td>
<td>OutputStream을 반환</td>
</tr>
<tr>
<td>newBufferedReader()</td>
<td>BufferedReader를 반환</td>
</tr>
<tr>
<td>newBufferedWriter()</td>
<td>Buffered Writer를 반환</td>
</tr>
<tr>
<td>newDirectoryStream()</td>
<td>DirectoryStream을 반환</td>
</tr>
<tr>
<td>newByteChannel()</td>
<td>SeekableByteChannel을 반환</td>
</tr>
<tr>
<td>createFile()</td>
<td>빈 파일 생성</td>
</tr>
<tr>
<td>createDirectory()</td>
<td>빈 디렉토리 생성</td>
</tr>
<tr>
<td>delete()</td>
<td>디렉토리 또는 파일을 삭제</td>
</tr>
<tr>
<td>copy()</td>
<td>source를 target으로 복사</td>
</tr>
<tr>
<td>move()</td>
<td>source를 target으로 이동</td>
</tr>
<tr>
<td>readAllLines()</td>
<td>모든 행을 읽어서 List<String>으로 반환</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h2><ul>
<li>Direct Buffer vs Non-Direct Buffer</li>
</ul>
<table>
<thead>
<tr>
<th>Direct Buffer</th>
<th>Non-Direct Buffer</th>
</tr>
</thead>
<tbody><tr>
<td>OS 메모리를 직접 사용</td>
<td>JVM 메모리(힙 메모리)</td>
</tr>
<tr>
<td>OS와의 통신에 비해 버퍼 생성이 느림</td>
<td>빠름</td>
</tr>
<tr>
<td>사용 가능 크기가 큼</td>
<td>JVM에 의해서 제한된 메모리만 사용 가능</td>
</tr>
<tr>
<td>입출력 성능이 좋음</td>
<td>입출력 성능이 떨어짐</td>
</tr>
</tbody></table>
<ul>
<li>자주쓰는건 DirectBuffer를 사용하는게 좋다.</li>
</ul>
<ul>
<li><p>버퍼의 생성</p>
<ul>
<li>정적 메소드 allocate()를 이용한 버퍼의 생성<ul>
<li>모든 타입의 non-direct buffer 생성</li>
</ul>
</li>
<li>정적 메소드 wrap()을 이용한 버퍼의 생성<ul>
<li>이미 생성된 배열을 이용하여 non-direct buffer 버퍼 객체 생성</li>
</ul>
</li>
<li>정적 메소드 allocateDirect()를 이용한 direct buffer 생성<ul>
<li>ByteBuffer 정적 메소드를 이용하여 ByteBuffer 생성</li>
<li>생성된 Direct buffer를 asShortBuffer(), asIntBuffer() … 등을 이용해 버퍼 변환</li>
</ul>
</li>
</ul>
</li>
<li><p>버퍼의 사용</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>버퍼의 크기</td>
</tr>
<tr>
<td>limit</td>
<td>버퍼에 있는 데이터의 한계 (flip으로 설정)</td>
</tr>
<tr>
<td>position</td>
<td>버퍼에서 현재 커서의 위치</td>
</tr>
<tr>
<td>mark</td>
<td>reset()으로 돌아오기 위해 표시한 위치</td>
</tr>
</tbody></table>
<ul>
<li>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>flip()</td>
<td>limit=position, position=0</td>
</tr>
<tr>
<td>mark()</td>
<td>mark=position</td>
</tr>
<tr>
<td>reset()</td>
<td>position=mark</td>
</tr>
<tr>
<td>rewind()</td>
<td>position=0, mark 삭제</td>
</tr>
<tr>
<td>clear()</td>
<td>position=0, 모든 mark 삭제, limit=capacity</td>
</tr>
<tr>
<td>get()</td>
<td>상대/절대 위치에서 버퍼 읽기</td>
</tr>
<tr>
<td>getP()</td>
<td>P자료형으로 버퍼 읽기</td>
</tr>
<tr>
<td>put()</td>
<td>상대/절대 위치에서 버퍼 쓰기</td>
</tr>
<tr>
<td>putP()</td>
<td>P자료형으로 버퍼 쓰기</td>
</tr>
</tbody></table>
</li>
<li><p>버퍼의 변환</p>
<ul>
<li><p>ByteBuffer로의 수동 변환</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] src = &#123;<span class="number">423</span>, <span class="number">525</span>, <span class="number">236</span>, <span class="number">523</span>&#125;;</span><br><span class="line">IntBuffer iBuff = IntBuffer.wrap(src);</span><br><span class="line">ByteBuffer bBuff = ByteBuffer.allocate(iBuff.capacity() * <span class="number">4</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iBuff.capacity(); i++) &#123;</span><br><span class="line">  bBuff.putInt(iBuff.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use bBuff ...</span></span><br><span class="line"></span><br><span class="line">bBuffer.rewind();</span><br><span class="line">IntBuffer iBuffer2 = bBuffer.asIntBuffer();</span><br><span class="line"><span class="keyword">int</span> [] target = <span class="keyword">new</span> <span class="keyword">int</span>[iBUffer2.capacity()];</span><br><span class="line">iBuffer2.get(target);</span><br><span class="line">System.out.println(Arrays.toString(target));</span><br></pre></td></tr></table></figure>
</li>
<li><p>java.nio.charset.Charset</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>forName()</td>
<td>charsetName을 입력받아 Charset 객체 생성</td>
</tr>
<tr>
<td>encode()</td>
<td>String 또는 CharBuffer를 ByteBuffer로 변환하여 반환</td>
</tr>
<tr>
<td>decode()</td>
<td>ByteBuffer를 CharBuffer로 변환하여 반환</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    String str = <span class="string">&quot;문자열 데이터&quot;</span>;</span><br><span class="line">    Charset charset = Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    ByteBuffer bBuff = charset.encode(str);</span><br><span class="line">    CharBuffer cBuff = charset.decode(bBuff);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(cBuff.array()));</span><br><span class="line">   ``` </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">* Channels</span><br><span class="line">  * java.nio.channel.FileChannel</span><br><span class="line"></span><br><span class="line">  | 메소드 |    설명 |</span><br><span class="line">  | ----- | ---- |</span><br><span class="line">  | open() | FileChannel 객체 생성 |</span><br><span class="line">  | close() | FileChannel의 리소스를 반환 |</span><br><span class="line">  | read() | ByteBuffer에 FileChannel에서 읽은 내용을 저장 |</span><br><span class="line">  | write() | ByteBuffer의 내용을 FileChannel을 이용해 출력 |</span><br><span class="line">  </span><br><span class="line">* StandardOpenOption</span><br><span class="line"></span><br><span class="line">| 열거형 상수 | 설명 |</span><br><span class="line">| --------- | ---- |</span><br><span class="line">| READ | 읽기용으로 파일 오픈 |</span><br><span class="line">| WRITE    | 쓰기용으로 파일 오픈 |</span><br><span class="line">| CREATE | 파일이 없으면 새로운 파일 생성, 있으면 기존 파일 사용 |</span><br><span class="line">| CREATE_NEW | 파일이 없으면 새로운 파일 생성, 있으면 FileAlreadyExistsException 예외 발생 |</span><br><span class="line">| APPEND | 파일 뒤에 내용 추가 |</span><br><span class="line">| DELETE_ON_CLOSE | 채널을 닫을 때 파일 삭제 |</span><br><span class="line"></span><br><span class="line">* flip() - 현재 포지션을 limit으로 세팅하고 포지션을 <span class="number">0</span>으로 돌리는 역할을 함. 읽은 포지션을 limit으로 기억함.(어느 부분까지 적혀있는지, 사이즈를 말하는 듯)</span><br><span class="line">* channel2.write(readBuffer) 그래서 포지션 <span class="number">0</span>부터 limit까지 쓰게 된다.</span><br><span class="line">* read()하면 포지션은 <span class="number">0</span> 로되고 limit은 capacity랑 같은 사이즈가 되서 원래 사용하지 않은것처럼 돌아간다.</span><br><span class="line">  </span><br><span class="line">```groovy</span><br><span class="line">Path src = Paths.get(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">Path dst = Paths.get(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (FileChannel channel1 = FileChannel.open(src, StandardOpenOption.READ);</span><br><span class="line">    FileChannel channel2 = FileChannel.open(dst, StandardOpenOption.WRITE, StandardOpenOption.CREATE))&#123; <span class="comment">//with resourece로 하는게 좋음 create 하면 새로만듬 create_new는 없으니 새로만든다는 의미 파일이 기존에 있으면 에러남</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    ByteBuffer readBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) channel1.size());</span><br><span class="line">    <span class="comment">// allocate -&gt; allocateDirect(보통사용함)</span></span><br><span class="line">    <span class="comment">// 버퍼 크기를 변경하여 최적화 가능. 버퍼크기가 너무 크면 느려진다. 적절한게 좋음.</span></span><br><span class="line">    read = channel1.read(readBuffer); <span class="comment">// 버퍼를 읽어줌</span></span><br><span class="line">    <span class="keyword">if</span>(read == <span class="number">-1</span>)&#123; <span class="comment">// 읽은게 하나도 없다면</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    readBuffer.flip();</span><br><span class="line">    channel2.write(readBuffer); <span class="comment">//</span></span><br><span class="line">    readBuffer.clear();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>버퍼가 작은 경우</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">src = Paths.get(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">dst = Paths.get(<span class="string">&quot;3.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (FileChannel channel1 = FileChannel.open(src, StandardOpenOption.READ);</span><br><span class="line">     FileChannel channel2 = FileChannel.open(dst, StandardOpenOption.WRITE, StandardOpenOption.CREATE))&#123; <span class="comment">//with resourece로 하는게 좋음 create 하면 새로만듬 create_new는 없으니 새로만든다는 의미 파일이 기존에 있으면 에러남</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 채널에서 읽어올때  순서대로 읽어올수 있게 기억하고 있음 readbuffer크기만큼 가져오고 나머지는 대기하고있음</span></span><br><span class="line">    <span class="keyword">while</span> ((read = channel1.read(readBuffer)) != <span class="number">-1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        channel2.write(readBuffer);</span><br><span class="line">        readBuffer.clear(); <span class="comment">// 버퍼를 다시 쓸 수 있게 초기화</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/11/21/Java/JavaAdvanced/NIO/" data-id="ckhrac5hp00178cu29cxcfz6b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/11/21/Algorithm/Programmers/FunctionDevelopment/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Programmers-기능개발
        
      </div>
    </a>
  
  
    <a href="/2020/11/07/Algorithm/Programmers/DivideNumberArray/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Programmers-나누어 떨어지는 숫자 배열</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/21/Spring/Servlet/">Spring-Servlet</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Spring/Pholymorphism/">Spring-Pholymorphism</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Spring/JSP/">Spring-JSP</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Spring/JDBC/">Spring-JDBC</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Spring/HTTP/">Spring-HTTP</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>