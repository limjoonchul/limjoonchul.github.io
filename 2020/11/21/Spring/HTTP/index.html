<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Spring-HTTP | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="HTTP클라이언트, 웹, WAS 클라이언트 - 서비스를 이용하는 사람, 웹 프로그래밍 관점에선 클라이언트 역할을 하는 프로그램, 웹에서는 웹 브라우저, 모바일 앱 등등이다.  웹서버 - 클라이언트에서 자료를 요청하면 요청을 받는게 웹 서버가 된다. 웹서버가 있어도 되고 없어도 되는데사용하는 이유는 로드밸런싱이라는 기술을 한다.  로드밸런싱 - 요청을 받아주">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-HTTP">
<meta property="og:url" content="https://limjoonchul.github.io/2020/11/21/Spring/HTTP/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="HTTP클라이언트, 웹, WAS 클라이언트 - 서비스를 이용하는 사람, 웹 프로그래밍 관점에선 클라이언트 역할을 하는 프로그램, 웹에서는 웹 브라우저, 모바일 앱 등등이다.  웹서버 - 클라이언트에서 자료를 요청하면 요청을 받는게 웹 서버가 된다. 웹서버가 있어도 되고 없어도 되는데사용하는 이유는 로드밸런싱이라는 기술을 한다.  로드밸런싱 - 요청을 받아주">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://limjoonchul.github.io/Java/documents/images/HTTPStructure.jpg">
<meta property="og:image" content="https://limjoonchul.github.io/Java/documents/images/RequestHeader.jpg">
<meta property="og:image" content="https://limjoonchul.github.io/Java/documents/images/ResponseHeader.jpg">
<meta property="article:published_time" content="2020-11-21T05:59:49.970Z">
<meta property="article:modified_time" content="2020-11-21T06:01:32.912Z">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://limjoonchul.github.io/Java/documents/images/HTTPStructure.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring/HTTP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/21/Spring/HTTP/" class="article-date">
  <time datetime="2020-11-21T05:59:49.970Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring-HTTP
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="클라이언트-웹-WAS"><a href="#클라이언트-웹-WAS" class="headerlink" title="클라이언트, 웹, WAS"></a>클라이언트, 웹, WAS</h2><ul>
<li><p>클라이언트 - 서비스를 이용하는 사람, 웹 프로그래밍 관점에선 클라이언트 역할을 하는 프로그램<br>, 웹에서는 웹 브라우저, 모바일 앱 등등이다.</p>
</li>
<li><p>웹서버 - 클라이언트에서 자료를 요청하면 요청을 받는게 웹 서버가 된다. 웹서버가 있어도 되고 없어도 되는데<br>사용하는 이유는 로드밸런싱이라는 기술을 한다.</p>
<ul>
<li>로드밸런싱 - 요청을 받아주면 이 요청에 대해서 답을 만들어 내야하는데<br>정적인 파일이면 응답을 바로하던가하고 동적인 파일이면 was에 보내서 응답을 받도록 한다.(웹서버에서 내부적으로 돌아간다.)</li>
<li>클라이언트에서 요청을 하면 웹 서버에서 로드밸런싱이 일어나서 서버가 여러대가 있는데 일을 덜하고 있는 서버에<br>요청해서 답을 얻어서 응답해주는게 웹서버의 역할이다. 이런 효율성을 위해서 웹서버가 필요하다.</li>
<li>정적 파일을 바로 응답해주는게 주요 일이였는데 규모가 커지면서 로드 밸런싱의 역할이 더 중요해졌다.</li>
</ul>
</li>
<li><p>Servlet/JSP(웹 컨테이너) - 동적인 자료를 생성해주는것 html 형태나 json 형태로 답을 한다.</p>
<ul>
<li>html - 로직을 짤 수없는 화면에 바로 보여지는 것만 만든다. 프로그램을 넣을 수 없다.</li>
<li>json - 자료를 요청하면 가공해서 맵 형태(키벨류쌍)로 환경에 대한 정보(mac os, 버전, 프로토콜, 실제 데이터가 인코딩되서 바이트코드로 들어갈 수 있는 프로퍼티,  자료)등을<br>담는다. </li>
</ul>
</li>
<li><p>WAS - 웹서버와 웹 컨테이너를 합친 것</p>
<ul>
<li>웹서버는 정적 콘텐츠를 요청에 따라 전달해 주는 역하을 한다</li>
<li>WAS는 사용자의 요청에 따라 서버에서 프로그램을 실행 및 처리한 뒤 그것을 다시 정적인 페이지로 변환해 반환하는 동적인 처리를 담당한다.</li>
</ul>
</li>
<li><p>웹 서버는 입 출력간의 게이트 역할을 해주는 것이고, WAS에서 실제로 무언가를 생성하는 것이다.</p>
</li>
<li><p>WAS에서는 무거운 프로그램이 동작하지 않는다.</p>
<ul>
<li>에러를 발생시킨다던지 이런 가벼운 동작만하고 무거운건 애플리케이션에서 한다.</li>
</ul>
</li>
</ul>
<h2 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li><p>웹에서 가장 많이 사용하는 클라이언트와 서버간의 통신 규약을 말한다.</p>
</li>
<li><p>특정 IP 두개가 서로 통신을 할 때 방식이 TCP/UDP 방식이 있다.</p>
<ul>
<li><p>TCP - A에서 자료를 던지면 B에서 잘 전달 받았으면 ACK라는 반응을 하고, 자료를 모르겠거나 잘 못 되었으면 NACK를 반응하는 등의<br>서로간의 자료를 잘 받았는지 확인을 하면서 통신하는 연결 지향적이다.</p>
</li>
<li><p>UDP - 자료를 일방적으로 던지는 것을 말한다 신뢰성이 없다. 대신 속도가 빠르다<br>패킷단위로 잘게 쪼개서 통신을 할 때 드물게 오류가 발생할 수 있는데 압축을 풀었을 때 오류가 난다던가 하는 일이 생길 수 있다.<br>이런 이유에서 신뢰도가 낮다. </p>
<p><img src="/Java/documents/images/HTTPStructure.jpg" alt="HTTP"></p>
</li>
<li><p>HTTP 요청와 HTTP 응답은 스타트 라인, 메세지해더 빈칸 바디로 구성되어 있다.<br>브라우저에 버튼을 누르거나해서 요청을 하면 요청 프로토콜을 만들고 헤더와 바디에 정보를 담고 흘러가서 서버에 전달이 되고<br>서버입장에서는 요청 프로토콜을 추출해서 메세지 헤더 바디정보 뭔가를 실행한다.<br>그런 다음 브라우저로 보낼 때 응답 프로토콜을 만들어서 스타트라인, 메세지 헤더, 메세지 바디쪽에 뭔가를 출력하고<br>브라우저에 도착하면 응답 프로토콜의 스타트라인, 메세지 헤더, 바디 정보를 추출해서 화면을 렌더링한다.</p>
</li>
<li><p>브라우저가 서버에 요청을 하는 방법은 크게 3가지 url검색창을 통한 url 요청, 버튼, 링크 </p>
<h3 id="HTTP-특징"><a href="#HTTP-특징" class="headerlink" title="HTTP 특징"></a>HTTP 특징</h3></li>
</ul>
</li>
<li><p>Connectionless(비 연결지향)</p>
<ul>
<li>클라이언트에서 서버에 요청을 보내고 서버에서 응답을 하고나면 접속이 끊어지는 특성이다.</li>
</ul>
</li>
<li><p>Stateless (상태 정보 유지 안함)</p>
<ul>
<li>HTTP통신은 요청을 응답하고 접속을 끊기 때문에 클라이언트의 정보를 알 수 없다.</li>
</ul>
</li>
<li><p>이런 특징이 있는데 로그인 처럼 사용자의 정보를 유지시켜야 할 때 단점으로 작용하는데 이런 것을 해결하기 위한 것이 쿠키이다.</p>
</li>
</ul>
<h2 id="HTTP-메세지"><a href="#HTTP-메세지" class="headerlink" title="HTTP 메세지"></a>HTTP 메세지</h2><ul>
<li>HTTP 메세지 - 클라이언트의 요청을 서버에서 응답할 때 응답에 대한 정보를 클라이언트로 보낼때 정보가 담긴<br>메세지를 의미한다. 시작줄, 헤더, 본문으로 구성 되어있다.<h3 id="Head-Field"><a href="#Head-Field" class="headerlink" title="Head Field"></a>Head Field</h3></li>
<li>General-Header, Request/Response-Header, Entity-Header(HTTP Body Info)로 구성되어 있다</li>
<li>Cache-Control(HTTP/1.1)<ul>
<li>웹 서버와 클라이언트의 요청과 응답의 횟수(round-trip)를 줄여 대역폭을 향상하기 위해 사용되며, 보통 만기일 (expiration)과 유효일(validation)을 지정</li>
<li>개발 중에는 보통 no-cache</li>
</ul>
</li>
<li>Connection<ul>
<li>HTTP/1.0은 요청과 응답이후 커넥션을 종료한다. 이러한 오버헤드를 줄이기 위해  “close/keep alive 둘 중의 하나를 설정하여 HTTP/1.1에서는 연결지향으로 설정할 수 있다.</li>
<li>close 제어필드<ul>
<li>요청/응답이후 클라이언트/서버의 연결을 끊겠다는 의미</li>
</ul>
</li>
<li>keep alive <ul>
<li>요청/응답이후에도 연결을 지속하겠다는 의미</li>
</ul>
</li>
</ul>
</li>
<li>Transfer-Encoding<ul>
<li>전체 데이터를 인코딩하기 위해 사용하며, ‘chunked’로 지정하면 Content-Length를 제공하지 않는다</li>
<li>데이터를 암호화하기 위해 보통 사용한다.</li>
</ul>
</li>
</ul>
<h4 id="General-Header"><a href="#General-Header" class="headerlink" title="General-Header"></a>General-Header</h4><ul>
<li>요청/응답 Message에 모두 활용 할 수 있는 기능을 제공함<h4 id="HTTP-Response-Header"><a href="#HTTP-Response-Header" class="headerlink" title="HTTP Response Header"></a>HTTP Response Header</h4></li>
<li>Location - 리소스가 리다이렉트(redirect)된 때에 이동된 주소, 또는 새로 생성된 리소스 주소를 명시한다. 300 응답일 때 어느 페이지로 이동할지 redirect한다.</li>
<li>retry-after - 서버 응답 코드 503에러와 함께 쓰이며, 일정 시간이 지난 후 문서요청을 다시 하라는 헤더 값이다<h4 id="HTTP-Entity"><a href="#HTTP-Entity" class="headerlink" title="HTTP Entity"></a>HTTP Entity</h4></li>
<li>엔티티로 구성됨을 의미하며, 엔티티 헤더와 엔티티 본문으로 구성<ul>
<li>Content-Encoding : 본문이 압축/암호화 되었을 때의 헤더 설정 값 (gzip등)</li>
<li>Content-Type : Response Body Mime Type</li>
<li>Content-Length : 본문의 길이(byte) </li>
</ul>
</li>
<li>Entity Body<ul>
<li>엔티티 본문은 존재 할 수도, 존재하지 않을 수도 있으며, Content-Length/Transfer-Encoding 헤더가 존재한다면 메시지 본문이 존재한다는 것을 의미</li>
</ul>
</li>
</ul>
<h3 id="Request-구조"><a href="#Request-구조" class="headerlink" title="Request 구조"></a>Request 구조</h3><ul>
<li><p>요청</p>
<ul>
<li>시작줄 - 메소드 주소 버전으로 구성되었다, 요청 방식(get , post) / uri / 요청에 사용된 프로토콜의 버전(중요 x 프로토콜은 불변이니깐)</li>
<li>헤더 - 요청에 대한 정보를 담고 있다.</li>
<li>본문 - 요청을 할 때 함께 보낼 데이터를 담고 있다.</li>
</ul>
<p><img src="/Java/documents/images/RequestHeader.jpg" alt="RequestHeader"></p>
</li>
<li><p>HTTP 메서드</p>
<ul>
<li>GET, POST, PUT, PATCH, DELETE 가 있다.</li>
<li>GET - 서버로부터 데이터를 가져올 때 사용, get, 이미지, url입력 방식은 무조건 get방식이다.</li>
<li>POST - 클라이언트가 서버에 데이터를 새로 추가할 때 사용 ,  form태그의 전송방식이 post방식이다.</li>
<li>PUT - 서버에 이미 존재하는 데이터를 업데이트할 때 사용</li>
<li>DELETE - 서버의 데이터를 삭제할 때 사용.</li>
<li>GET과 DELTE를 제외한 나머지는 요청을 보낼 때 본문을 같이 보낼 수 있다.</li>
<li>OPTIONS - 서버가 어떤 메서드를 지원하는지 알아볼 때 사용 (CORS문제에 많이 나온다)<ul>
<li>실제 요청을 보내기전 서버를 테스트해보는 용도</li>
</ul>
</li>
</ul>
</li>
<li><p>참고자료 : <a target="_blank" rel="noopener" href="https://www.zerocho.com/category/HTTP/post/5b4c4e3efc5052001b4f519b">https://www.zerocho.com/category/HTTP/post/5b4c4e3efc5052001b4f519b</a>      </p>
</li>
<li><p>CRUD 위의 것들을 의미</p>
</li>
<li><p>RESTful API에서 다룰 것이다. 어느 정도 특정 조건을 만족하면 REST한 성질을 가진 API다라는 RESTful API라고 하는것</p>
</li>
<li><p>클라이언트측에서 웹서버로 요청</p>
</li>
<li><p>패킷을 구성해서 던진다 패킷은 더 쪼개질 수있다.</p>
</li>
<li><p>메소드를 결정한다 get/post를 많이 사용</p>
</li>
<li><p>GET - 스테이트리스하게 동작하는 대표적인 예 페이지를 받아온다. 정적인 페이지를 나한테 돌려 달라 라는의미 이 페이지를 보여달라 등에 사용.</p>
<ul>
<li>입력 데이터를 URL에 붙여서 전송하므로 헤더에 바디가 없다.</li>
<li>전송하는 자료량에 한계가 있다.</li>
<li>POST보다 본안성이 좋지 않다.</li>
</ul>
</li>
<li><p>POST - GET처럼 쓸 수 있지만 메세지 바디가 존재해서 내가 원하는 만큼 자료를 심어서 보낼 수 있다.(이미지 등)</p>
<ul>
<li>이미지를 전송한다는게 메세지바디에 인코딩 상태로 바이트스트림으로 적힌다. 자료를 더해서 요청을 할 때 자료를 처리해 달라던지 자료를 같이 보낼 때 사용 </li>
<li>스트림 형태로 전송되므로 전송 용량에 제한이 없다.</li>
<li>보안이 우수함</li>
</ul>
</li>
</ul>
<h3 id="Response-구조"><a href="#Response-구조" class="headerlink" title="Response 구조"></a>Response 구조</h3><ul>
<li><p>응답</p>
<ul>
<li>시작줄 - 버전 상태코드 상태메세지로 구성</li>
<li>헤더 - 응답에 대한 정보</li>
<li>본문 - 요청한 데이터를 담아서 보내는데 HTML이 담겨있어서 브라우저가 이걸 받아 화면에 렌더링 한다.</li>
</ul>
<p><img src="/Java/documents/images/ResponseHeader.jpg" alt="RequestHeader"></p>
</li>
<li><p>Request랑 거의 동일</p>
</li>
<li><p>상태코드</p>
<ul>
<li>2XX -&gt; 웹 서버가 성공적으로 클라이언트의 요청에 응답 했음을 의미</li>
<li>3XX -&gt; 다른 페이지로 재 연결 필요가 있음을 통지</li>
<li>4XX -&gt; 클라이언트에 오류를 있음을 나타냄<ul>
<li>404  - 요청한 파일을 찾을 수 없을 때 또는 url패턴 매핑이 안되어 있을 때 뜬다.</li>
<li>405 - 요청한 method가 없을 때  요청한방식이 post로 요청했는데 post가 없고 get밖에 없을 때 뜬다. </li>
</ul>
</li>
<li>5XX -&gt; 서버에서 에러가 발생 했음을 의미 Server Internal Error<ul>
<li>500 - 서버오류 예외가 발생하면 그 아래 코드는 실행되지 않는다.<br>이런 상황일 때 서버 프로그램에서 예외가 발생했다고 뜬다.</li>
</ul>
</li>
</ul>
</li>
<li><p>keep alive를 지원하지 않을 경우</p>
<p>1.</p>
<ul>
<li>웹 서버에 연결한다.</li>
<li>HTML 문서를 다운로드 한다.</li>
<li>웹 서버 연결을 끊는다.</li>
</ul>
<ol start="2">
<li><ul>
<li>HTML 문서의 image, css, javascript 링크들을 읽어서 다운로드해야할 경로를 저장한다.</li>
<li>웹 서버에 연결한다. </li>
<li>첫번째 이미지를 다운로드</li>
<li>연결을 끊는다.</li>
</ul>
</li>
<li><ul>
<li>웹 서버에 연결한다.</li>
<li>두번째 이미지를 다운로드</li>
<li>연결을 끊는다.</li>
</ul>
</li>
</ol>
<ul>
<li>이 과정을 모든 자료를 다운로드할 때까지 반복한다.</li>
</ul>
</li>
<li><p>Keep-alive 설정을 하면, 지정된 시간동안 연결을 끊지 않고 요청을 계속해서 보낼 수 있다<br>.  * 웹 서버에 연결한다.</p>
<ul>
<li>HTML 문서를 다운로드 한다.</li>
<li>Image, css, javascript 들을 다운로드 한다.</li>
<li>모든 문서를 다운로드 받았다면 연결을 끊는다.</li>
</ul>
</li>
<li><p>참교 사이트 : <a target="_blank" rel="noopener" href="https://shlee0882.tistory.com/107?category=703874">https://shlee0882.tistory.com/107?category=703874</a>   </p>
</li>
</ul>
<h2 id="쿠키-Cookie"><a href="#쿠키-Cookie" class="headerlink" title="쿠키(Cookie)"></a>쿠키(Cookie)</h2><ul>
<li><p>클라이언트가 서버에 떨어뜨린 작은 부스러기의 의미로 쿠키라는 명칭을 사용.</p>
</li>
<li><p>클라이언트 로컬에 저장되는 key-value쌍을 갖는 작은 데이터 파일이다.</p>
</li>
<li><p>쿠키를 이용해 로컬에다가 key-value쌍으로 되어있는 상태를 저장한다 이걸 요청을 보낼 때 같이 붙여서 보내면<br>서버에서 요청을 분석해서 사용자를 구별하고 개개인에 맞는 응답을 줄 수 있게 하는 방식이다.</p>
</li>
<li><p>반드시 사용자의 정보가 아니라 다른 세팅도 저장이 될 수 있다.</p>
</li>
<li><p>쿠키의 구성요소</p>
<ul>
<li>이름, 값, 유효시간, 도메인, 경로</li>
</ul>
</li>
<li><p>동작방식</p>
<ul>
<li>예를 들어서 클라이언트가 책을 장바구니에 한 책을 담는다는 요청을 보내면 서버에서 쿠키에 책에 대한 정보를 담아서 응답으로 쿠키를 담아서 보낸다.<br>그런다음 다른 책을 장바구니에 담으면 그전에 응답이 왔던 쿠키(여기서가 떨어져있던 부스러기를 의미하는 듯)를 담아서 요청을 보내면<br>서버에서 요청이 들어온 정보들을 보면서 쿠키를 환경변수가 분석해서 전에 책을 담았던 클라이언트구나하고 인식하고<br>2개의 책이 담긴 쿠키를 다시 클라이언트에게 보낸다.</li>
</ul>
</li>
</ul>
<h2 id="세션-Session"><a href="#세션-Session" class="headerlink" title="세션(Session)"></a>세션(Session)</h2><ul>
<li>세션은 쿠키를 기반으로 하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버측에서 관리한다.<br>서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다.<ul>
<li>물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 세션을 끊도록 설정이 가능하다.</li>
</ul>
</li>
<li>사용자에 대한 정보를 서버에 저장하기 대문에 쿠키보다 보안에 좋지만, 사용자가 많아질 수록 서버 메모리를 많이 차지하게 된다.</li>
</ul>
<h3 id="세션의-동작-방식"><a href="#세션의-동작-방식" class="headerlink" title="세션의 동작 방식"></a>세션의 동작 방식</h3><ol>
<li>클라이언트가 서버 접속 시 세션 ID를 발급한다.</li>
<li>클라이언트가 세션 ID에 대해 쿠키를 사용해서 저장(JSEESIONID)</li>
<li>클라이언트가 서버에 다시 접속 시 이 쿠키를 이용해서 세션 ID 값을 서버에 전달한다.</li>
</ol>
<h3 id="세션의-특징"><a href="#세션의-특징" class="headerlink" title="세션의 특징"></a>세션의 특징</h3><ul>
<li>각 클라이언트에게 고유 ID를 부여한다.</li>
<li>세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공한다.</li>
<li>보안 면에서 쿠키보다 우수하다.</li>
<li>사용자가 많아질 수록 메모리를 많이 차지하게 된다.</li>
</ul>
<h3 id="쿠키와-세션의-차이"><a href="#쿠키와-세션의-차이" class="headerlink" title="쿠키와 세션의 차이"></a>쿠키와 세션의 차이</h3><ul>
<li><p>쿠키와 세션은 비슷한 역할을 하며, 동작 원리도 비슷하다.</p>
<ul>
<li>이유는 세션도 결국 쿠키를 사용하기 때문이다.</li>
</ul>
</li>
<li><p>가장 큰 차이점은 사용자의 기록정보가 저장되는 위치이다.</p>
<ul>
<li>쿠키는 로컬에 저장되고, 세션은 서버에 저장된다.</li>
</ul>
</li>
<li><p>참고자료 : <a target="_blank" rel="noopener" href="https://victorydntmd.tistory.com/34">https://victorydntmd.tistory.com/34</a></p>
</li>
</ul>
<h3 id="캐쉬"><a href="#캐쉬" class="headerlink" title="캐쉬"></a>캐쉬</h3><ul>
<li>캐쉬는 내가 페이지를 요청했을 때 완전히 같은 페이지를 뱉어줄건데 매번 해줘야 하나에서 나온게 Cache-Control</li>
<li>요즘엔 트래픽이 많아서 중요함. 페이지를 새로고침했을 때 바로바로 화면에 나오는게 있는데 이런부분들이 로컬에 이미 다운이 받아져 있고<br>html이 캐슁이 되서 저장이 되어있다. 미리 저장을 해두고 바꿔야하는 부분만 업데이트를 한다.<br>아니면 타이밍 한시간뒤에는 다시 받아온다 던지 이런걸 서버에서 정할 수 있다.</li>
<li>실시간성, 응답성, 전체적인 트랙픽을 낮추는 이세가지사이에 트레이드오프가 있다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/11/21/Spring/HTTP/" data-id="ckhrac5f800038cu2edx99d2m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/11/21/Spring/JDBC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spring-JDBC
        
      </div>
    </a>
  
  
    <a href="/2020/11/21/Algorithm/Programmers/SortStringDescending/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Programmers-문자열 내림차순으로 배치하기</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/21/Spring/Servlet/">Spring-Servlet</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Spring/Pholymorphism/">Spring-Pholymorphism</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Spring/JSP/">Spring-JSP</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Spring/JDBC/">Spring-JDBC</a>
          </li>
        
          <li>
            <a href="/2020/11/21/Spring/HTTP/">Spring-HTTP</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>