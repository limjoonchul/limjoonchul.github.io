<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://limjoonchul.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Facamp lim">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://limjoonchul.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java/JavaAdvanced/Java-JavaInputOutput" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/" class="article-date">
  <time datetime="2020-10-07T11:31:56.495Z" itemprop="datePublished">2020-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h1><h2 id="I-O와-스트림"><a href="#I-O와-스트림" class="headerlink" title="I/O와 스트림"></a>I/O와 스트림</h2><ul>
<li>I/O 입출력(Input/Output)을 함께 부르는 것</li>
<li>자바의 I/O는 스트림을 이용해 데이터를 주고 받는 형식으로 이루어졌다.<ul>
<li>데이터의 소스와 목적지를 노드(Node)라고 부른다.</li>
<li>노드는 키보드(입력), 모니터(출력,터치스크린은 입력가능), 파일(입출력), 메모리에 적혀있는걸 읽는것(입출력둘다 해당), 데이터베이스(입출력),다른 프로그램 등이 될 수 있다.</li>
</ul>
</li>
<li>장치하고는 상관없이 자바의 입출력을 추상화해놓은 스트림이다.</li>
<li>자바 응용프로그램과 입출력 자료사이에 데이터를 입출력하는 통로라고 생각하면 된다!!</li>
</ul>
<h2 id="입출력-스트림이란"><a href="#입출력-스트림이란" class="headerlink" title="입출력 스트림이란?"></a>입출력 스트림이란?</h2><ul>
<li>네트워크에서 자료의 흐름이 물과같다는 의미에서 유래되었다.</li>
<li>다양한 입출력 장치에 독립적으로 일관성있는 입출력 방식을 제공한다.</li>
<li>가상 경로가 있다고 가정하고 입출력이 이뤄진다.</li>
<li>입출력이 구현 되는 곳에서는 모두 I/O 스트림을 사용<ul>
<li>키보드, 파일 디스크, 메모리 등</li>
</ul>
</li>
</ul>
<p><img src="../../../image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="입출력스트림"></p>
<h2 id="입출력-스트림-구분"><a href="#입출력-스트림-구분" class="headerlink" title="입출력 스트림 구분"></a>입출력 스트림 구분</h2><ul>
<li>I/O 대상 기준 : 입력 스트림, 출력 스트림</li>
<li>자료의 종류 : 바이트 스트림, 문자 스트림<ul>
<li>동영상이나 음악파일은 한 바이트씩 쓰인다.</li>
<li>문자, 한글 파일등은 멀티 파이트로 쓰인다.</li>
</ul>
</li>
<li>스트림의 기능 : 기반 스트림(메인 스트림), 보조 스트림</li>
</ul>
<h3 id="기반-스트림-메인스트림-과-보조스트림"><a href="#기반-스트림-메인스트림-과-보조스트림" class="headerlink" title="기반 스트림(메인스트림)과 보조스트림"></a>기반 스트림(메인스트림)과 보조스트림</h3><ul>
<li><p>자바의 I/O는 디자인 패턴 중에 데코레이터 패턴으로 구현되어 있는데 보조스트림은 읽거나 쓰는 기능은 없다.</p>
</li>
<li><p>데코레이터 패턴에서 원래 컴포넌트가 가지는 기능 읽거나 쓰는 기능은 기반 스트림에서 가지고 있고,<br>보조스트림은 기반스트림을 보조하는 기능을 추가하는 것이다.</p>
<ul>
<li>자바 I/O는 데코레이터 패턴 기반이다.</li>
<li>원래 어떤 클래스 기능이 확장되면 상속을 쓰는 경우가 있는데,<br>데코레이터 패턴은 더 유연하게 기능을 확장할 수 있는 그런 디자인 패턴이다.</li>
</ul>
</li>
<li><p>바이트를 문자로 바꿔준다던가 버퍼링기능을 제공한다던가 직렬화 같은 것들이 보조 스트림에서 제공이 된다.</p>
</li>
<li><p>하나의 스트림은 입력이나 출력이냐, 바이트냐 문자냐, 기반이냐 보조냐로 구분해서 보면 스트림을 이해하는데 도움이 된다.</p>
</li>
</ul>
<h3 id="입출력-스트림과-출력-스트림"><a href="#입출력-스트림과-출력-스트림" class="headerlink" title="입출력 스트림과 출력 스트림"></a>입출력 스트림과 출력 스트림</h3><ul>
<li>입력 스트림 : 대상으로부터 자료를 읽어 들이는 스트림</li>
<li>출력 스트림 : 대상으로 자료를 출력하는 스트림</li>
</ul>
<p><img src="../../../image/%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8A%A4%ED%8A%B8%EB%A6%BC2.jpg" alt="입출력스트림"></p>
<h4 id="입출력-스트림과-출력-스트림의-종류"><a href="#입출력-스트림과-출력-스트림의-종류" class="headerlink" title="입출력 스트림과 출력 스트림의 종류"></a>입출력 스트림과 출력 스트림의 종류</h4><ul>
<li>입력 스트림 : FileInputStream, FileReader, BufferedInputStream, BufferedReader 등</li>
<li>출력 스트림 : FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등<ul>
<li>끝에 Stream이 붙은 것은 Byte 단위로 처리하고, Reader/writer는 문자 단위로 처리한다.</li>
<li>Buffered는 버퍼링을 제공하는 보조스트림이다.</li>
</ul>
</li>
</ul>
<h3 id="바이트-단위-스트림과-문자-스트림"><a href="#바이트-단위-스트림과-문자-스트림" class="headerlink" title="바이트 단위 스트림과 문자 스트림"></a>바이트 단위 스트림과 문자 스트림</h3><ul>
<li>바이트 단위 스트림 :  바이트 단위로 자료를 읽고 쓴다(동영상, 음악파일등)</li>
<li>문자 단위 스트림 : 문자는 2바이트씩 처리해야한다!!(char형 나왔을 때 2바이트라는거 생각해!!)</li>
</ul>
<p><img src="../../../image/%EB%B0%94%EC%9D%B4%ED%8A%B8%EB%AC%B8%EC%9E%90%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="바이트문자스트림"></p>
<h4 id="바이트-단위-스트림과-문자-스트림의-종류"><a href="#바이트-단위-스트림과-문자-스트림의-종류" class="headerlink" title="바이트 단위 스트림과 문자 스트림의 종류"></a>바이트 단위 스트림과 문자 스트림의 종류</h4><ul>
<li>바이트 스트림 : FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream 등</li>
<li>문자 스트림 : FileReader, FileWriter, BufferedReader, BufferedWriter 등</li>
</ul>
<h2 id="기반-스트림과-보조-스트림"><a href="#기반-스트림과-보조-스트림" class="headerlink" title="기반 스트림과 보조 스트림"></a>기반 스트림과 보조 스트림</h2><ul>
<li>기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림</li>
<li>보조 스트림 : 직접 읽고 쓰는 기능은 없고 추가적인 기능을 제공해 주는 스트림<br>기반 스트림이나 또 다른 보조 스트림을 생성자의 매개변수로 포함시킨다.</li>
</ul>
<p><img src="../../../image/%EA%B8%B0%EB%B0%98%EB%B3%B4%EC%A1%B0%EC%8A%A4%ED%8A%B8%EB%A6%BC.jpg" alt="기반보조스트림"></p>
<h3 id="기반-스트림과-보조-스트림의-종류"><a href="#기반-스트림과-보조-스트림의-종류" class="headerlink" title="기반 스트림과 보조 스트림의 종류"></a>기반 스트림과 보조 스트림의 종류</h3><ul>
<li>기반 스트림 : FileInputStream, FileOutputStream, FileReader, FileWriter 등</li>
<li>보조 스트림 : InputStreamReader, OutputStreamReader, BufferedInputStream, BufferedOutputStream 등</li>
</ul>
<h2 id="표준-입출력"><a href="#표준-입출력" class="headerlink" title="표준 입출력"></a>표준 입출력</h2><h3 id="Sytem-in"><a href="#Sytem-in" class="headerlink" title="Sytem.in"></a>Sytem.in</h3><ul>
<li>한바이트 씩 읽어 들인다.</li>
<li>한글과 같은 여러 바이트로 된 문자를 읽기 위해서는 InputStreamReader 와 같은 보조 스트림을 사용해야 한다.</li>
</ul>
<h3 id="Scanner-클래스"><a href="#Scanner-클래스" class="headerlink" title="Scanner 클래스"></a>Scanner 클래스</h3><ul>
<li>java.util 패키지에 있는 입력 클래스</li>
<li>문자뿐 아니라 정수, 실수등 다양한 자료형을 읽을 수 있다.</li>
<li>생성자가 다양하여 여러 소스로부터 자료를 읽을 수 있다.</li>
</ul>
<p><img src="../../../image/%EC%8A%A4%EC%BA%90%EB%84%88%ED%81%B4%EB%9E%98%EC%8A%A4.jpg" alt="스캐너클래스"></p>
<h3 id="Console-클래스"><a href="#Console-클래스" class="headerlink" title="Console 클래스"></a>Console 클래스</h3><ul>
<li><p>System.in 을 사용하지 않고 콘솔에서 표준 입출력이 가능</p>
</li>
<li><p>Console 클래스의 메소드<br><img src="../../../image/%EC%BD%98%EC%86%94%ED%81%B4%EB%9E%98%EC%8A%A4.jpg" alt="콘솔클래스"></p>
</li>
</ul>
<h2 id="노드-스트림"><a href="#노드-스트림" class="headerlink" title="노드 스트림"></a>노드 스트림</h2><h3 id="InputStream과-Reader"><a href="#InputStream과-Reader" class="headerlink" title="InputStream과 Reader"></a>InputStream과 Reader</h3><ul>
<li>InputStream의 주요 메소드(byte 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>byte 하나를 읽어서 int로 반환. 읽을 값이 없으면 -1</td>
</tr>
<tr>
<td>int read(byte b[])</td>
<td>데이터를 읽어 b를 채우고, 읽은 바이트 수를 반환</td>
</tr>
<tr>
<td>int read(byte b[], int offset, int len)</td>
<td>최대 len개의 바이트를 읽어 b의 offset 위치부터 채운다.</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납</td>
</tr>
<tr>
<td>int available()</td>
<td>읽을 수 있는 데이터의 크기를 반납</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>스트림에서 n만큼 건너 뛴다.</td>
</tr>
<tr>
<td>void mark(int readLimit)</td>
<td>reset()으로 돌아갈 위치를 표시한다. readLimit은 돌릴 수 있는 최대 바이트 수</td>
</tr>
<tr>
<td>void reset()</td>
<td>mark()가 호출된 지점으로 돌아간다.</td>
</tr>
<tr>
<td>boolean markSupported()</td>
<td>mark, reset 메소드의 지원 여부를 반환</td>
</tr>
</tbody></table>
<ul>
<li><p>기본 코드</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 여기서는 값을 계속 입력받게 무한루프에 빠지게 된다.(강제 종료를 시켜야한다.)</span></span><br><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123; <span class="comment">//autocloseable 자동으로 close 호출</span></span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span>((read = input.read()) != <span class="number">-1</span>) &#123; <span class="comment">//read는 1바이트를 읽어온다.</span></span><br><span class="line">     <span class="comment">//-1이나오면 더이상 읽을게 없다라고 의미하는 것이다.</span></span><br><span class="line">         System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>버퍼를 사용한 코드</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// byte[] bytes = new byte[2];</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">// 일단 read()안에 버퍼 bytes라고 매개값을 주게 되면, 이 버퍼의 길이만큼 배열안에 입력받은 값들이 담겨져</span></span><br><span class="line">    <span class="comment">// 그 값들의 개수를 반환 시킨다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 512의 크기를 준 것 처럼 한번에 담을 수 없는 큰 크기를 줬을 때 이것 또한 무한 루프에 빠지게 된다.</span></span><br><span class="line">    <span class="comment">// 근데 만약 2 같은 작은 크기를 줬을 때는 2개씩 짤려서 반환시켜서 read에 넣어주다가 마지막에 1개인 값만 남게 되면 반복문이 종료됨</span></span><br><span class="line">    <span class="comment">// 예로 abcd를 입력하고 엔터를치면 ab 두개를 짤라서 read넣으면 2 != 1이니깐 반복문을 한번더 돌고 cd도 2!=1이니깐</span></span><br><span class="line">    <span class="comment">// 한번더 도는데 엔터도 \n라고 값이 있는 것이기 때문에 1개의 값이 되서 종료된다.</span></span><br><span class="line">    <span class="comment">// 그래서 이렇게 작은 버퍼를 주게 되었을 때는 밑에 while문 안에 조건문을 주는 것이 의미가 없게 된다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// input.read(bytes)를 하게 되면 bytes의 크기만큼의 데이터를 읽어서 길이를 반환해주고, bytes안에 입력된 값들이 저장된다.</span></span><br><span class="line">    <span class="keyword">while</span>((read = input.read(bytes)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)bytes[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">// 버퍼를 사용할 때는 입력 받은 글자의 길이를 반환해주는 것이기 때문에</span></span><br><span class="line">    <span class="comment">// 버퍼를 사용할 경우에 어떠한 글자들을 입력해도 계속해서 입력 받을 수 있다.(0과 같지 않을 때라고 조건을 해놨기 때문에)</span></span><br><span class="line">    <span class="keyword">while</span>((read = input.read(bytes)) != <span class="number">0</span>) &#123;  <span class="comment">// 읽은 개수가 0이면 읽을게 없다라는 의미이다</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)bytes[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Stream의 mark/reset 기능</p>
<ul>
<li><p>mark - 스트림이 있고 내용이 차있을 때 하나씩 가져오는게 스트림의 read인데 마크를 호출하게 되면 해당 인덱스에 마킹이 된다<br>그다음 쭉쭉 진행이되다가 reset을하면 마크를 해놓은 부분을 기억해놨다가 마킹되어있는 부분으로 돌아가게 되는 기능이다.</p>
</li>
<li><p>System.out.println(System.in.markSupported()); // mark/reset 가능?하다는 의미 true/fase로 출력</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream input = System.<span class="keyword">in</span>)&#123; <span class="comment">//autocloseable 자동으로 close 호출</span></span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>((read = input.read()) != <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">char</span>)read == <span class="string">&#x27;m&#x27;</span>)&#123; <span class="comment">// m은 포함되지 않는다. 다음부터 마크가 된다.</span></span><br><span class="line">            input.mark(<span class="number">32</span>); <span class="comment">//몇개까지 기억을 할것이냐 32개를 기억함.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>)read == <span class="string">&#x27;r&#x27;</span>)&#123; <span class="comment">// r이 입력이 되면 reset이 호출된다.</span></span><br><span class="line">            input.reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Reader의 주요 메소드 (char 단위)<ul>
<li>stream과 유사하나, Reader는 char 단위로 읽어서 int로 반환</li>
<li>stream을 이용해서 Reader를 초기화할 수 있다.</li>
<li>char 단위로 동작하기때문에 한글도 깨지지 않고 잘 동작한다.</li>
<li>byte단위로 하면 한글은 읽어서 조합을 해줘야 한다.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>char 하나를 읽어서 int로 반환. 읽을 값이 없으면 -1</td>
</tr>
<tr>
<td>int read(char cbuf[])</td>
<td>데이터를 읽어 cbuf를 채우고, 읽은 char 수를 반환</td>
</tr>
<tr>
<td>int read(char cbuf[], int off, int len)</td>
<td>최대 len개의 char를 읽어 cbuf의 offset 위치부터 채운다.</td>
</tr>
<tr>
<td>int read(java.nio.CharBuffer target)</td>
<td>NIO target에 데이터를 저장한다.</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납</td>
</tr>
<tr>
<td>int available()</td>
<td>읽을 수 있는 데이터의 크기를 반납</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>스트림에서 n만큼 건너 뛴다.</td>
</tr>
<tr>
<td>void mark(int readAheadLimit)</td>
<td>reset()으로 돌아갈 위치를 표시한다. readLimit은 돌릴 수 있는 최대 바이트 수</td>
</tr>
<tr>
<td>void reset()</td>
<td>mark()가 호출된 지점으로 돌아간다.</td>
</tr>
<tr>
<td>boolean markSupported()</td>
<td>mark, reset 메소드의 지원 여부를 반환</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>))&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>((read = reader.read()) != <span class="number">1</span>) &#123;  </span><br><span class="line">          System.out.printf(<span class="string">&quot;Int: %d Char: %c\n&quot;</span>, read, read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>))&#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charbuffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>((read = reader.read(charbuffer)) != <span class="number">-1</span>) &#123;  </span><br><span class="line">        System.out.println(Arrays.toString(charbuffer));</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OutputStream과-Writer"><a href="#OutputStream과-Writer" class="headerlink" title="OutputStream과 Writer"></a>OutputStream과 Writer</h3><ul>
<li>OutputStream의 주요 메소드(byte 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>b 내용을 byte로 출력</td>
</tr>
<tr>
<td>void write(byte b[])</td>
<td>b를 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(byte b[], int off, int len)</td>
<td>b의 off부터 (off + len - 1)만큼을 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납. close() 내부적으로 flush() 호출</td>
</tr>
<tr>
<td>void flush()</td>
<td>버퍼 스트림에서 버퍼의 내용을 출력하고 비운다.</td>
</tr>
</tbody></table>
<ul>
<li>Writer의 주요 메소드 (char 단위)</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>c 내용을 char로 출력</td>
</tr>
<tr>
<td>void write(char cbuf[])</td>
<td>cbuf를 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(char cbuf[], int off, int len)</td>
<td>cbuf의 off부터 (off + len - 1)만큼을 문자열로 변환하여 출력</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>str을 출력한다.</td>
</tr>
<tr>
<td>void write(String str, int off, int len)</td>
<td>str의 off부터 (off + len - 1)만큼을 출력</td>
</tr>
<tr>
<td>Writer append(CharSequence csq)</td>
<td>csq를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>Writer append(CharSequence csq, int start, int end)</td>
<td>csq의 start부터 end까지를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>Writer append(char c)</td>
<td>c를 출력하고 Writer 반환</td>
</tr>
<tr>
<td>void close()</td>
<td>스트림을 종료하고 자원을 반납. close() 내부적으로 flush() 호출</td>
</tr>
<tr>
<td>void flush()</td>
<td>버퍼 스트림에서 버퍼의 내용을 출력하고 비운다.</td>
</tr>
</tbody></table>
<h3 id="다양한-입출력-처리"><a href="#다양한-입출력-처리" class="headerlink" title="다양한 입출력 처리"></a>다양한 입출력 처리</h3><ul>
<li><p>메모리 기반의 입/출력</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> [] memory = <span class="string">&quot;메모리 입출력 테스트 입력&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">char</span> [] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]; <span class="comment">//버퍼는 단순해야 단순하지 않으면 오히려 속도가 떨어진다.</span></span><br><span class="line"><span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 리소스를 두개 사용하는 방법 ;을 사용하여 나누면됨</span></span><br><span class="line"><span class="keyword">try</span> (CharArrayReader reader = <span class="keyword">new</span> CharArrayReader(memory);</span><br><span class="line">     CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter())&#123;</span><br><span class="line">     <span class="keyword">while</span> ((read = reader.read(cbuf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//writer.write(cbuf, 0,read); // (buffer, offset, len)</span></span><br><span class="line">          <span class="comment">// read 길이만큼 들어있는데 이때 몇개를 스킵할 수 있다 그때 사용하는게 offset</span></span><br><span class="line">          <span class="comment">// 1를 첫번째거빼고 2번째거 부터 하게된다는 의미이다. 0은 스킵없이 처음부터 한다는 것이고</span></span><br><span class="line">          <span class="comment">// len은 몇개까지 한다는 것  개수를 정해줘야 한다.</span></span><br><span class="line">          writer.write(cbuf); <span class="comment">//개수를 지정해주지 않으면 메모리에 남아있는게 마지막 문자뒤에 전에 문자가 붙어서 출력됨</span></span><br><span class="line">          <span class="comment">// 여기서는 [메,모,리, ,입,출,력, ,테,스,트, ,입, 력, 트, ] 이런식으로 출력이 된다.</span></span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(Arrays.toString(writer.toCharArray()));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>파일 기반의 입출력</p>
<ul>
<li><p>생성자 및 생성/삭제 메소드</p>
<table>
<thead>
<tr>
<th>생성자 및 메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>pathname에 해당하는 파일 생성. 기본 경로는 애플리케이션의 시작 경로</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>parent 경로 아래 child 파일 생성</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td>parent 경로 아래 child 파일 생성</td>
</tr>
<tr>
<td>File(URI uri)</td>
<td>file로 시작하는 URI 객체를 이용해 파일 생성</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>새로운 파일을 생성</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>새로운 디렉토리를 생성</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>경로상의 모든 디렉토리를 생성</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>파일/디렉토리 삭제</td>
</tr>
<tr>
<td>void deleteOnExit()</td>
<td>애플리케이션 종료시 자동으로 삭제</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String filePath = <span class="string">&quot;D:&quot;</span> + File.separator + <span class="string">&quot;Temp&quot;</span> + File.separator + <span class="string">&quot;MyTemp&quot;</span>;</span><br><span class="line"></span><br><span class="line">File fileOne = <span class="keyword">new</span> File(filePath);</span><br><span class="line">fileOne.mkdir(); <span class="comment">// 가장 하위 폴더만 생성 상위폴더가 없으면 실패</span></span><br><span class="line">fileOne.mkdirs(); <span class="comment">// 경로에 있는 모든 폴더를 생성한다.</span></span><br><span class="line">File fileTwo = <span class="keyword">new</span> File(filePath, <span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line">fileTwo.createNewFile(); <span class="comment">//성공 True 실패 false</span></span><br><span class="line"></span><br><span class="line">File fileThree = <span class="keyword">new</span> File(fileOne, <span class="string">&quot;file3.txt&quot;</span>);</span><br><span class="line">fileThree.createNewFile(); <span class="comment">// fileOne이 path이기 때문에 이것도 사용가능하다.</span></span><br><span class="line"></span><br><span class="line">File fileFour = <span class="keyword">new</span> File(<span class="keyword">new</span> URI(<span class="string">&quot;file:///d:/Temp/MyTemp/file4.txt&quot;</span>));</span><br><span class="line">fileFour.createNewFile();</span><br><span class="line">fileFour.deleteOnExit();</span><br><span class="line"><span class="comment">// Temp 파일을 사용할 때 유용하다, 4번파일을 생성했다가 프로그램이 종료될때 바로 삭제를 한다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>File 클래스의 주요 메소드</p>
<ul>
<li>getName(), getParent(), getParentFile(), getPath()</li>
<li>isAbsolute(), getAbsolutePath(), getCanonicalPath(), toURI()</li>
<li>canRead(), canWrite()</li>
<li>isDirectory(), isFile()</li>
<li>length(), list(), listFiles(), lastModified(), renameTo()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(fileTwo.getName()); <span class="comment">// 파일이름출력</span></span><br><span class="line">System.out.println(fileTwo.getParent()); <span class="comment">// parent에 해당하는 path 출력</span></span><br><span class="line">System.out.println(fileTwo.isAbsolute()); <span class="comment">// 절대 경로를 사용 하는지?</span></span><br><span class="line"><span class="comment">// 상대 경로는 프로그램을 실행하면 그위치에 파일을 만든다던지 그 내부에 만든다던지 할 수 있다</span></span><br><span class="line">    <span class="comment">// 파일을 실행하는 위치로부터 찾아가는 것</span></span><br><span class="line"><span class="comment">// 절대 경로 어디에서 찾아가도 똑같은 경로</span></span><br><span class="line">System.out.println(fileTwo.getAbsolutePath());</span><br><span class="line"><span class="comment">// 시작위치만 정해주고 그내부에서는 ..을 이용하던 다양한 방식으로 표현이가능하다.</span></span><br><span class="line"><span class="comment">// 절대경로라고 해서 우리가 알고있는 d:Temp/MyTemp 이런 형식의 깔끔한 경로가 반드시 나온다고 할 수 는 없다</span></span><br><span class="line"><span class="comment">// 절대 경로이지 표준형은 아닐 수 있다 그래서 깔끔한 경로만 표현해주는게 getCanonicalPath()</span></span><br><span class="line">System.out.println(fileTwo.getCanonicalPath()); <span class="comment">// 깔끔한 경로만 사용한다 , .. 등을 모두 배제한 표준 표현 법 사용</span></span><br><span class="line"><span class="comment">// 두개의 큰 차이는 없다.앱솔루트가 지저분해 질 수 있다 5:07</span></span><br><span class="line">System.out.println(fileOne.isDirectory()); <span class="comment">// 디렉토리를 가리키는지 윈도우즈 이전 도스에서 사용하던 표현 디렉토리</span></span><br><span class="line">System.out.println(fileTwo.isFile()); <span class="comment">// 파일을 가리키는지</span></span><br><span class="line">    </span><br><span class="line">System.out.println(Arrays.toString(fileOne.list())); <span class="comment">// 리스트를 이용해서 그안에 잇는 파일이름들을 다 출력함 String Array로 출력</span></span><br><span class="line"><span class="comment">// [files.txt,files2.txt...]</span></span><br><span class="line">System.out.println(Arrays.toString(fileOne.listFiles())); <span class="comment">// 파일의 경로까지 출력됨 File 객체로 출력이 나옴</span></span><br><span class="line"><span class="comment">// [D:/Temp/MyTemp/files.txt,D:/Temp/MyTemp/files2.txt ...]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>FileInputStream, FileOutputStream</p>
<ul>
<li>파일명이나 File 객체를 이용하여 입출력 스트림 생성 가능</li>
<li>FileOutputStream에서 boolean append를 true로 하면 기존 파일에 이어서 쓴다.</li>
</ul>
</li>
<li><p>FileReader, FileWriter</p>
<ul>
<li>파일명이나 File 객체를 이용하여 입출력 Reader 생성 가능</li>
<li>FileWriter에서 boolean append를 true로 하면 기존 파일에 이어서 쓴다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="보조-스트림"><a href="#보조-스트림" class="headerlink" title="보조 스트림"></a>보조 스트림</h2><h3 id="보조-스트림의-특징"><a href="#보조-스트림의-특징" class="headerlink" title="보조 스트림의 특징"></a>보조 스트림의 특징</h3><ul>
<li>스트림에 부가적인 기능 제공</li>
<li>노드(데이터 소스/목적지)와 직접 연결되지 않고, 다른 스트림과 연결</li>
<li>Stream Chaining : 스트림을 여러개 연결하여 사용</li>
</ul>
<h3 id="보조-스트림의-종류"><a href="#보조-스트림의-종류" class="headerlink" title="보조 스트림의 종류"></a>보조 스트림의 종류</h3><p>| 보조 스트림 | 기능 |<br>| InputStreamReader | byte 스트림을 char 스트림으로 변환 |<br>| OutputStreamWriter |    byte 스트림을 char 스트림으로 변환 |<br>| BufferedReader | 버퍼링을 통해 스트림 속도 향상 |<br>| BufferedWriter | 버퍼링을 통해 스트림 속도 향상 |<br>| BufferedInputStream |    버퍼링을 통해 스트림 속도 향상 |<br>| BufferedOutputStream | 버퍼링을 통해 스트림 속도 향상 |<br>| DataInputStream |    기본 데이터형 전송 |<br>| DataOutputStream | 기본 데이터형 전송 |<br>| ObjectInputStream | 객체 전송 |<br>| ObjectOuputStream | 객체 전송 |<br>| PrintWriter |    문자열 표현으로 출력 |<br>| PrintStream |    문자열 표현으로 출력 |</p>
<h3 id="스트림-자료형-변경"><a href="#스트림-자료형-변경" class="headerlink" title="스트림 자료형 변경"></a>스트림 자료형 변경</h3><ul>
<li>캐릭터셋: utf-8, ms949, euc-kr<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader readerOne = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>);</span><br><span class="line">InputStreamReader readerTwo = <span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">OutputStreamWriter writerOne = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line">OutputStreamWriter writerTwo = <span class="keyword">new</span> OutputStreamWriter(System.out, <span class="string">&quot;ms949&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="버퍼를-이용한-스트림"><a href="#버퍼를-이용한-스트림" class="headerlink" title="버퍼를 이용한 스트림"></a>버퍼를 이용한 스트림</h3><ul>
<li><p>기본 버퍼 크기: 8192 bytes</p>
</li>
<li><p>버퍼링을 사용하는 원리 </p>
<ul>
<li>입출력장치에 입력을받고출력을받고 해주면 기기를 사용하는데 있어서</li>
<li>한번 입력을 해주고 출력을해줄때 약간의 오버헤드가 발생한다.</li>
<li>키보드의 입력을 눌렀을 때 컴퓨터는 폴링방식을 이용하는데 계속해서 키보드에 있는 버퍼에 접근을 해서</li>
<li>우리가 가져올 데이터가 있는지 계속확인을 한다 매번하게될 경우 성능이 떨어진다 이게 평균전송속도측면에서 떨어지는 것이다.</li>
<li>대신 반응성은 빨라지게 된다. 두개 delay와 throughput은 tradeoff 관계에 있다,</li>
<li>우리가 동작이 빠르게 일어날 필요가 없다면 throughput을 향상시키는게 좋다</li>
<li>예로 파일의 입출력을 하게 될 경우 파일에 넣어서 작성을 할때 파일 즉 하드디스크에 계속 접근을 해서</li>
<li>쓰는 것보다 메모리에 일정량을 써놓고 한번에 하드디스크에 입력을 하는게 더 효율적이다</li>
<li>딜레이가 생겨도 througput이 더 좋은게 이득이여서 버퍼링을 사용하는게 더 이득이다.</li>
</ul>
</li>
<li><p>반응성이 중요한 경우 : 네트워크에서 게임을 한다했을 때 커멘드를 하나하입력할 때 반응성이 더 중요한 경우이다.</p>
</li>
<li><p>반응성이 중요하지 않은 경우(파일입출력, 네트워크 일부 경우(다운로드, 업로드…), 등등)</p>
</li>
<li><p>BufferedReader         ┬ 스트림에 버퍼링을 적용하여 스트림 throughput 형성</p>
</li>
<li><p>BuuferedWriter         ┤ throughput : 평균 전송 속도</p>
</li>
<li><p>BufferedInputStream    ┤ delay :반응성, 버퍼링을 쓸 경우 오히려 안좋아짐(딜레이시간이 길어지는 것이다) (네트워크에서 핑)</p>
</li>
<li><p>BuuferedOutputStream   ┘  서로 트레이드오프 관계에있다.</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> copyStream(InputStream input, OutputStream output) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">byte</span> [] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">int</span> read = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> ((read = input.read(buff) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    output.write(buff, <span class="number">0</span>, read);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">  File src = <span class="keyword">new</span> File(<span class="string">&quot;C:/Windows/explorer.exe&quot;</span>);</span><br><span class="line">  File dst = <span class="keyword">new</span> File(<span class="string">&quot;C:/temp/explorer.exe&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> (FileInputStream <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">       FileOutputStream out = <span class="keyword">new</span> FileOutputStream(dst);</span><br><span class="line">       BufferedInputStream buffIn = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">in</span>);</span><br><span class="line">       BufferedOutputStream buffOut = <span class="keyword">new</span> BufferedOutputStream(out)) &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    copyStream(<span class="keyword">in</span>, out);</span><br><span class="line">    System.out.println(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    copyStream(buffIn, buffOut);</span><br><span class="line">    System.out.println(System.nanoTime() - start);</span><br><span class="line">    <span class="comment">// 버퍼를 사용하면 throughput이 향상된다.</span></span><br><span class="line">    <span class="comment">// 반응성이 중요하지 않은 경우 거의 반드시 써야한다고 생각하면 된다.</span></span><br><span class="line">    <span class="comment">// 반응성이 중요하면 버퍼를 사용하지 않으면 좋겠다라고 생각하면 됨.</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BufferedReader는 readLine() 메소드를 사용할 수 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File src = <span class="keyword">new</span> File(<span class="string">&quot;./src.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (BufferedReader buffReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));) &#123;</span><br><span class="line">  String line = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="기본-데이터형-전송-스트림"><a href="#기본-데이터형-전송-스트림" class="headerlink" title="기본 데이터형 전송 스트림"></a>기본 데이터형 전송 스트림</h3><ul>
<li>byte, char 외에 다른 기본 데이터형도 전송 가능한 스트림<ul>
<li>읽은 후에는 자료형을 알 수 없으므로 쓴 순서대로 읽어야 함</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>클래스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>DataInputStream</td>
<td>boolean readBoolean()</td>
</tr>
<tr>
<td></td>
<td>byte readByte()</td>
</tr>
<tr>
<td></td>
<td>short readShort()</td>
</tr>
<tr>
<td></td>
<td>int readInt()</td>
</tr>
<tr>
<td></td>
<td>long readLong()</td>
</tr>
<tr>
<td></td>
<td>float readFloat()</td>
</tr>
<tr>
<td></td>
<td>double readDouble()</td>
</tr>
<tr>
<td></td>
<td>char readChar()</td>
</tr>
<tr>
<td></td>
<td>String readUTF()</td>
</tr>
<tr>
<td>DataOutputStream</td>
<td>void writeBoolean(bool v)</td>
</tr>
<tr>
<td></td>
<td>void writeByte(byte v)</td>
</tr>
<tr>
<td></td>
<td>void writeShort(short v)</td>
</tr>
<tr>
<td></td>
<td>void writeInt(int v)</td>
</tr>
<tr>
<td></td>
<td>void writeLong(long v)</td>
</tr>
<tr>
<td></td>
<td>void writeFloat(float v)</td>
</tr>
<tr>
<td></td>
<td>void writeDouble(double v)</td>
</tr>
<tr>
<td></td>
<td>void writeChar(char v)</td>
</tr>
<tr>
<td></td>
<td>void writeUTF(String v)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">File src = <span class="keyword">new</span> File(<span class="string">&quot;c:/Temp/data.dat&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(src))) &#123;</span><br><span class="line">  out.writeUTF(<span class="string">&quot;김자바&quot;</span>);</span><br><span class="line">  out.writeInt(<span class="number">15</span>);</span><br><span class="line">  out.writeFloat(<span class="number">14.23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 중요!! 읽어올 때는 위에 쓴 순서대로 읽어와야한다 그렇지않으면 디코딩이 제대로 이뤄지지 않음</span></span><br><span class="line"><span class="keyword">try</span> (DataInputStream <span class="keyword">in</span> = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(src))) &#123;</span><br><span class="line">  String string = <span class="keyword">in</span>.readUTF();</span><br><span class="line">  <span class="keyword">int</span> integer = <span class="keyword">in</span>.readInt();</span><br><span class="line">  <span class="keyword">float</span> floatNum = <span class="keyword">in</span>.readFloat();</span><br><span class="line">  System.out.println(string + <span class="string">&quot; &quot;</span> + integer + <span class="string">&quot; &quot;</span> + floatNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="객체-저장을-위한-스트림"><a href="#객체-저장을-위한-스트림" class="headerlink" title="객체 저장을 위한 스트림"></a>객체 저장을 위한 스트림</h3><ul>
<li>일반적인 참조형 객체를 저장하기 위한 스트림</li>
<li>직렬화(Serialization)와 역직렬화(Deserialization) 사용<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span> <span class="comment">// has-a 관계의 모든 클래스가 Serializable이어야 함</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L; <span class="comment">// 객체의 버전 관리</span></span><br><span class="line"></span><br><span class="line">  String userName;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">transient</span> String passWord;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> userName + <span class="string">&quot; &quot;</span> + id + <span class="string">&quot; &quot;</span> + passWord;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main (String [] args) &#123;</span><br><span class="line">    File dst = <span class="keyword">new</span> File(<span class="string">&quot;C:/Temp/obj.data&quot;</span>);</span><br><span class="line">    Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">    foo.userName = <span class="string">&quot;김사탕&quot;</span>;</span><br><span class="line">    foo.id = <span class="number">142</span>;</span><br><span class="line">    foo.passWord = <span class="string">&quot;qwer1234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(dst));</span><br><span class="line">        ObjectInputStream <span class="keyword">in</span> = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(dst));) &#123;</span><br><span class="line">      out.writeObject(foo);</span><br><span class="line">      Object read = <span class="keyword">in</span>.readobject();</span><br><span class="line">      <span class="keyword">if</span> (read != <span class="literal">null</span> &amp;&amp; read <span class="keyword">instanceof</span> Foo) &#123;</span><br><span class="line">        Foo readFoo = (Foo)read;</span><br><span class="line">        System.out.println(readFoo);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>부모 클래스가 Serializable이 아닌 경우 자식 클래스에서 직접 처리<ul>
<li>writeObject(), readObject()를 자식 클래스에서 직접 구현<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentFoo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> memVarOne;</span><br><span class="line">  <span class="keyword">double</span> memVarTwo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildFoo</span> <span class="keyword">extends</span> <span class="title">ParentFoo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> writeObject(ObjectOutputStream out) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    out.writeInt(memVarOne);</span><br><span class="line">    out.writeDouble(memVarTwo);</span><br><span class="line">    out.defaultWriteObject();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> readObject(ObjectInputStream <span class="keyword">in</span>) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    memVarOne = <span class="keyword">in</span>.readInt();</span><br><span class="line">    memVarTwo = <span class="keyword">in</span>.readDouble();</span><br><span class="line">    <span class="keyword">in</span>.defaultReadObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/10/07/Java/JavaAdvanced/Java-JavaInputOutput/" data-id="ckgxjhqea002ncwu29ed1f5rs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-Java_langPackage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/29/Java/JavaAdvanced/Java-Java_langPackage/" class="article-date">
  <time datetime="2020-09-29T10:43:02.136Z" itemprop="datePublished">2020-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/29/Java/JavaAdvanced/Java-Java_langPackage/">Java_Java-lang Package</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java-lang-패키지"><a href="#java-lang-패키지" class="headerlink" title="java.lang 패키지"></a>java.lang 패키지</h1><h2 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h2><ul>
<li>Java에서 가장 기본적이며 자주 사용되는 클래스를 모은 패키지</li>
<li>별도로 import하지 않아도 사용이 가능한, Java의 기본 중의 기본</li>
</ul>
<h2 id="ObjectClass"><a href="#ObjectClass" class="headerlink" title="ObjectClass"></a>ObjectClass</h2><ul>
<li>모든 클래스의 최상위 클래스</li>
<li>java.lang.Object 클래스</li>
<li>모든 클래스는 Object 클래스에서 상속 받는다.</li>
<li>모든 클래스는 Object 클래스의 메소드를 사용할 수 있다.</li>
<li>모든 클래스는 Object 클래스의 일부 메소드를 재정의하여 사용할 수 있다.<ul>
<li>final로 재정의된 메소드들은 하위클래스에서 재정의 할 수 없기 때문에 일부 메소드만 재정의할 수 있다 라고 하는 것</li>
</ul>
</li>
</ul>
<h3 id="ObjectClass의-메소드"><a href="#ObjectClass의-메소드" class="headerlink" title="ObjectClass의 메소드"></a>ObjectClass의 메소드</h3><table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>public final native Class&lt;?&gt; getClass()</td>
<td>현재 객체의 클래스를 반환한다.</td>
</tr>
<tr>
<td>public native int hashCode()</td>
<td>현재 객체의 해시코드 값을 반환한다.</td>
</tr>
<tr>
<td>public boolean equals()</td>
<td>현재 객체와 대상이 같은 객체를 참조하는지 여부를 반환한다.</td>
</tr>
<tr>
<td>public String toString()</td>
<td>객체를 문자열로 변환하여 반환한다.</td>
</tr>
<tr>
<td>proteted native clone()</td>
<td>throws CloneNotSupportedException 객체를 복사하여 새로운 객체로 반환한다.</td>
</tr>
</tbody></table>
<ul>
<li><p>Object는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 같은 해쉬코드를 가질 수 없지만,<br>String은 문자열의 내용이 같으면 같은 해시코드를 반환하도록 hasCode()가 오버라이딩 되어있다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">Object obj1 = obj;</span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(obj.getClass()); <span class="comment">// Class 클래스 객체를 반환하게 된다.</span></span><br><span class="line">System.out.println(<span class="string">&quot;obj&quot;</span>+obj.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;obj1&quot;</span>+obj1.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;obj2 &quot;</span>+obj2.hashCode());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 힙안에 있는 스트링 풀에 들어감</span></span><br><span class="line">String str2 = str1;</span><br><span class="line">String str3 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//이미 들어가있는 스트링풀을 가리킨다. 그래서 동일한 객체가 된다.</span></span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// new로 만들경우는 새로운 객체를 명시적으로 생성해줬기 때문에 다르다</span></span><br><span class="line">System.out.println(<span class="string">&quot;str1 &quot;</span>+str1.hashCode()); </span><br><span class="line">System.out.println(<span class="string">&quot;str4 &quot;</span>+str4.hashCode());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="toString-메소드"><a href="#toString-메소드" class="headerlink" title="toString() 메소드"></a>toString() 메소드</h4></li>
<li><p>toString()메소드의 원형</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>
</li>
<li><p>객체의 정보를 String으로 바꾸어 사용할 때 유용하다.</p>
</li>
<li><p>자바 클래스 중에는 이미 정의된 클래스가 많다.</p>
<ul>
<li>예 : String, Integer, Calender 등</li>
</ul>
</li>
<li><p>많은 클래스에서 재정의하여 사용한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends Object 된 것과 같다 컴파일 할 때 자동으로 생성이 된다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book(String title, String author)&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> author+<span class="string">&quot;,&quot;</span>+title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Book book =  <span class="keyword">new</span> Book(<span class="string">&quot;토지&quot;</span>,<span class="string">&quot;박경리&quot;</span>);</span><br><span class="line">        System.out.println(book.toString());</span><br><span class="line">        <span class="comment">// toString을 재정의하지 않았을 때, 메모리 주소가 출력된다.</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;토지&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        <span class="comment">// String 안에 이미 toString()메소드가 정의되어 있어서</span></span><br><span class="line">        <span class="comment">// String클래스 안에 있는 Character의 배열을 출력하도록 되어 있다.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="equals-메소드"><a href="#equals-메소드" class="headerlink" title="equals() 메소드"></a>equals() 메소드</h4></li>
<li><p>두 객체의 동일함을 논리적으로 재정의 할 수 있다.</p>
</li>
<li><p>물리적 동일함 : 객체 같은 메모리 주소를 가지는 있다. </p>
</li>
<li><p>논리적 동일함 : 객체가 실제로 같은 값을 가지고 있다.(같은 학번의 학생, 같은 주문 번호의 주문 등)</p>
</li>
<li><p>물리적으로 다른 메모리에 위치한 객체라도 논리적으로 동일함을 구현하기 위해 사용하는 메소드</p>
</li>
<li><p>원래 ObjectClass의 equals()메소드는 <code>==</code>와 똑같이 메모리 주소를 반환하게 되어있다.<br>그래서 객체를 만들 때 equlas() 메소드를 사용했을 때 메모리 주소가 같은지를 확인하게 되어있어서 값이 같은지를 비교하게 하고 싶을 때는<br>재정의하여 사용하면 된다.</p>
</li>
</ul>
<p><img src="../../../image/equals.jpg" alt="equals"></p>
<h5 id="equals-메소드-예제"><a href="#equals-메소드-예제" class="headerlink" title="equals() 메소드 예제"></a>equals() 메소드 예제</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> studentNum;</span><br><span class="line">    String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student(<span class="keyword">int</span> studentNum, String studentName)&#123;</span><br><span class="line">        <span class="built_in">this</span>.studentName = studentName;</span><br><span class="line">        <span class="built_in">this</span>.studentNum = studentNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> equals(Object obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            Student std = (Student)obj;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.studentNum == std.studentNum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Student lee = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="string">&quot;이상원&quot;</span>);</span><br><span class="line">        Student lee2 =lee;</span><br><span class="line">        Student won = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="string">&quot;이상원&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lee == lee2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(lee == won);<span class="comment">//false equals()메소드 재정의 전</span></span><br><span class="line">        System.out.println(lee.equals(won)); <span class="comment">//equals()메소드 재정의 전(false), 후(true) </span></span><br><span class="line"></span><br><span class="line">        System.out.println(lee.hashCode());</span><br><span class="line">        System.out.println(won.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="String-비교-예제"><a href="#String-비교-예제" class="headerlink" title="String 비교 예제"></a>String 비교 예제</h5><ul>
<li>원래 ObjectClass의 equals()메소드는 <code>==</code>와 똑같이 메모리 주소를 반환하게 되어있는데, String클래스에서 재정의했다.<br>그래서 String은 문자열이 같으면 true를 반환하도록 재정의 되어 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//메모리 주소가 같은가 를 확인</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//두개의 문자열이 같은가를 확인</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="hashCode-메소드"><a href="#hashCode-메소드" class="headerlink" title="hashCode() 메소드"></a>hashCode() 메소드</h4><ul>
<li><p>자바에서 JVM이 있는데 인스턴스가 생성이 됬을 때 메모리 주소를 준다. 그 주소 값을 <code>hashCode</code>라고 한다.</p>
</li>
<li><p>hashCode() 메소드의 반환값: 인스턴스가 저장된 가상머신의 주소를 10진수로 반환</p>
</li>
<li><p>두 개의 서로 다른 메모리에 위치한 인스턴스가 동일하다는 것은?</p>
<ul>
<li>논리적으로 동일 : equals()의 반환 값이 true</li>
<li>동일한 hashCode 값을 가짐 : hashCode()의 반환 값이 동일하다.</li>
</ul>
</li>
<li><p><code>navtive</code> 메소드이므로 구현 내용을 볼 수 없다.</p>
<ul>
<li>native : c 또는 c++등 외부 언어로 작성된 메소드 속도 최적화를 위해서 자바로 구현되어 있지 않다!<br>jvm에 종속 되어 있어야 하고 그런 문제가 있어서</li>
</ul>
</li>
<li><p>실제 메모리 값이 아닌 hashCode값이 동일해야 객체들이 동일하다고 말할 수 있다.</p>
</li>
<li><p>실제 메모리 값은 그대로 있다. 단지 overriding만 하는 것이다.</p>
</li>
<li><p>일반적으로 equals를 오버라이딩하면 hasCode도 오버라이딩 한다.</p>
<ul>
<li>equals()의 반환 값이 true 일때, hashcode도 같은 값이 반환될 수 있도록 한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">100</span>;</span><br><span class="line">Integer i2 = <span class="number">100</span>;</span><br><span class="line">System.out.println(i1.equals(i2));</span><br><span class="line">System.out.println(i1.hashCode());</span><br><span class="line">System.out.println(i2.hashCode());</span><br><span class="line"></span><br><span class="line">System.out.println(System.identityHashCode(i1));</span><br><span class="line">System.out.println(System.identityHashCode(i2)); <span class="comment">//진짜 메모리 값 확인하는 메소드</span></span><br></pre></td></tr></table></figure>
<h5 id="hashCode-의-제한-사항"><a href="#hashCode-의-제한-사항" class="headerlink" title="hashCode()의 제한 사항"></a>hashCode()의 제한 사항</h5></li>
</ul>
</li>
<li><p>한 객체의 hashCode()를 여러 번 호출할 경우, equals()에 사용하는 값이 변하지 않으면<br>동일한 값을 반환해야 한다.</p>
</li>
<li><p>equals() 메소드가 같다고 판단한 두 객체의 hashCode() 반환값은 같아야 한다.</p>
</li>
<li><p>equals() 메소드가 다르다고 판단한 두 객체의 hashCode()가 반드시 다를 필요는 없으나,<br>다른 값이 나오면 HashTable 성능이 향상된다.</p>
</li>
</ul>
<h4 id="clone-메소드"><a href="#clone-메소드" class="headerlink" title="clone() 메소드"></a>clone() 메소드</h4><ul>
<li>객체의 복사본을 만듦</li>
<li>기본 틀(prototype)로부터 같은 속성 값을 가진 객체의 복사본을 생성할 수 있음</li>
<li>객체지향 프로그래밍의 정보은닉에 위배될 가능성이 있으므로 복제할 객체는 cloneable 인터페이스를 명시해야 한다.</li>
<li>같은 객체를 동일하게 인스턴스 값을 동일하게 해서 만드는 것</li>
</ul>
<h4 id="join-메소드-과-StringJoiner-클래스"><a href="#join-메소드-과-StringJoiner-클래스" class="headerlink" title="join()메소드 과 StringJoiner 클래스"></a>join()메소드 과 StringJoiner 클래스</h4><ul>
<li><p>join()은 문자열 사이에 구분자를 넣어서 결합한다</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;CCC&quot;</span>&#125;;</span><br><span class="line">String strJoin = String.join(<span class="string">&quot;-&quot;</span>,strArr);</span><br><span class="line">System.out.println(<span class="string">&quot;strJoin &quot;</span>+strJoin);</span><br></pre></td></tr></table></figure>
</li>
<li><p>java.util.StringJoiner 클래스를 사용하여 문자열을 결합한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String <span class="attr">s :</span> strArr)&#123;</span><br><span class="line">    sj.add(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;String Joiner &quot;</span>+ sj);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="기본형에서-String으로-변환"><a href="#기본형에서-String으로-변환" class="headerlink" title="기본형에서 String으로 변환"></a>기본형에서 String으로 변환</h4><ul>
<li>숫자에 빈문자열(“”)을 더하여서 String형으로 변환 시킬 수 있다.</li>
<li>valueOf() 메소드를 사용하여 변환 할 수 있다.</li>
<li>valueOf()의 반환타입은 int가 아니라 Integer지만 오토박싱에 의해 자동변환</li>
<li>valueOf(String s) 는 메소드 내부에 parseInt(String s)를 호출할 뿐이므로,<br>두 메소드는 반환 타입만 다르고 같은 메소드다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="number">100</span> + <span class="string">&quot;&quot;</span>; <span class="comment">// 100 &gt; &quot;100&quot;</span></span><br><span class="line">String str2 = String.valueOf(<span class="number">100</span>); <span class="comment">// 100 &gt; &quot;100&quot;</span></span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;100&quot;</span>) <span class="comment">// &quot;100&quot; &gt; 100</span></span><br><span class="line"><span class="keyword">int</span> i2 = Integer.valueOf(<span class="string">&quot;100&quot;</span>) <span class="comment">// &quot;100&quot; &gt; 100</span></span><br></pre></td></tr></table></figure>

<h5 id="주의"><a href="#주의" class="headerlink" title="주의"></a>주의</h5><ul>
<li>생성자와는 다르다. 생성자는 기본 초기화를 하면서 만드는데 이건 인스턴스의 상태를 그대로 복제하는 것 </li>
<li>private필드까지 다 복제해올 수 있어서 정보은닉에 위배될 수 있어서 객체 복제를 할 때 cloneable 인터페이스가 명시되어 있어야 한다.</li>
<li>clone() 메소드를 사용할 때 object 형으로 반환되므로 다운캐스팅을 해줘야한다.</li>
<li>구현 클래스에 Cloneable 인터페이스를 implements해야 한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>&#123;</span></span><br><span class="line">    String title;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book(String title, String author)&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> author+<span class="string">&quot;,&quot;</span>+title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object clone() <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        Book book =  <span class="keyword">new</span> Book(<span class="string">&quot;토지&quot;</span>,<span class="string">&quot;박경리&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Book book2 =(Book)book.clone();</span><br><span class="line">        <span class="comment">//book.clone()이렇게 했을 때 object 자료형으로 반환이되서</span></span><br><span class="line">        <span class="comment">//명시적으로 다운캐스팅을 해줘야하고 예외처리를 해줘야 한다.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(book2);</span><br><span class="line">        <span class="comment">//그냥하면 예외가 발생함</span></span><br><span class="line">        <span class="comment">// 이유 위에 cloneable 인터페이스를 implements 하지 않아서</span></span><br><span class="line">        <span class="comment">// 이런 인터페이스를 마크인터페이스라고 한다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="finalize-메소드"><a href="#finalize-메소드" class="headerlink" title="finalize() 메소드"></a>finalize() 메소드</h4><ul>
<li>직접 불러서 사용하는 메소드는 아니다.</li>
<li>이 메소드는 객체가 heap 메모리에서 해체될 때, gc에서 호출되는 메소드이다.<br>이게 정의가 되어 있으면 gc가 이 메소드 부분을 수행한다.</li>
<li>주로 리소스 해제, 안 닫혔을 소켓을 닫는다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> finalize() <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="built_in">super</span>.finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><ul>
<li>실행 중인 OS와 interact하기 위한 클래스</li>
<li>System 클래스의 주요 정적 변수</li>
</ul>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>public static final PrintStream err</td>
<td>오류를 출력하기 위한 표준 출력 스트림</td>
</tr>
<tr>
<td>public static final InputStream in</td>
<td>표준 입력을 처리하기 위한 입력 스트림</td>
</tr>
<tr>
<td>public static final PrintStream out</td>
<td>표준 출력을 처리하기 위한 출력 스트림</td>
</tr>
</tbody></table>
<ul>
<li><p>System 클래스의 주요 정적 메소드</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>arraycopy()</td>
<td>src 배열의 내용을 dst 배열로 복사한다.</td>
</tr>
<tr>
<td>currentTimeMillis()</td>
<td>현재 시스템 시간을 ms로 반환한다.</td>
</tr>
<tr>
<td>exit()</td>
<td>프로그램을 종료한다.</td>
</tr>
<tr>
<td>gc()</td>
<td>GC를 요청한다.</td>
</tr>
<tr>
<td>getenv()</td>
<td>환경 변수의 값을 반환한다.</td>
</tr>
<tr>
<td>getProperties()</td>
<td>시스템 속성을 Property로 반환한다.</td>
</tr>
<tr>
<td>getProperty()</td>
<td>시스템 속성 값을 문자열로 반환한다. 없을 경우 null 또는 def를 반환</td>
</tr>
<tr>
<td>identityHashCode()</td>
<td>객체의 해시코드 값을 반환한다.</td>
</tr>
<tr>
<td>lineSeparator()</td>
<td>시스템의 줄넘김 문자열을 반환한다. UNIX: \n, WINDOWS: \r\n</td>
</tr>
<tr>
<td>nanoTime()</td>
<td>시스템 시간을 ns로 반환한다.</td>
</tr>
<tr>
<td>setProperties()</td>
<td>시스템 속성을 한번에 설정한다.</td>
</tr>
<tr>
<td>setProperty()</td>
<td>시스템 속성을 하나씩 설정한다.</td>
</tr>
</tbody></table>
<ul>
<li><p>주요 메소드</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>user.country</td>
<td>OS 로케일 정보</td>
</tr>
<tr>
<td>java.io.tmpdir</td>
<td>임시 경로</td>
</tr>
<tr>
<td>line.separator</td>
<td>줄넘김 문자열</td>
</tr>
<tr>
<td>user.home</td>
<td>유저 홈 경로</td>
</tr>
<tr>
<td>file.separator</td>
<td>파일 경로 구분</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><ul>
<li><p>수학 계산에 필요한 메소드를 가진 final 클래스</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>abs()</td>
<td>절대값을 반환한다.</td>
</tr>
<tr>
<td>ceil()</td>
<td>올림 값을 double로 반환한다.</td>
</tr>
<tr>
<td>floor()</td>
<td>내림 값을 double로 반환한다.</td>
</tr>
<tr>
<td>max()</td>
<td>두 값 중 더 큰 값을 반환한다.</td>
</tr>
<tr>
<td>min()</td>
<td>두 값 중 더 작은 값을 반환한다.</td>
</tr>
<tr>
<td>random()</td>
<td>0 이상 1.0 미만의 임의의 값을 반환한다.</td>
</tr>
<tr>
<td>round()</td>
<td>소수점 첫째자리에서 반올림한 정수 값을 반환한다.</td>
</tr>
<tr>
<td>addExact()</td>
<td>덧셈 연산으로, Overflow 발생 시 ArithmaticException 발생.</td>
</tr>
<tr>
<td>subtractExact()</td>
<td>뺄셈 연산으로, Overflow 발생 시 ArithmaticException 발생.</td>
</tr>
<tr>
<td>multiplyExact()</td>
<td>곱셈 연산으로, Overflow 발생 시 ArithmaticException 발생.</td>
</tr>
</tbody></table>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/29/Java/JavaAdvanced/Java-Java_langPackage/" data-id="ckgxjhqcs001icwu28grv0uqx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-StreamAPI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/Java/JavaAdvanced/Java-StreamAPI/" class="article-date">
  <time datetime="2020-09-27T12:41:16.159Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/27/Java/JavaAdvanced/Java-StreamAPI/">Java_StreamAPI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="스트림-API-Stream-API"><a href="#스트림-API-Stream-API" class="headerlink" title="스트림 API(Stream API)"></a>스트림 API(Stream API)</h1><ul>
<li>여기서 말하는 스트림과 나중에 자바 io에서 말하는 스트림은 다른 것이다.<ul>
<li>여기서의 스트림은 자료의 연산을 위해서 사용하는 객체를 말한다.</li>
<li>자바 io에서의 스트림은 입출력을 위한 스트림이다.<h2 id="스트림-API"><a href="#스트림-API" class="headerlink" title="스트림 API"></a>스트림 API</h2></li>
</ul>
</li>
<li>Java 8에서 추가된 Java.util.stream 패키지</li>
<li>컬렉션의 요소를 람다식으로 처리할 수 있도록 하는 함수형 프로그래밍 도구</li>
<li>스트림 API는 데이터를 추상화하여 다루므로, 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공한다.</li>
<li>따라서 스트림 API를 이용하면 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방법으로 다룰 수 있게 된다.</li>
<li>중간 연산과 최종 연산으로 구분 된다,최종 연산이 수행되어야 모든 연산이 적용되는 지연 연산이다.</li>
</ul>
<h3 id="스트림의-특징"><a href="#스트림의-특징" class="headerlink" title="스트림의 특징"></a>스트림의 특징</h3><h4 id="1-스트림은-한-번-밖에-사용-못한다"><a href="#1-스트림은-한-번-밖에-사용-못한다" class="headerlink" title="1. 스트림은 한 번 밖에 사용 못한다."></a>1. 스트림은 한 번 밖에 사용 못한다.</h4><ul>
<li>내부적으로 몇번째 동작을 하고 있는지 체크하는 것이 들어가 있다. 그래서 사용할 때마다 다시 정의해주고 사용해야 한다.<h4 id="2-간결한-코드로-작성할-수-있다"><a href="#2-간결한-코드로-작성할-수-있다" class="headerlink" title="2. 간결한 코드로 작성할 수 있다."></a>2. 간결한 코드로 작성할 수 있다.</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존의 Java 7방식의 작성 방법</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;fast&quot;</span>,<span class="string">&quot;campus&quot;</span>,<span class="string">&quot;rocks&quot;</span>);</span><br><span class="line">List&lt;String&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String <span class="attr">s :</span> list)&#123;</span><br><span class="line">    newList.add(s.toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String <span class="attr">s :</span> newList)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 8 - Stream API -&gt; 훨씬 더 간결한 코드로 작성할 수 있다.</span></span><br><span class="line">List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;fast&quot;</span>,<span class="string">&quot;campus&quot;</span>,<span class="string">&quot;rocks&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list1.stream(); <span class="comment">//스트림으로 변환해준다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 스트링에서 스트림으로 매핑해준다.</span></span><br><span class="line"><span class="comment">//uppercase를 string에 매핑, 각각의 요소에 적용해라</span></span><br><span class="line">stream.map(<span class="attr">String:</span>:toUpperCase).forEach(System.<span class="attr">out:</span>:println); <span class="comment">// foreach는 Consumer를 받는다,각각의 요소를 하나씩 출력한다.</span></span><br></pre></td></tr></table></figure>
<h4 id="3-데이터-소스에-대한-공통된-접근-방식-제공"><a href="#3-데이터-소스에-대한-공통된-접근-방식-제공" class="headerlink" title="3. 데이터 소스에 대한 공통된 접근 방식 제공."></a>3. 데이터 소스에 대한 공통된 접근 방식 제공.</h4></li>
<li>Stream으로 변경해주고 나면, List, Set, Map 모두 동일한(표준화된) 방식으로 데이터를 접근 가능.</li>
<li>컬렉션 프레임워크는 각각을 다른 방식으로 데이터를 처리 해줘야 한다.</li>
<li>특히 Stream::sorted() 메소드는 공통된 정렬 방식을 제공한다.</li>
</ul>
<h4 id="4-중간-처리와-최종-처리를-지원한다"><a href="#4-중간-처리와-최종-처리를-지원한다" class="headerlink" title="4.중간 처리와 최종 처리를 지원한다."></a>4.중간 처리와 최종 처리를 지원한다.</h4><ul>
<li>Mapping, Filtering, Sorting 등 중간 처리 지원(여러 개 사용이 가능하다.)</li>
<li>Iteration, Count, Average, Summation, Reduce 등 최종 처리 지원(마지막에 하나 사용 가능하다.)</li>
</ul>
<h4 id="5-데이터-소스와-처리-결과를-분리"><a href="#5-데이터-소스와-처리-결과를-분리" class="headerlink" title="5.데이터 소스와 처리 결과를 분리"></a>5.데이터 소스와 처리 결과를 분리</h4><ul>
<li>원본 데이터를 유지하여 처리하는 것에 의한 부작용을 방지한다.</li>
<li>처리 결과를 새로운 컬렉션으로 저장이 가능하다.</li>
</ul>
<h4 id="6-람다식으로-요소-처리-코드를-제공한다"><a href="#6-람다식으로-요소-처리-코드를-제공한다" class="headerlink" title="6. 람다식으로 요소 처리 코드를 제공한다."></a>6. 람다식으로 요소 처리 코드를 제공한다.</h4><ul>
<li>스트림이 제공하는 대부분의 요소처리 메소드는 함수적 인터페이스 매개타입을 가진다.   </li>
<li>매개값으로 람다식 또는 메소드 참조를 대입할 수 있다.<br>(함수적 인터페이스 매개타입을 가지기 때문에 람다식,메소드 참조로 매개값을 제공할 수 있음)</li>
</ul>
<h4 id="7-내부-반복자를-사용하므로-병렬-처리가-쉽다"><a href="#7-내부-반복자를-사용하므로-병렬-처리가-쉽다" class="headerlink" title="7. 내부 반복자를 사용하므로 병렬 처리가 쉽다."></a>7. 내부 반복자를 사용하므로 병렬 처리가 쉽다.</h4><ul>
<li><p>외부 반복자 - 개발자가 코드로 직접 컬렉션 요소를 반복해서 요청하고 가져오는 코드패턴<br>(Iterator를 생각하면 될 것 같다. Iterator을 사용해서 반복문을 구현해서 하나씩 값을 출력하게<br>코드를 구현해야 하는 것을 말하는 것 같다.)</p>
</li>
<li><p>내부 반복자 - 컬렉션 내부에서 요소들을 반복시키고 개발자는 요소당 처리해야할 코드만 제공하는 코드 패턴<br> (forEach메소드 처럼 내부가 어떻게 구현되어있는지 모르지만 이것을 사용하면 요소들 하나씩 가져오라는 코드가 없지만<br> 알아서 반복해서  반환시켜 처리해준다. 이런 것을 의미하는 것 같다)</p>
</li>
<li><p>내부 반복자의 이점 - 개발자는 요소 처리 코드에만 집중, 멀티 코어 cpu를 활용하기 위해 요소들을 분배시켜 병렬 처리 작업을 수 있다.</p>
<ul>
<li>컬렉션의 요소가 많을 경우에 요소를 나눠서 별도의 스트림으로 만들어서 각각의 코어에서 병렬적으로 처리할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="스트림-API를-이용한-자료-처리"><a href="#스트림-API를-이용한-자료-처리" class="headerlink" title="스트림 API를 이용한 자료 처리"></a>스트림 API를 이용한 자료 처리</h2><h3 id="스트림-API의-종류"><a href="#스트림-API의-종류" class="headerlink" title="스트림 API의 종류"></a>스트림 API의 종류</h3><table>
<thead>
<tr>
<th>종류</th>
<th>처리 대상</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td>일반적인 객체를 처리</td>
</tr>
<tr>
<td><code>IntStream</code></td>
<td>기본 자료형 <code>int</code>를 처리</td>
</tr>
<tr>
<td><code>LongStream</code></td>
<td>기본 자료형 <code>long</code>을 처리</td>
</tr>
<tr>
<td><code>DoubleStream</code></td>
<td>기본 자료형 <code>double</code>을 처리</td>
</tr>
</tbody></table>
<h3 id="스트림-객체-생성-메소드"><a href="#스트림-객체-생성-메소드" class="headerlink" title="스트림 객체 생성 메소드"></a>스트림 객체 생성 메소드</h3><ul>
<li>데이터 소스(인터페이스, 클래스)로부터 스트림 생성</li>
</ul>
<table>
<thead>
<tr>
<th>데이터 소스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Collection</td>
<td>default Stream<E> stream()</td>
</tr>
<tr>
<td>Collection</td>
<td>default Stream<E> parallelStream()</td>
</tr>
<tr>
<td>Arrays</td>
<td>public static <T> Stream<T> stream(T[] array)</td>
</tr>
<tr>
<td>Arrays</td>
<td>public static <T> Stream<T> of(T … values)</td>
</tr>
<tr>
<td>Arrays</td>
<td>public static IntStream stream(int[] array)</td>
</tr>
<tr>
<td>Arrays</td>
<td>public static IntStream of(int … values)</td>
</tr>
<tr>
<td>Arrays</td>
<td>public static LongStream stream(long[] array)</td>
</tr>
<tr>
<td>Arrays</td>
<td>public static LongStream of(long … values)</td>
</tr>
<tr>
<td>Arrays</td>
<td>public static DoubleStream stream(double[] array)</td>
</tr>
<tr>
<td>Arrays</td>
<td>public static DoubleStream of(double … values)</td>
</tr>
</tbody></table>
<ul>
<li>정수 범위와 java.util.Random으로부터 생성</li>
</ul>
<table>
<thead>
<tr>
<th>구분</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>int형 범위</td>
<td>public static IntStream range(int startInclusive, int endExclusive)</td>
</tr>
<tr>
<td>int형 범위</td>
<td>public static IntStream rangeClosed(int startInclusive, int endInclusive)</td>
</tr>
<tr>
<td>long형 범위</td>
<td>public static LongStream range(long startInclusive, long endExclusive)</td>
</tr>
<tr>
<td>long형 범위</td>
<td>public static LongStream rangeClosed(long startInclusive, long endInclusive)</td>
</tr>
<tr>
<td>Random p형 값</td>
<td>public PStream ps()</td>
</tr>
<tr>
<td>Random p형 값</td>
<td>public PStream ps(long streamSize)</td>
</tr>
<tr>
<td>Random p형 값</td>
<td>public PStream ps(long streamSize, p origin, p bound)</td>
</tr>
</tbody></table>
<h4 id="스트림-생성-방식-예제"><a href="#스트림-생성-방식-예제" class="headerlink" title="스트림 생성 방식 예제"></a>스트림 생성 방식 예제</h4><ul>
<li><p>컬렉션의 인스턴스 메소드 stream()</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream1 = list1.stream();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Arrays 클래스의 클래스 메소드 stream() 을 이용</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수형 인터페이스랑 비슷함 P Type</span></span><br><span class="line"><span class="comment">// LongStream, DoubleStream 도 있다.</span></span><br><span class="line"><span class="keyword">int</span>[] ints = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">IntStream intStream = Arrays.stream(ints);</span><br><span class="line">intStream.forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure>
</li>
<li><p>위의 두 개의 다른점</p>
<ul>
<li><code>Stream&lt;Integer&gt;</code>로 할 경우, <code>Primitive Type</code>이 들어올 때 오토박싱으로 변경되고 다시 출력할 때 언방식이 되는데 이럴 때 오버헤드가 발생한다.</li>
<li><code>IntStream</code>을 사용 할 경우, 오버헤드 필요 없이, <code>WrapperClass</code>없이 사용 가능하다. 그래서 효율적이다.</li>
</ul>
</li>
<li><p>Stream 클래스의 클래스 메소드 <code>of()</code>를 이용해서 <code>Collection</code>을 걸치지 않고도 스트림을 생성 가능</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DoubleStream doubleStream = DoubleStream.of(<span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.2</span>, <span class="number">1.2</span>, <span class="number">0.94</span>);</span><br><span class="line">doubleStream.forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure></li>
<li><p>range()를 이용한 스트림 -&gt; for i문 (for(int i=0…))을 대체하는 스트림</p>
</li>
<li><p>rangeClosed() : 0~10까지 10을 포함한다.</p>
</li>
<li><p>순서대로 값을 출력한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream1 = IntStream.range(<span class="number">0</span>,<span class="number">10</span>); <span class="comment">// 0~9까지 10은 포함되지 않는다.</span></span><br><span class="line">intStream1.forEach(System.<span class="attr">out:</span>:println);</span><br><span class="line"></span><br><span class="line">IntStream intStream2 = IntStream.rangeClosed(<span class="number">0</span>,<span class="number">10</span>); <span class="comment">// 0~10까지 10포함된다.</span></span><br><span class="line">intStream2.forEach(System.<span class="attr">out:</span>:println);</span><br><span class="line"><span class="comment">// LongStream도 range, rangeClosed 가 있다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Random 객체를 이용한 스트림이 있다. Java.util 패키지 안에 있다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">// LongStream longStream =  random.longs();</span></span><br><span class="line"><span class="comment">// longStream.forEach(System.out::println); // 개수 제한 없이 무한히 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 개수 제한 가능</span></span><br><span class="line">LongStream longStream1 =  random.longs(<span class="number">100</span>);</span><br><span class="line">longStream1.forEach(System.<span class="attr">out:</span>:println); <span class="comment">// 개수를 정해질 수있다 100개</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 개수제한 + 범위 제한 가능 젤 많이 사용함</span></span><br><span class="line">LongStream longStream2 =  random.longs(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">longStream2.forEach(System.<span class="attr">out:</span>:println); <span class="comment">// 개수를 정해질 수있다 0~1000까지 100개를 출력</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="중간-처리-메소드"><a href="#중간-처리-메소드" class="headerlink" title="중간 처리 메소드"></a>중간 처리 메소드</h3><ul>
<li>중간 처리 메소드 이후에 최종 처리 메소드를 붙여서 사용하는 것 같다.</li>
</ul>
<table>
<thead>
<tr>
<th>동작</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>필터링</td>
<td>dinstict(), filter()</td>
</tr>
<tr>
<td>자르기</td>
<td>skip(), limit()</td>
</tr>
<tr>
<td>정렬</td>
<td>sorted()</td>
</tr>
<tr>
<td>매핑</td>
<td>flatMap(), flatMapToP(), map(), mapToP(), asDoubleStream(), asLongStream()</td>
</tr>
<tr>
<td>조회</td>
<td>peek()</td>
</tr>
</tbody></table>
<h4 id="필터링"><a href="#필터링" class="headerlink" title="필터링"></a>필터링</h4><h5 id="필터링은-스트림의-일부-요소를-제거하는-역할을-한다"><a href="#필터링은-스트림의-일부-요소를-제거하는-역할을-한다" class="headerlink" title="필터링은 스트림의 일부 요소를 제거하는 역할을 한다."></a>필터링은 스트림의 일부 요소를 제거하는 역할을 한다.</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Is&quot;</span>,<span class="string">&quot;Fun&quot;</span>,<span class="string">&quot;Isn&#x27;t&quot;</span>,<span class="string">&quot;It&quot;</span>,<span class="string">&quot;?&quot;</span>,<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stringStream.forEach(System.<span class="attr">out:</span>:println); <span class="comment">// 기본형 중복이 포함되서 출력됨.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>distinct() : 스트림에 같은 요소가 있을 경우 하나만 남기고 삭제하는 메소드(중복 제거)<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringStream.distinct().forEach(System.<span class="attr">out:</span>:println);</span><br><span class="line"><span class="comment">// stringStream.distinct() 여기까지 중간처리메소드, foreach는 최종처리 메소드</span></span><br><span class="line">```        </span><br><span class="line">* filter() : Predicate 계열을 입력을 받아, <span class="literal">true</span>인 요소만 남긴다.</span><br><span class="line">```groovy</span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Is&quot;</span>,<span class="string">&quot;Fun&quot;</span>,<span class="string">&quot;Isn&#x27;t&quot;</span>,<span class="string">&quot;It&quot;</span>,<span class="string">&quot;?&quot;</span>);</span><br><span class="line">stringStream.filter(s-&gt;s.length()&gt;=<span class="number">3</span>).forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="자르기"><a href="#자르기" class="headerlink" title="자르기"></a>자르기</h4><h5 id="자르기는-스트림의-일부-요소를-한번에-생략한다"><a href="#자르기는-스트림의-일부-요소를-한번에-생략한다" class="headerlink" title="자르기는 스트림의 일부 요소를 한번에 생략한다."></a>자르기는 스트림의 일부 요소를 한번에 생략한다.</h5><ul>
<li>skip(long n) : 스트림의 처음부터 n개의 요소를 생략하는 메소드, n개 자른다. n+1부터 끝까지 반환</li>
<li>limit(long maxsize) : 스트림의 최대 요소 개수를 maxsize를 제한한다, maxsize의 요소보다 뒤에 있는 값들은 짤린다. 0부터 n개까지 반환</li>
</ul>
<h4 id="정렬"><a href="#정렬" class="headerlink" title="정렬"></a>정렬</h4><h5 id="스트림-요소의-compareTo-또는-입력받은-Comparator를-이용해-정렬한다"><a href="#스트림-요소의-compareTo-또는-입력받은-Comparator를-이용해-정렬한다" class="headerlink" title="스트림 요소의 compareTo() 또는 입력받은 Comparator를 이용해 정렬한다."></a>스트림 요소의 <code>compareTo()</code> 또는 입력받은 <code>Comparator</code>를 이용해 정렬한다.</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparable 객체를 정렬한 스트림 반환</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line">stringStream.sorted().forEach(System.<span class="attr">out:</span>:println); <span class="comment">// 사전순으로 정렬됨</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator 인터페이스를 람다식으로 구현하여 정렬한다.</span></span><br><span class="line"><span class="comment">// Comparator를 이용하여 정렬된 스트림 반환</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line">stringStream.sorted((o1, o2) -&gt; o1.length() - o2.length()).forEach(System.<span class="attr">out:</span>:println); </span><br><span class="line"><span class="comment">//compreator를 람다식으로 작성해줄 수 있다, 길이가 짧은 것부터 나온다.</span></span><br></pre></td></tr></table></figure>

<h4 id="매핑"><a href="#매핑" class="headerlink" title="매핑"></a>매핑</h4><h5 id="Function-인터페이스를-이용해-요소의-값을-변환한다"><a href="#Function-인터페이스를-이용해-요소의-값을-변환한다" class="headerlink" title="Function 인터페이스를 이용해 요소의 값을 변환한다."></a>Function 인터페이스를 이용해 요소의 값을 변환한다.</h5><ul>
<li>map 계열 - 입력 1 : 1 출력<ul>
<li><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code> : 기존 스트림의 T 타입 요소를 R 타입으로 변환하여 새로운 스트림 반환<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function 계열의 인터페이스를 사용하여 스트림의 각 요소를 매핑(Operator 계열도 사용)</span></span><br><span class="line">stringStream = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fwf&quot;</span>,<span class="string">&quot;twtie&quot;</span>,<span class="string">&quot;dnmov&quot;</span>,<span class="string">&quot;work&quot;</span>);</span><br><span class="line"><span class="comment">// Function 계열로 string -&gt; integer 로 변환하는 매핑 Function&lt;String,Intger&gt;와 같은 형식을 람다식에 넣어준 것이다.</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = stringStream.map(s-&gt;s.length()) ;<span class="comment">//입력은 string 출력은 원하는대로 할수 있다</span></span><br><span class="line">stream2.forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure></li>
<li><code>PStream mapToP(ToPFunction&lt;? super T&gt; mapper)</code> : R(return)이 기본형 타입으로 제한된 map()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PStream (기본형 타입의 스트림)은 Operator 계열로 처리(자료형 반환x)</span></span><br><span class="line"><span class="comment">// 입출력 값이 똑같기 때문에</span></span><br><span class="line">IntStream intStream3 = IntStream.of(<span class="number">5</span>,<span class="number">2</span>,<span class="number">30</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">-34</span>);</span><br><span class="line">IntStream intStream4 = intStream3.map(value -&gt; value * <span class="number">10</span>); <span class="comment">// 형 변환이 되지 않고 입력이 출력이 된다.</span></span><br><span class="line">intStream4.forEach(System.<span class="attr">out:</span>:println);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>flatMap 계열 - 입력 1 : n 출력(스트림 형태로 출력한다.)(Function 계열만 사용)<ul>
<li><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code> : 스트림의 T 타입 요소가 n개의 R 타입 요소로 매핑된 새로운 스트림을 반환</li>
<li><code>PStream flatMapToP(Function&lt;? super T, ? extends PStream&gt; mapper)</code> : R이 기본형 타입으로 제한된 flatMap()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s.split(&quot;&quot;) : &quot;java&quot; -&gt; &#123;&quot;j&quot;,&quot;a&quot;,&quot;v&quot;,&quot;a&quot;&#125;</span></span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;backend&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;course&quot;</span>);</span><br><span class="line">list2.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(s.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;).forEach(System.<span class="attr">out:</span>:println); <span class="comment">//foreach를 사용하면 스트림이 끝나게 된다.</span></span><br></pre></td></tr></table></figure>
<h4 id="조회"><a href="#조회" class="headerlink" title="조회"></a>조회</h4><h5 id="스트림-처리-과정에-영향을-미치지-않으며-중간-결과를-확인할-수-있으며-입력받은-스트림과-동일한-스트림을-반환한다"><a href="#스트림-처리-과정에-영향을-미치지-않으며-중간-결과를-확인할-수-있으며-입력받은-스트림과-동일한-스트림을-반환한다" class="headerlink" title="스트림 처리 과정에 영향을 미치지 않으며, 중간 결과를 확인할 수 있으며 입력받은 스트림과 동일한 스트림을 반환한다."></a>스트림 처리 과정에 영향을 미치지 않으며, 중간 결과를 확인할 수 있으며 입력받은 스트림과 동일한 스트림을 반환한다.</h5></li>
</ul>
</li>
<li>Stream<T> peek(Consumer&lt;? super T&gt; action)<ul>
<li>peek() -&gt; Consumer 계열의 람다식 입력을 받아 입력 요소를 소비</li>
<li>peek()는 입력받아 스트림과 동일한 스트림을 다시 출력<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(list2.stream().flatMap(s -&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> Arrays.stream(s.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;).peek(s-&gt; System.out.println(<span class="string">&quot;flatMap():&quot;</span>+s))</span><br><span class="line">           .distinct().peek(s-&gt; System.out.println(<span class="string">&quot;distinct():&quot;</span>+s))</span><br><span class="line">           .count()); <span class="comment">// 함수형 프로그래밍은 선언형이어서 어떻게 해라라고 말해야한다.</span></span><br><span class="line"><span class="comment">// flatmap은 모든 요소를 다 나타내고 distinct는 중복된것을 없애고 하나만 출력됨.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="최종-처리-메소드"><a href="#최종-처리-메소드" class="headerlink" title="최종 처리 메소드"></a>최종 처리 메소드</h3><table>
<thead>
<tr>
<th>동작</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>매칭</td>
<td>allMatch(), anyMatch(), noneMatch()</td>
</tr>
<tr>
<td>수집</td>
<td>collect()</td>
</tr>
<tr>
<td>루핑</td>
<td>forEach()</td>
</tr>
<tr>
<td>집계</td>
<td>count(), max(), min(), average(), sum(), reduce()</td>
</tr>
<tr>
<td>조사</td>
<td>findFirst(), findAny()</td>
</tr>
</tbody></table>
<h4 id="루핑"><a href="#루핑" class="headerlink" title="루핑"></a>루핑</h4><h5 id="forEach-메소드로-스트림-요소를-순차적으로-Consumer를-이용해-소비"><a href="#forEach-메소드로-스트림-요소를-순차적으로-Consumer를-이용해-소비" class="headerlink" title="forEach() 메소드로 스트림 요소를 순차적으로 Consumer를 이용해 소비"></a>forEach() 메소드로 스트림 요소를 순차적으로 Consumer<T>를 이용해 소비</h5><ul>
<li>forEach() - 요소들을 계속해서 반복해서 가져와라라는 의미이다.<ul>
<li><code>stream.forEach(name -&gt; System.out.println(name))</code>으로 되어있을 때<br>스트림에 가져온 요소를 name에 넣어서 하나씩 출력되게 하는 것이다.</li>
<li>매개값의 형태는 Consumer 함수형 인터페이스 타입을 갖는다.</li>
</ul>
</li>
<li><code>void forEach(Comsumer&lt;? super T&gt; action)</code> : 스트림의 각 요소를 action으로 소비  </li>
</ul>
<h4 id="매칭"><a href="#매칭" class="headerlink" title="매칭"></a>매칭</h4><h5 id="Predicate-계열을-이용해-스트림-요소들이-특정-조건에-만족하는지-조사하는-메소드"><a href="#Predicate-계열을-이용해-스트림-요소들이-특정-조건에-만족하는지-조사하는-메소드" class="headerlink" title="Predicate 계열을 이용해 스트림 요소들이 특정 조건에 만족하는지 조사하는 메소드"></a>Predicate 계열을 이용해 스트림 요소들이 특정 조건에 만족하는지 조사하는 메소드</h5><ul>
<li>boolean allMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 모든 요소가 Predicate를 만족하면 true를 반환</li>
<li>boolean anyMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 요소 중 하나라도 Predicate를 만족하면 true를 반환</li>
<li>boolean noneMatch(Predicate&lt;? super T&gt; predicate) : 스트림의 요소 중 하나라도 Predicate를 만족하지 않으면 true를 반환</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.allMatch(s -&gt; s.equals(<span class="string">&quot;abc&quot;</span>))); <span class="comment">//false</span></span><br><span class="line">st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.anyMatch(s -&gt; s.equals(<span class="string">&quot;cde&quot;</span>))); <span class="comment">//true</span></span><br><span class="line">st0 = Stream.of(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">System.out.println(st0.noneMatch(s -&gt; s.equals(<span class="string">&quot;abcde&quot;</span>)));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="집계-통계"><a href="#집계-통계" class="headerlink" title="집계 (통계)"></a>집계 (통계)</h4><ul>
<li><p>최종 처리 기능</p>
<ul>
<li>카운팅, 합계, 평균값, 최대값, 최소값 등과 같이 하나의 값으로 산출한다.</li>
<li>대량의 데이터를 가공해서 축소하는 리덕션이라고 볼 수 있다.</li>
</ul>
</li>
<li><p>기본 집계 메소드</p>
<ul>
<li>기본형 스트림의 통계 : count(), sum(), average(), min(), max()</li>
<li>T 타입 스트림의 통계 : count(), min(), max() (min, max의 경우 Comparator 필요)</li>
</ul>
</li>
<li><p>reduce() 메소드 : 사용자 정의 집계 메소드</p>
<ul>
<li>모든 자료형에서 사용할 수 있는 집계 메소드이다!</li>
<li>개발자가 프로그램화해서 다양한 집계(리덕션) 결과물을 만들 수 있다.</li>
<li>특정한 값을 집계 할 수 있게 하기 위해서 reduce를 제공한다.</li>
<li><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code> : accumulator를 수행하고 Optional<T> 타입 반환</li>
<li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code> : identity를 초기값으로 하여, accumulator를 이용해 집계 연산</li>
<li><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code> : combiner를 이용해 병렬 스트림 결합</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>리턴 타입</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Stream</td>
<td>Optional<T></td>
<td>reduce(BinaryOperator<T> accumulator</td>
</tr>
<tr>
<td></td>
<td>T</td>
<td>reduce(T identitiy, BianryOperator<T> accmulator)</td>
</tr>
<tr>
<td>IntStream</td>
<td>OptionalInt</td>
<td>reduce(IntBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>reduce(int indentity, IntBinaryOperator  op)</td>
</tr>
<tr>
<td>LongStream</td>
<td>OptionalLong</td>
<td>reduce(LongBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>reduce(long indentity, LongBinaryOperator  op)</td>
</tr>
<tr>
<td>DoubleStream</td>
<td>OptionalDouble</td>
<td>reduce(DoubleBinaryOperator  op)</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>reduce(double indentitiy, DoubleBinaryOperator  op)</td>
</tr>
</tbody></table>
</li>
<li><p>reduce(BinaryOperator<T> accumulator) </p>
<ul>
<li>이건 연산의 결과가 없으면 예외가 발생한다. NotSuchElementException 요소가 있어야 동작한다.</li>
</ul>
</li>
<li><p>reduce(T identitiy, BianryOperator<T> accmulator) </p>
<ul>
<li>연산의 결과가 없다면, 디폴트로 identity 사용  요소가 없어도 동작한다.</li>
<li>연산의 결과가 없는 것은 요소가 없는 것이다. 그래서 연산의 결과로 디폴트 값으로 identity를 하는 것이다.</li>
</ul>
</li>
<li><p>매개변수</p>
<ul>
<li>XXXBinaryOperator : 두 개의 매개 값을 받아 연산 후 리턴하는 함수적 인터페이스</li>
<li>identity : 스트림에 요소가 전혀 없을 경우 리턴될 디폴트 값   <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(IntStream.range(<span class="number">0</span>,<span class="number">10</span>).reduce(<span class="number">0</span>,(value1,value2)-&gt;value1+value2)); <span class="comment">//sum()</span></span><br><span class="line"><span class="comment">// 1,2와 더한걸 3이랑 더하고 12 와 3을 더한걸 4 와 더함 .. 누적해서 더하는 것이다.</span></span><br><span class="line"><span class="comment">// identity가 사용이 되는 이유는 처음 identitiy와 1을 더한값과 2를계산하기위해서</span></span><br><span class="line"><span class="comment">// 0 [0,1,2,3,4,5,6,7,8,9] 0+0 =0 -&gt; 0+1-&gt;1 1+2-&gt; 3 과같은 연산 0~9까지 더한 연산</span></span><br><span class="line"><span class="comment">// sum()으로도 나타낼 수 있다 sum,min,max등등 도 reduce로 구현되어 있다</span></span><br><span class="line"></span><br><span class="line">System.out.println(IntStream.range(<span class="number">0</span>,<span class="number">10</span>).reduce(Integer.MAX_VALUE,(value1,value2)-&gt;value1&lt;value2? value1:value2));<span class="comment">// min()</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>java.util.Optional&lt;T&gt;</code></p>
<ul>
<li><p>T 타입 객체의 null 여부에 따라 다르게 동작하는 Wrapper 클래스</p>
</li>
<li><p>자바 8부터 추가된 값을 저장하는 값 기반 클래스</p>
</li>
<li><p>java.util 패키지의 Optional, OptionalDouble, OptionalInt, OptionLong 클래스를 말한다.</p>
</li>
<li><p>집계 메소드의 리턴 타입으로 사용되어 집계 값을 가지고 있다. 이게 핵심이다!!</p>
</li>
<li><p>저장된 값을 얻으려면 get(), getAsDouble(), getAsInt(), getAsLong()를 호출한다. </p>
</li>
<li><p>Optional 클래스의 정적 메소드를 이용해 Optional 객체 생성</p>
<ul>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; of(T value)</code> : value가 null인 경우 NullPointerException을 발생시키는 Wrapping 메소드</li>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code> : value가 null인 경우 empty()의 결과를 리턴하는 Wrapping 메소드</li>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; empty()</code> : 값이 비어있는 Optional 객체를 리턴</li>
</ul>
</li>
<li><p>Optional 객체를 처리하는 메소드</p>
<ul>
<li><code>public T get()</code> : Optional의 값을 리턴하며, null일 경우 NullPointerException 발생</li>
<li><code>public void ifPresent(Consumer&lt;? super T&gt; consumer)</code> : Optional 값이 null이 아닐 경우 consumer를 이용해 소비한다, 값이 저장되어 있지 않을 경우 디폴트 값(매개변수가 디폴트 값이 된다)<ul>
<li>consumer로 집계 값을 받아서 처리하는 코드를 람다식으로 작성한다</li>
</ul>
</li>
<li><code>public T orElse(T other)</code> : Optional의 값이 null일 경우 other를 반환한다, 값이 저장되어 있을 경우 Consumer 에서 처리</li>
<li><code>public T orElseGet(Supplier&lt;? extends T&gt; other)</code> : Optional의 값이 null일 경우 Supplier를 통해 공급받은 값을 반환한다.</li>
<li><code>public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</code> : Optional의 값이 null일 경우 exceptionSupplier에서 공급받은 예외를 throw</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> avg = list.stream()</span><br><span class="line">        .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">        .average()</span><br><span class="line">        .getAsDouble();</span><br><span class="line">System.out.println(avg); <span class="comment">//NotSuchElementException</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">// isPresent()</span></span><br><span class="line">OptionalDouble optionalDouble = list.stream()</span><br><span class="line">        .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">        .average();</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> (optionalDouble.isPresent())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;값이 있는 경우 : &quot;</span> + optionalDouble.getAsDouble());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;방법 1-값이 없는 경우 : &quot;</span> + <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// orElse()</span></span><br><span class="line"><span class="keyword">double</span> avg = list.stream()</span><br><span class="line">        .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">        .average()</span><br><span class="line">        .orElse(<span class="number">0.0</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;방법 2 : &quot;</span> + avg);</span><br><span class="line">     </span><br><span class="line"><span class="comment">// ifPresent()</span></span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.stream()</span><br><span class="line">        .mapToInt(<span class="attr">Integer:</span>:intValue)</span><br><span class="line">        .average()</span><br><span class="line">        .ifPresent(i-&gt; System.out.println(<span class="string">&quot;방법 3 : &quot;</span>+ i));</span><br><span class="line"><span class="comment">// 값이 없을 경우 false가 되서 종료가 된다. consumer로 했기 때문에 바로 값 출력</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="조사"><a href="#조사" class="headerlink" title="조사"></a>조사</h4><h5 id="첫번째-요소-또는-아무-요소를-조사하는-최종-처리-메소드-필터링-등으로-인해-스트림에-요소가-남아있는지-확인할-수-있다"><a href="#첫번째-요소-또는-아무-요소를-조사하는-최종-처리-메소드-필터링-등으로-인해-스트림에-요소가-남아있는지-확인할-수-있다" class="headerlink" title="첫번째 요소 또는 아무 요소를 조사하는 최종 처리 메소드. 필터링 등으로 인해 스트림에 요소가 남아있는지 확인할 수 있다."></a>첫번째 요소 또는 아무 요소를 조사하는 최종 처리 메소드. 필터링 등으로 인해 스트림에 요소가 남아있는지 확인할 수 있다.</h5><ul>
<li><code>Optional&lt;T&gt; findFirst()</code> : 스트림의 첫 요소 또는 empty Optional 객체를 반환</li>
<li><code>Optional&lt;T&gt; findAny()</code> : 스트림의 아무 요소나 가지는 Optional 객체를 반환 (병렬 스트림일 때 사용한다.)</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> firstValue = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line">                .filter(n -&gt; n%<span class="number">3</span> ==<span class="number">0</span>)</span><br><span class="line">                .findFirst()</span><br><span class="line">                .getAsInt();</span><br></pre></td></tr></table></figure>

<h4 id="수집"><a href="#수집" class="headerlink" title="수집"></a>수집</h4><h5 id="필요한-요소를-수집하여-새로운-Collection으로-구성하여-반환하는-메소드"><a href="#필요한-요소를-수집하여-새로운-Collection으로-구성하여-반환하는-메소드" class="headerlink" title="필요한 요소를 수집하여 새로운 Collection으로 구성하여 반환하는 메소드"></a>필요한 요소를 수집하여 새로운 Collection으로 구성하여 반환하는 메소드</h5><ul>
<li>최종 처리 기능으로 요소들을 수집 또는 그룹핑한다.<ul>
<li>필터링 또는 매핑된 요소들로 최종적으로 얻은요소들로 새로운 컬렉션 생성하는 것.</li>
<li>요소들을 그룹핑하고, 집계를 할 수 있다. </li>
</ul>
</li>
<li>Stream API는  JCF-&gt; STREAM -&gt; 처리 -&gt; 결과</li>
<li>결과가 출력일 수도 있고 값일 수도 있고, 다시 컬렉션으로 만들고 싶을 수 있다.</li>
<li>요소가 여러개 있는 프레임워크 혹은 Arrays에서 스트림을 생성한 다음에 스트림에서 중간 처리를 쭉쭉한 다음에 마지막에 출력이나 값을 낼 수 있지만<br>다음 중 3가지중 하나의 조건은 꼭 선택해야 한다.<ul>
<li>조건1. foreach()를 사용하거나</li>
<li>조건2. 특정한 값을 리턴을 받거나(reduce())</li>
<li>조건3. count,min,max 스트림을 간추려서 통계를 낼 수 있는 값들을 가져오던지 다시 컬렉션으로 만들어 주던지 해야한다.</li>
</ul>
</li>
</ul>
<h5 id="보통-수집을-하기-위해서-필터링을-한다"><a href="#보통-수집을-하기-위해서-필터링을-한다" class="headerlink" title="보통 수집을 하기 위해서 필터링을 한다."></a>보통 수집을 하기 위해서 필터링을 한다.</h5><ul>
<li><p>스트림에서 필요한 요소만 필터링해서 별도의 컬렉션으로 만든다</p>
</li>
<li><p>collect라는 메소드 사용 collect(Collector &lt;T,A,R&gt; collector)</p>
</li>
<li><p>collect가  요소를 어떤 컬렉션에 수집할 것인지를 결정한다.</p>
</li>
<li><p>collect()메소드</p>
<ul>
<li><p><code>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R) collector)</code> : collector를 이용해 새로운 Collection R에 담아 반환</p>
<ul>
<li>Collectors의 <code>정적 메소드</code> : toList(), toSet(), toCollection(), toMap(), toConcurrentMap()</li>
</ul>
</li>
<li><dl><dt><code>&lt;R, A&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</code></dt><dd>supplier를 통해 공급된 컨테이너 R에 accumulator를 이용해 T값을 저장. 병렬처리 스트림에 사용될 경우 combiner를 이용해 스레드별 컨테이너 R을 통합</dd></dl></li>
</ul>
</li>
<li><p>Collector의 타입 파라미터</p>
<ul>
<li>T : 요소                                </li>
<li>A : 누적기(accumulator) 요소를 컬렉션에 수집하는 역할을한다.</li>
<li>R : 요소가 저장될 새로운 컬렉션 <ul>
<li>T 요소를 A 누적기가 R에 저장한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>리턴 타입</th>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Collector&lt;T,?,Collection<T>&gt;</td>
<td>Collectors.toCollection{Supplier<T>}</td>
<td>Supplier가 제공한 Collection에 저장</td>
</tr>
<tr>
<td>Collector&lt;T,?,ConcurrentMap&lt;K,U&gt;&gt;</td>
<td>Collectors.toConcurrentMap(…)</td>
<td>ConcurrentMap에 저장한다.</td>
</tr>
<tr>
<td>Collector&lt;T,?,List<T>&gt;</td>
<td>Collectors.toList()</td>
<td>List에 저장</td>
</tr>
<tr>
<td>Collector&lt;T,?,Map&lt;K,U&gt;&gt;</td>
<td>Collectors.toMap()</td>
<td>Map에 저장</td>
</tr>
<tr>
<td>Collecotr&lt;T,?,Set<T>&gt;</td>
<td>Collectors.toSet()</td>
<td>Set에 저장</td>
</tr>
</tbody></table>
<ul>
<li><p>Collectors.toConcurrentMap(…) - 멀티쓰레드 환경에서 쓰레드의 안전한 concurrentmap을 만들어서 거기에 요소를 수집하는 Collector를 얻는다. </p>
</li>
<li><p>A가 ? 인 이유</p>
<ul>
<li>List, Set, Map 컬렉션에 누적할 경우 별도의 누적기가 필요 없다. </li>
<li>컬렉터내부에서 이들 컬렉션에 저장하는 방법을 알고 있기 때문에 별도의 누적기가 필요 없음.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.stream(array)</span><br><span class="line">        .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">        .collect(Collectors.toList()); <span class="comment">// ArrayList</span></span><br><span class="line">        <span class="comment">// .collect(Collectors.toCollection(LinkedList::new))</span></span><br><span class="line">System.out.println(list.getClass().getName() + <span class="string">&quot;:&quot;</span> + list);</span><br><span class="line">  </span><br><span class="line">Set&lt;String&gt; set = Arrays.stream(array)</span><br><span class="line">        .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">        .collect(Collectors.toSet()); <span class="comment">// HashSet</span></span><br><span class="line">        <span class="comment">// .collect(Collectors.toCollection(HashSet::new))</span></span><br><span class="line">System.out.println(set.getClass().getName() + <span class="string">&quot;:&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = Arrays.stream(array)</span><br><span class="line">        .filter(s -&gt; s.length() &gt;= <span class="number">3</span>)</span><br><span class="line">        .collect(Collectors.toMap(s -&gt; s, <span class="attr">String:</span>:length)); <span class="comment">// HashMap</span></span><br><span class="line">        <span class="comment">// .collect(Collectors.toCollection(s -&gt; s, String::length, (oldVal, newVal) -&gt; newVal, TreeMap::new))</span></span><br><span class="line">System.out.println(map.getClass().getName() + map);</span><br></pre></td></tr></table></figure></li>
<li><p>Collectors의 정적 메소드를 이용한 그룹화와 분리</p>
</li>
<li><p>partitioningBy는 어떤 기준으로 무더기로 나누는 것 (2가지 true or false)</p>
</li>
<li><p>groupingBy는 어떤 기준으로 여러개 묶어 내는 것  (여러개)</p>
<ul>
<li><dl><dt><code>public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code></dt><dd>classifier를 key값으로, 해당하는 값의 목록을 List인 value로 가지는 Map으로 스트림을 수집하는 Collector를 반환</dd></dl><ul>
<li><code>public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)</code> : List 대신 downstream collector로 수집</li>
<li>groupingBy(R Function<T>) - Map&lt;R, List<T>&gt;입력받은게 function으로 출력됨 R타입에 따라 그룹이 됨 그래서 R이 키가 된다.</li>
<li>T를 String..length 로 해주면 R은 Integer</li>
<li>결과 - 1: [………..], 2: [………..], 3: [………..]<ul>
<li><code>public static &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate)</code> : predicate 결과를 key로, 해당하는 값의 목록을 List value로 가지는 Map으로 스트림을 수집하는 Collector를 반환</li>
</ul>
</li>
<li><code>public static &lt;T, A, D&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream))</code> : List 대신 downstream collector로 수집</li>
<li>partitionBy(predciate)- Map&lt;Boolean, List<T>&gt; 왜냐하면 이건 두가지로 나누는 것이기 때문에 predicate 계열을 가지고 참인지 거짓인지 판단을 해야 해서</li>
<li>결과 - true :[……] , false: [……]  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> Map&lt;Character, List&lt;String&gt;&gt; map1 = Arrays.stream(array)</span><br><span class="line">         .collect(Collectors.groupingBy(s -&gt; s.charAt(<span class="number">0</span>)));</span><br><span class="line"> System.out.println(map1);</span><br><span class="line"> </span><br><span class="line"> Map&lt;Boolean, List&lt;String&gt;&gt; map2 = Arrays.stream(array)</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.length() &gt;= <span class="number">3</span>));</span><br><span class="line"> System.out.println(map2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>집계를 위한 Collector</p>
<ul>
<li>Downstream collector로 집계를 위한 Collector를 사용할 경우 유용하다.</li>
<li>counting(), summingP(), averagingP(), maxBy(), minBy(), reducing()</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Isn&#x27;t&quot;</span>, <span class="string">&quot;It&quot;</span>, <span class="string">&quot;?&quot;</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  Map&lt;Character, Long&gt; map = Arrays.stream(array)</span><br><span class="line">          .collect(Collectors.groupingBy(s -&gt; s.charAt(<span class="number">0</span>),</span><br><span class="line">                                         Collectors.counting()));</span><br><span class="line">  System.out.println(map);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="병렬-스트림"><a href="#병렬-스트림" class="headerlink" title="병렬 스트림"></a>병렬 스트림</h3><h4 id="병렬-처리"><a href="#병렬-처리" class="headerlink" title="병렬 처리"></a>병렬 처리</h4><ul>
<li>한가지 작업을 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬 적으로 처리한 후,<br>서브 작업들의 결과들을 최종 결합하는 방법, 자바는 ForkJoinPool 프레임워크를 이용해서 병렬 처리를 한다.</li>
</ul>
<h4 id="병렬-스트림의-생성"><a href="#병렬-스트림의-생성" class="headerlink" title="병렬 스트림의 생성"></a>병렬 스트림의 생성</h4><ul>
<li><p>stream() 대신 parallelStream()으로 변경</p>
</li>
<li><p>stream 생성 후 parallel()으로 병렬화</p>
<ul>
<li>combiner를 이용해 병렬 스트림으로 생성된 컬렉션을 결합</li>
</ul>
</li>
<li><p>BiConsumer&lt;T, K&gt; combiner : T 객체에 K 객체를 결합 </p>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>리턴타입</th>
<th>메소드(매개변수)</th>
</tr>
</thead>
<tbody><tr>
<td>java.util.Collection</td>
<td>Stream</td>
<td>parallelStream()</td>
</tr>
<tr>
<td>java.util.Stream</td>
<td>Stream</td>
<td>parallel()</td>
</tr>
<tr>
<td>java.util.Intstream</td>
<td>IntStream</td>
<td></td>
</tr>
<tr>
<td>java.util.Longstream</td>
<td>Longstream</td>
<td></td>
</tr>
<tr>
<td>java.util.Doublestream</td>
<td>Doublestream</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>parallelStream()<ul>
<li>컬렉션으로부터 병렬 스트림을 바로 리턴</li>
</ul>
</li>
<li>parallel()<ul>
<li>순차 처리 스트림을 병렬 스트림으로 변환해서 리턴</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="병렬성-구분"><a href="#병렬성-구분" class="headerlink" title="병렬성 구분"></a>병렬성 구분</h4><ul>
<li><p>데이터 병렬성</p>
<ul>
<li>데이터 병렬성은 한 작업 내에 있는 전체 데이터를 쪼개어 서브 데이터들로 만들고<br> 이 서브 데이터들을 병럴 처리해서 작업을 빨리 끝내는 것을 말한다.</li>
</ul>
<ul>
<li>작업 병렬성<ul>
<li>작업 병렬성은 서로 다른 작업을 병렬 처리하는 것을 말한다.</li>
<li>작업 병렬성은 대표적인 예는 웹서버이다.<br>웹 서버는 각각의 브라우저에서 요청한 내용을 개별 스레드에서 병렬로 처리한다.</li>
</ul>
</li>
</ul>
</li>
<li><p>병렬 스트림은 데이터 병렬성을 구현한 것이다.</p>
<ul>
<li>멀티 코어의 수만큼 대용량 요소를 서브 요소들로 나누고,<br> 각각의 서브 요소들을 분리된 스레드에서 병렬 처리시킨다.</li>
<li>예를 들어 쿼드 코어cpu일 경우 4개의 서브 요소들로 나누고,<br>4개의 스레드가 각가의 서브 요소들을 병렬처리한다.</li>
<li>병렬 스트림은 포크조인 프레임워크를 이용한다.</li>
</ul>
</li>
</ul>
<pre><code class="groovy">Stream&lt;String&gt; parStream = Arrays.stream(arr).parallel(); //  스트림을 parallel로 바꿔줌
System.out.println(parStream.map(String::length).count());
// parallelStream을 사용하면 연산 순서가 달라질 수 있다.

List&lt;String&gt; list4 = List.of(&quot;atwe&quot;,&quot;bff&quot;,&quot;cqqqw&quot;,&quot;dtwer&quot;);
Stream&lt;String&gt; stream6 = list4.parallelStream(); // 어떤 요소가 먼저 수행되는지 알 수 없음
// Stream&lt;String&gt; stream6 = list4.stream();

stream6.map(String::length).peek(s-&gt;System.out.println(&quot;A: &quot;+ s))
              .filter(value-&gt;value &gt;=3)
              .peek(s-&gt; System.out.println(&quot;B :&quot;+ s))
              .forEach(System.out::println);</code></pre>
<h3 id="포크조인-프레임워크-ForkJoin-Framework"><a href="#포크조인-프레임워크-ForkJoin-Framework" class="headerlink" title="포크조인 프레임워크(ForkJoin Framework)"></a>포크조인 프레임워크(ForkJoin Framework)</h3><ul>
<li><p>포크조인 프레임워크 동작 방식</p>
<ul>
<li><p>포크 단계</p>
<ul>
<li>데이터를 서브 데이터로 반복적으로 분리한다.</li>
<li>서브 데이터를 멀티 코어에서 병렬로 처리한다.</li>
</ul>
</li>
<li><p>조인 단계</p>
<ul>
<li>서브 결과를 결합해서 최종 결과를 만들어 낸다.</li>
</ul>
</li>
<li><p>실제로 병렬 처리 스트림은 포크 단게에서 <code>차례대로 요소를 4등분 하지 않는다.</code>내부적으로 서브 요소를 나누는 알고리즘이 있기 때문에 개발자는 신경 쓸 필요가 없다.</p>
</li>
</ul>
<ul>
<li>포크조인풀(포크조인프레임워크는 내부적으로 스레드를 포크조인풀에서 관리한다.)<ul>
<li>각각의 코어에서 서브요소를 처리하는 것은 개별 스레드가 해야하므로 스레드 관리가 필요<ul>
<li>코어에서 작업을 할려면 코어별로 각각의 스레드가 존재해야한다.</li>
</ul>
</li>
<li>포크조인 프레임워크는 ExcutorService의 구현 객체인 ForkJoinPool을 사용</li>
<li>4개의 코어를 가진 cpu일 경우</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="병렬-처리-성능"><a href="#병렬-처리-성능" class="headerlink" title="병렬 처리 성능"></a>병렬 처리 성능</h3><ul>
<li><p>병렬 처리는 항상 빠르다?</p>
<ul>
<li>스트림 병렬 처리가 스트림 순차 처리보다 항상 실행 성능이 좋다고 판단해서는 안된다.</li>
</ul>
</li>
<li><p>병렬 처리에 영향을 미치는 3가지 요인</p>
<ul>
<li><p>요소의 수와 요소당 처리 시간 - 요소우의 수가 적고 요소당 처리시간이 짧으면 순차 처리가 오히려 병렬처리보다<br>빠를 수 있다 병렬처리는 스레드풀 생성, 스레드 생성이라는 추가적인 비용이 발생하기 때문이다.</p>
</li>
<li><p>스트림 소스의 종류</p>
<ul>
<li>ArrayList, 배열은 램덤 액세스를 지원(인덱스로 접근)하기 때문에 포크 단계에서 쉽게 요소를<br>분리할 수 있어 병렬 처리 시간이 절약된다, 반면 HashSet, TreeSet은 요소를 분리하기가 쉽지않고,<br>LinkedList는 램덤 액세스를 지원하지 않아서 요소를 분리하기가 쉽지 않다.<br>또한, BufferedReader.lines()은 전체 요소의 수를 알기 어렵기 때문에 포크 단계에서 부분 요소로<br>나누기 어렵다. 따라서 이들 소스들은 ArrayList, 배열 보다는 상대적으로 병럴처리가 늦다.</li>
</ul>
</li>
<li><p>코어의 수<br> *싱글코어 cpu일 경우 순차처리가 빠르다. 코어의 수가 많으면 병렬처리 속도가 빨라진다.</p>
</li>
</ul>
</li>
</ul>
<h4 id="패럴레-스트림을-사용한다는-것이-어떤-의미인가"><a href="#패럴레-스트림을-사용한다는-것이-어떤-의미인가" class="headerlink" title="패럴레 스트림을 사용한다는 것이 어떤 의미인가"></a>패럴레 스트림을 사용한다는 것이 어떤 의미인가</h4><ul>
<li>원래 스트림(페럴레아닌 상태)은 [0,0,0,0,0,0] 이런게 있다로 시작, 스트림을 정하고 맵이 있으면 맵을 한 결과가 나와야함[0,0,0,0,0,0]</li>
<li>그런다음 맵을 한 번 더 실행하고 [0,0,0,0,0,0] foreach가 실행이 된다. 하나하나가 함수로 소비가 되는 상태가 된다</li>
<li>하나씩 처리가 된다 각 요소 가 모든 연산이 쭉되고 다음 요소가 모든 연산이 실행이 됨</li>
<li>그 중간에 peek(),peek(),foreach()의 결과가 출력이 된다 이것이 우리가 생각하는 기본적인 스트림</li>
</ul>
<h4 id="병렬-스트림-동작"><a href="#병렬-스트림-동작" class="headerlink" title="병렬 스트림 동작"></a>병렬 스트림 동작</h4><ul>
<li><p>자바에서 스레드가 기본적인건 모르겠으나 여기서 7개의 스레드가 각각있다고 가정하고 동시에 동작을한다</p>
</li>
<li><p>스레드는 프로그램을 동작할 때 한줄씩 실행되는데 이 한 줄씩 실행되는 것이 여러개 있는 것이다.각각 독립적으로 한줄을 실행한다.</p>
</li>
<li><p>한줄 한줄 계산하는게 동시에 계산해도 된다 각각을 순수함수로 되어있어야 하니깐</p>
<ul>
<li>여기서 한줄이란 세로로 한줄이 시작되고 그옆에 세로가 시작되는건데 병렬처리면 스레드의 개수에 따라<br>이 세로줄의 실행이 스레드 개수에 따라서 한번에 실행된다는 의미이다 4개스레드이면 4개의 세로줄이 동시에 실행됨.</li>
<li>한줄 계산되는 동안 다른 한줄이 같이 계산되고 몇개가 같이 연산이 진행되는진 모르지만 스레드의 개수에 따라 한줄이 같이 진행됨</li>
</ul>
</li>
<li><p>[0,0,0,0,0,0]</p>
</li>
<li><p>[0,0,0,0,0,0]</p>
</li>
<li><p>[0,0,0,0,0,0]</p>
</li>
<li><p>[0,0,0,0,0,0]</p>
<ul>
<li>명령형/ 순차처리 &lt;-&gt; 함수형/병렬처리 큰 간극을 보인다</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/27/Java/JavaAdvanced/Java-StreamAPI/" data-id="ckgxjhqfh002qcwu22q5kb737" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaAdvanced/Java-LambdaExpression" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/Java/JavaAdvanced/Java-LambdaExpression/" class="article-date">
  <time datetime="2020-09-27T12:35:58.485Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/27/Java/JavaAdvanced/Java-LambdaExpression/">Java_LambdaExpression</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="람다식-Lambda-Expression"><a href="#람다식-Lambda-Expression" class="headerlink" title="람다식(Lambda Expression)"></a>람다식(Lambda Expression)</h1><h2 id="람다식"><a href="#람다식" class="headerlink" title="람다식"></a>람다식</h2><ul>
<li>Java1.8에서 추가된 함수형 프로그래밍 기법이다.</li>
<li>객체지향 프로그래밍과 다르게, 비즈니스 로직만을 빠르게 구현하는 특징.</li>
<li>객체지향 언어인 Java에서 메소드를 함수처럼 사용하는 형식.</li>
</ul>
<h3 id="함수적-프로그래밍"><a href="#함수적-프로그래밍" class="headerlink" title="함수적 프로그래밍"></a>함수적 프로그래밍</h3><ul>
<li>y = f(x) 형태의 함수로 구성된 프로그래밍 기법 x에 어떤 값을 주면 y가 얻어지는 함수형 기법<ul>
<li>데이터를 매개값으로 전달하고 결과를 받는 코드들로 구성</li>
<li>객체 지향 프로그래밍 보다는 효율적인 경우<ul>
<li>대용량 데이터의 처리시에 유리<br>객체를  생성후 처리하는 것보다, 데이터를 바로 처리하는 것이 속도에 유리</li>
<li>이벤트 지향 프로그래밍(이벤트가 발생하면 핸들러 함수 실행)에 적합<br>반복적인 이벤트 처리는 핸들러 객체보다는 핸들러 함수가 적합</li>
</ul>
</li>
</ul>
</li>
<li>현대적 프로그래밍 기법<ul>
<li>객체 지향 프로그래밍 <code>+</code> 함수적 프로그래밍</li>
</ul>
</li>
</ul>
<h3 id="자바에서-람다식을-수용한-이유"><a href="#자바에서-람다식을-수용한-이유" class="headerlink" title="자바에서 람다식을 수용한 이유"></a>자바에서 람다식을 수용한 이유</h3><ul>
<li>코드가 매우 간결해진다,</li>
<li>컬렉션 요소(대용량 데이터)를 필터링 또는 매핑해서 쉽게 집계할 수 있다.</li>
</ul>
<h3 id="자바는-람다식을-함수적-인터페이스의-익명-구현-객체로-취급한다"><a href="#자바는-람다식을-함수적-인터페이스의-익명-구현-객체로-취급한다" class="headerlink" title="자바는 람다식을 함수적 인터페이스의 익명 구현 객체로 취급한다."></a>자바는 람다식을 함수적 인터페이스의 익명 구현 객체로 취급한다.</h3><ul>
<li>람다식은 매개변수를 가진 코드블록이다. -&gt; 익명 구현 객체</li>
<li>어떤 인터페이스를 구현할지는 대입되는 인터페이스에 달려있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Runnable runnable  = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 위의 코드처럼 있다 가정할 때, 익명 구현 객체는 아래 부분에 해당한다.</span></span><br><span class="line"><span class="comment">//  이것과 똑같은 효과를 내게 하는것이 람다식이다.</span></span><br><span class="line"><span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;...&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="함수적-인터페이스"><a href="#함수적-인터페이스" class="headerlink" title="함수적 인터페이스"></a>함수적 인터페이스</h4><ul>
<li><p>하나의 추상 메소드로 선언된 인터페이스만 타켓 타입이 될 수 있다</p>
</li>
<li><p>@FuntionalInterface 어노테이션</p>
<ul>
<li>하나의 추상 메소드만을 가지는지 컴파일러가 체크하도록 한다.</li>
<li>두 개 이상의 추상 메소드가 선언되어 있으면 컴파일 오류가 발생한다.<h2 id="람다식의-예"><a href="#람다식의-예" class="headerlink" title="람다식의 예"></a>람다식의 예</h2><h3 id="배열의-정렬"><a href="#배열의-정렬" class="headerlink" title="배열의 정렬"></a>배열의 정렬</h3></li>
</ul>
</li>
<li><p>기본 정렬 방식을 이용한 정렬</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String [] strings = &#123;<span class="string">&quot;fast&quot;</span>,<span class="string">&quot;campus&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;backend&quot;</span>,<span class="string">&quot;choigo&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;people&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br><span class="line">Arrays.sort(strings);<span class="comment">// 정렬할 수 있다. 사전순으로 Arrays로 정렬하는거 하나 새로 배움</span></span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Comparator 클래스를 만들고, 객체를 생성하여 전달하는 방식</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// string을 비교하기 위한 메소드를 인터페이스가 가지고 있어서</span></span><br><span class="line">   <span class="comment">// 인터페이스를 구현하면 sort에 넘겨주면 사전순으로 되어있던걸</span></span><br><span class="line">   <span class="comment">// 추가로 객체를 생성해서 메소드를 새롭게 구현하여 넣어서 새로 구현한 메소드가 정렬하는 방식을 다르게 할 수 있다.</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> compare(String o1, String o2) &#123;</span><br><span class="line">       <span class="keyword">return</span> o1.substring(<span class="number">1</span>).compareTo(o2.substring(<span class="number">1</span>));</span><br><span class="line">       <span class="comment">// 둘다 짤라서 시작문자가 1번 두번째 인덱스 자리를 서로 비교하는 것</span></span><br><span class="line">       <span class="comment">// compareto는 comparable 인터페이스에 있는 것을 가져옴, 이미 스트링에 정의되어 있음</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 기준을 바꾸고 싶을 때 방법은 새로운 comparator를 넣어줘서</span></span><br><span class="line"> <span class="comment">// 객체를 정렬하는 방법을 할 수 있다.</span></span><br><span class="line"> Arrays.sort(strings, <span class="keyword">new</span> MyComparator());</span><br><span class="line"> System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure></li>
<li><p>익명 내부 클래스를 이용할 수 있다.</p>
<ul>
<li>상속하고 싶은 인터페이스든 클래스를 적어준 다음에 블록을 열어서 재정의 해주면 작성할 수 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> compare(String o1, String o2) &#123;</span><br><span class="line">          <span class="keyword">return</span> o1.substring(<span class="number">2</span>).compareTo(o2.substring(<span class="number">2</span>)); <span class="comment">//필요한 내용은 이것이다.</span></span><br><span class="line">     &#125;</span><br><span class="line">);</span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>람다식을 이용한 방법</p>
<ul>
<li>클래스없이 작성이 가능한 익명내부클래스를 한번 더 줄임</li>
<li>람다식을 이용하는게 가장 간단하고 하기 편함</li>
<li>sort를 보면 하나만 입력을 받으면 자체를 비교하게 되고 두개를 입력받으면 comparator??<br>두번째 파라미터는 comparator를 구현한 람다식이라는 것을 알고 있다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, (o1, o2) -&gt; o1.substring(<span class="number">3</span>).compareTo(o2.substring(<span class="number">3</span>)));</span><br><span class="line">       <span class="comment">// 이게 비즈니스로직 동작했으면 하는 코드만 작성하는 것</span></span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Comparable 인터페이스를 이용한 방법</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hansol</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Hansol</span>&gt;&#123;</span></span><br><span class="line">     <span class="comment">//String 을 상속이 안되서 따로 컴포지션해서 사용했다?</span></span><br><span class="line">     String value;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">public</span> Hansol(String value) &#123;</span><br><span class="line">           <span class="built_in">this</span>.value = value;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> compareTo(Hansol o) &#123;</span><br><span class="line">         <span class="keyword">return</span> value.substring(<span class="number">1</span>).compareTo(o.value.substring(<span class="number">1</span>));</span><br><span class="line">         <span class="comment">// 자기자신이갖고있는 value랑 외부에서들어온 객체 value랑 비교를 함.</span></span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;                      <span class="comment">//스트링이 됬다면 이런 부부느 안해도 됬다.</span></span><br><span class="line">Hansol[] hansols = &#123;<span class="keyword">new</span> Hansol(<span class="string">&quot;fast&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;campus&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;backend&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;java&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;choigo&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;best&quot;</span>),<span class="keyword">new</span> Hansol(<span class="string">&quot;people&quot;</span>)&#125;;</span><br><span class="line">Arrays.sort(hansols);</span><br><span class="line">System.out.println(Arrays.toString(hansols));</span><br></pre></td></tr></table></figure></li>
<li><p>String 이 상속이 가능했다면 이용한 방법</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 밑에 코드만 구현했으면 됬는데 string은 final로 되어있어서 상속이 안됨</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fansol</span> <span class="keyword">extends</span> <span class="title">String</span>&#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> compareTo(String o)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="람다식을-사용하기-위한-조건"><a href="#람다식을-사용하기-위한-조건" class="headerlink" title="람다식을 사용하기 위한 조건"></a>람다식을 사용하기 위한 조건</h2></li>
<li><p>위의 코드들은 Comparator 인터페이스를 구현 했는데 이번엔 직접 작성한 것이다.</p>
</li>
<li><p>람다식으로 사용하기 위해서는 단 하나의 추상 메소드를 가지고 있어야 한다.</p>
<ul>
<li>추상메소드가 2개이상이면 오류가 발생한다.</li>
<li>디폴트 메소드는 구현이 되어 있더라도 상관이 없다.</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 필수는 아니다. 하지만 적어주면 interface가 적합한지 확인해준다.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runner</span>&lt;<span class="title">T</span>&gt;&#123;</span></span><br><span class="line">    T run(); <span class="comment">// 추상메소드는 단 하나만 있어야 한다. runner라는 객체를 넣어줬을 때</span></span><br><span class="line">    <span class="comment">// run()을 실행할 때 우리가 값을 하나만 넣어서 보낼 때 하나만 있어야 밑에 문장이 run()라고 확신 할수있다.</span></span><br><span class="line">    <span class="comment">// T runTwo() // 추상메소드가 2개 이상이면 오류 발생</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> method()&#123;&#125; <span class="comment">// 디폴트 메소드가 구현이 되어 있더라도 상관이 없다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">                          <span class="comment">// ? 라고 적어주면 어떤 것이든 상관이 없다.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> useRunner(Runner&lt;?&gt; runner)&#123;</span><br><span class="line">        System.out.println(runner.run());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">                                 <span class="comment">//? 랑 같은 타입이여야 하는데 ?로써지면 뭐가 들어오든 상관 없음</span></span><br><span class="line"><span class="comment">//         class MyRun implements Runner&lt;String&gt;&#123; 익명 내부 클래스</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//             @Override</span></span><br><span class="line"><span class="comment">//             public String run() &#123;</span></span><br><span class="line"><span class="comment">//                 return null;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         useRunner(new MyRun());</span></span><br><span class="line">        useRunner(() -&gt; <span class="string">&quot;This is how to use runner.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="다양한-람다식-표현-형식"><a href="#다양한-람다식-표현-형식" class="headerlink" title="다양한 람다식 표현 형식"></a>다양한 람다식 표현 형식</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runner</span>&#123;</span></span><br><span class="line">    String run(String x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RunnerTwo</span>&#123;</span></span><br><span class="line">    String run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> useRunner(String x, Runner runner)&#123;</span><br><span class="line">        System.out.println(runner.run(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> useRunnerTwo(RunnerTwo runner)&#123;</span><br><span class="line">        System.out.println(runner.run());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">         <span class="comment">// 람다식의 표준 형식</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 여기서 메소드를 정의해준 것을 위에 run()에서 호출해서 프린트로 정의해주면 useRunner을 다시 여기서 호출해서 그 프린트값을 출력------------</span></span><br><span class="line">        useRunner(<span class="string">&quot;안녕하세요!&quot;</span>,(String x) -&gt; &#123;<span class="keyword">return</span> x;&#125;); <span class="comment">//입력 파라미터의 자료형 입력 (String x) = Runner run &#123;run(String x)&#125; , &#123;return x;&#125; = run(String x)??&#123; return x;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 입력 파라미터가 1개면 () 생략하는 형식</span></span><br><span class="line">        useRunner(<span class="string">&quot;안녕하세요!&quot;</span>, x -&gt; &#123;<span class="keyword">return</span> x;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  입력 파라미터가 없으면 () 생략불가 형식</span></span><br><span class="line">        useRunnerTwo(() -&gt; &#123;<span class="keyword">return</span> <span class="string">&quot;안녕&quot;</span>;&#125;); </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 여러 줄 작성할 때 중괄호 필수이다. 이 때 return도 필요하다.</span></span><br><span class="line">        useRunner(<span class="string">&quot;안녕하세요!&quot;</span>,(x)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> x; </span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Expression을 바로 쓰면 알아서 return을 해준다.(expression labmda)</span></span><br><span class="line">        <span class="comment">// 한 줄로만 처리되는 expression이라면 세미콜론 없이 처리 가능.</span></span><br><span class="line">        useRunner(<span class="string">&quot;안녕&quot;</span>,x-&gt;x); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="람다식과-익명-클래스-객체가-동일한-것은-아니다라는-것의-증명"><a href="#람다식과-익명-클래스-객체가-동일한-것은-아니다라는-것의-증명" class="headerlink" title="람다식과 익명 클래스 객체가 동일한 것은 아니다라는 것의 증명"></a>람다식과 익명 클래스 객체가 동일한 것은 아니다라는 것의 증명</h2><ul>
<li>람다식과 익명 내부 클래스가 비슷한 것이라고 했는데 각각 구현을 해서 this를 출력해보니 결과 값이 다르게 나온다.<ul>
<li>이유는 익명 내부 클래스로 구현을 하면 익명 내부 클래스의 객체가 생성이 되서 this가 그 객체를 가리키지만,<br>람다식은 다르게 객체가 만들어지지 않아 Main의 객체가 만들어진다. </li>
</ul>
</li>
<li>이 부분만 다르고 완전히 똑같다고 생각하면 된다.  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFoo</span>&#123;</span></span><br><span class="line">    String method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> funtionalMethod(IFoo foo)&#123;</span><br><span class="line">        System.out.println(foo.method());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> methodA()&#123;</span><br><span class="line">        <span class="comment">// 그외에는 둘이 완전히 똑같다고 생각하면된다 this만 다르다고 생각하면 된다.</span></span><br><span class="line">        funtionalMethod(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this&quot;</span>+ <span class="built_in">this</span>); <span class="comment">// 이 this가 왜 Main의 객체?</span></span><br><span class="line">            <span class="comment">// 익명클래스와 다르게 람다식은 익명클래스와 달리 클래스가 만들어지지 않는다.</span></span><br><span class="line">            <span class="comment">// 함수형 인터페이스로 동작을 한다.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;OuterClass.this&quot;</span>+Main.<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Lambad expression used.&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">       <span class="comment">// 위 아래 출력 값이 다르다. this의 출력값이 다르다</span></span><br><span class="line">        funtionalMethod(<span class="keyword">new</span> IFoo() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String method() &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;this&quot;</span>+ <span class="built_in">this</span>); <span class="comment">// 익명 클래스의 객체가 this가 된다.</span></span><br><span class="line">                <span class="comment">// 익명클래스를사용할 때 실제로 익명클래스가 만들어지고 사용이되서 넣어진다는게 증명이된다.</span></span><br><span class="line">                System.out.println(<span class="string">&quot;OuterClass.this&quot;</span>+Main.<span class="built_in">this</span>); <span class="comment">//외부 클래스인 Main 객체의 this</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Anonymous local inner class used.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">new</span> Main().methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="표준-함수형-인터페이스"><a href="#표준-함수형-인터페이스" class="headerlink" title="표준 함수형 인터페이스"></a>표준 함수형 인터페이스</h1></li>
<li>자바 8부터 표준 API로 제공되는 함수형 인터페이스<ul>
<li>java.util.function 패키지에 포함되어 있다.</li>
<li>매개타입으로 사용되어 람다식을 매개값으로 대입할 수 있도록 해준다.</li>
</ul>
</li>
<li>자주 사용되는 함수형 인터페이스를 정의해 둔 API</li>
<li>Consumer, Supplier, Function, Operation, Predicate 계열이 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>계열</th>
<th>입력</th>
<th>출력</th>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer</td>
<td>O</td>
<td>X</td>
<td>void accept(T)</td>
<td>입력을 소비</td>
</tr>
<tr>
<td>Supplier</td>
<td>X</td>
<td>O</td>
<td>T get()</td>
<td>출력을 공급</td>
</tr>
<tr>
<td>Function</td>
<td>O</td>
<td>O</td>
<td>T apply(R)</td>
<td>입력 -&gt; 출력 함수 매핑</td>
</tr>
<tr>
<td>Operation</td>
<td>O</td>
<td>O</td>
<td>T apply(T)</td>
<td>입력을 연산하여 동일 타입의 출력으로 리턴</td>
</tr>
<tr>
<td>Predicate</td>
<td>O</td>
<td>boolean</td>
<td>boolean test(T)</td>
<td>입력을 판단</td>
</tr>
</tbody></table>
<h2 id="표준-함수형-인터페이스의-종류"><a href="#표준-함수형-인터페이스의-종류" class="headerlink" title="표준 함수형 인터페이스의 종류"></a>표준 함수형 인터페이스의 종류</h2><h3 id="Consumer-계열"><a href="#Consumer-계열" class="headerlink" title="Consumer 계열"></a>Consumer 계열</h3><ul>
<li>파라미터 입력을 받아서 그것을 소비하는 Funtional Interface이다.<ul>
<li>소비라는 것은 함수가 이용된다 라고 생각하면 된다. 리턴이 되지 않고<br>함수 내에서 사용이 되고 새로운 출력으로 되는게 아니고 없어진다.<br>그래서 소비라고 의미를 부여한 것이다.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T></td>
<td>void accept(T t)</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>void accept(T t, U u)</td>
</tr>
<tr>
<td>IntConsumer</td>
<td>void accept(int value)</td>
</tr>
<tr>
<td>LongConsumer</td>
<td>void accept(long value)</td>
</tr>
<tr>
<td>DoubleConsumer</td>
<td>void accept(double value)</td>
</tr>
<tr>
<td>ObjIntConsumer<T></td>
<td>void accept(T t, int value)</td>
</tr>
<tr>
<td>ObjLongConsumer<T></td>
<td>void accept(T t, long value)</td>
</tr>
<tr>
<td>ObjDoubleConsumer<T></td>
<td>void accept(T t, double value)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = (s)-&gt; System.out.println(s);</span><br><span class="line">        <span class="comment">// &lt;String&gt;이므로 매개값 s는 String</span></span><br><span class="line">        consumer.accept(<span class="string">&quot;A String.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiConsumer&lt;String, String&gt; biConsumer = (t,u) -&gt; System.out.println(t+<span class="string">&quot;,&quot;</span>+u);</span><br><span class="line">        <span class="comment">// &lt;String,String&gt; 이므로 매개값 t와 u는 모두 String 타입</span></span><br><span class="line">        biConsumer.accept(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 오토박싱/ 언방식 사용하면 비효율적이다.</span></span><br><span class="line">        Consumer&lt;Integer&gt; integerConsumer = (x) -&gt; System.out.println(x);</span><br><span class="line">        integerConsumer.accept(<span class="number">10</span>); <span class="comment">// 값이 들어갈 땐 오토박싱 출력할 때 언박싱</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 효율적으로 하기 위해서 IntConsumer 제네릭이 아니다 기본형 타입</span></span><br><span class="line">        <span class="comment">// 기본형 입력을 하려고 할 경우, PConsumber (p: primitive type)을 사용 가능.</span></span><br><span class="line">        <span class="comment">// 주의! 오버로딩이 아니고 별도의 인터페이스이다. 최적화를 위해서 불편하더라도 별도로 만들어 놓은 것이다.</span></span><br><span class="line">        IntConsumer intConsumer = (x) -&gt; System.out.println(x);</span><br><span class="line">        intConsumer.accept(<span class="number">5</span>); <span class="comment">// 객체가 아니라 값을 입력을 받는 것이다. 기본자료형이니깐</span></span><br><span class="line">        <span class="comment">//LongConsumer, DoubleConsumer</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// t는 &lt;&gt;안에 값 x는 objIntconsumber의 int의 자료형이 들어간다.</span></span><br><span class="line">        ObjIntConsumer&lt;String&gt; objIntConsumer = (t,x) -&gt; System.out.println(t + <span class="string">&quot;: &quot;</span>+ x);</span><br><span class="line">        objIntConsumer.accept(<span class="string">&quot;x&quot;</span>,<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// ObjLongConsumer,ObjDoubleConsumer</span></span><br><span class="line">        <span class="comment">// 총 4가지 타입이 있다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Supplier-계열"><a href="#Supplier-계열" class="headerlink" title="Supplier 계열"></a>Supplier 계열</h3><ul>
<li>아무런 입력을 받지 않고, 값을 하나 반환하는 함수형 인터페이스이다.</li>
<li>자료를 ‘공급’하는 공급자 역학을 한다.</li>
<li>외부로 데이터를 리턴해주는 역할을 한다.<ul>
<li>getXXX() 메소드 사용</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Supplier<T></td>
<td>T get()</td>
</tr>
<tr>
<td>BooleanSupplier</td>
<td>boolean getAsBoolean()</td>
</tr>
<tr>
<td>IntSupplier</td>
<td>int getAsInt()</td>
</tr>
<tr>
<td>LongSupplier</td>
<td>long getAsLong()</td>
</tr>
<tr>
<td>DoubleSupplier</td>
<td>double getAsDouble()</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.BooleanSupplier;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntSupplier;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;A String&quot;</span>;<span class="comment">//입력을 받지 않기때문에 ()이 필요하다.</span></span><br><span class="line">        System.out.println(supplier.get()); <span class="comment">// get()을 해서 출력을 한다.</span></span><br><span class="line">        <span class="comment">// BiSupperlier는 입력은 여러 개 할 수 있지만, 출력은 하나 밖에 못하기 때문에 없다.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Supplier는 P Type 계열에서 getAsP 메소드로 정의가 된다. primitive</span></span><br><span class="line">        <span class="comment">// 메소드가 다르다. getAsInt()...</span></span><br><span class="line">        BooleanSupplier boolsup = () -&gt; <span class="literal">true</span>;</span><br><span class="line">        System.out.println(boolsup.getAsBoolean()); <span class="comment">// 이것은 getAsBoolean()으로 출력한다.</span></span><br><span class="line">        <span class="comment">// IntSupplier, LongSupplier, DoubleSupplier</span></span><br><span class="line"></span><br><span class="line">        IntSupplier rollDice = () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//0~6까지 나와서 6은 나오지 않음 0~5까지만 실제 값이 나온다.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(rollDice.getAsInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        IntSupplier intSupp = () -&gt; x; <span class="comment">//로컬변수에도 접근할 수 있다.</span></span><br><span class="line">        <span class="comment">// 람다식을 활용할 때 모든 변수에 접근하여 활용할 수 있다.</span></span><br><span class="line">        <span class="comment">// 고정되어있는 값뿐만아니라 동적으로도 주변 값들을 공급할 수 있다.</span></span><br><span class="line">        <span class="comment">// 그래서 supplier가 나름대로의 의미가 있다??</span></span><br><span class="line">        System.out.println(intSupp.getAsInt());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Funtion-계열"><a href="#Funtion-계열" class="headerlink" title="Funtion 계열"></a>Funtion 계열</h3><ul>
<li>Mapping : 입력 -&gt;  출력을 연결하는 함수형 인터페이스</li>
<li>입력 타입과 출력 타입은 다를 수 있다.(다를 수 있다라는건 같을 수도 있다는 말도 된다.)</li>
<li>매개값을 리턴값으로 매핑(타입변환)하는 역할을 한다.<ul>
<li>applyXXXX() 메소드 사용.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Function&lt;T, R&gt;</td>
<td>R apply(T t)</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U, R&gt;</td>
<td>R apply(T t, U u)</td>
</tr>
<tr>
<td>PFunction<R></td>
<td>R apply(p value)</td>
</tr>
<tr>
<td>PtoQFunction</td>
<td>q applyAsQ(p value)</td>
</tr>
<tr>
<td>ToPFunction<T></td>
<td>p applyAsP(T t)</td>
</tr>
<tr>
<td>ToPBiFunction&lt;T, U&gt;</td>
<td>p applyAsP(T t, U u)</td>
</tr>
</tbody></table>
<ul>
<li><p>P, Q 는 기본 자료형(Primitive Type) : Int, Long, Double</p>
</li>
<li><p>p, q 는 기본 자료형(Primitive Type) : int, long, double</p>
</li>
<li><p>Funtion&lt;Student, String&gt; funtion = t-&gt; {return t.getName()};</p>
<ul>
<li>&lt;Student,String&gt;이므로 매개값 t는 Student 타입이고 리턴 값은String 타입이다.</li>
<li>Student 객체를 String으로 매핑한 예제</li>
</ul>
</li>
<li><p>ToIntFuntion<Student> funtion = t -&gt; {return t.getScore();}</p>
<ul>
<li><Student> 이므로 매개값 t는 Student 타입이고 리턴값은 int 타입 고정</li>
<li>Student 객체를 int로 매핑한 예제 </li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Function&lt;String,Integer&gt; func = (s) -&gt; s.length();</span><br><span class="line">        <span class="comment">// s 는 String타입, s.length() 는 Integer</span></span><br><span class="line">        System.out.println(func.apply(<span class="string">&quot;Strings&quot;</span>)); <span class="comment">//이것은 apply로 출력한다</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bi가 붙으면 &#x27;입력&#x27;을 2개 받을 수 있다는 의미이다.</span></span><br><span class="line">        BiFunction&lt;String,String,Integer&gt; biFunction = (s,u) -&gt; s.length() + u.length();</span><br><span class="line">        System.out.println(biFunction.apply(<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>)); <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// IntFunction&lt;R&gt;은 리턴 자료형</span></span><br><span class="line">        <span class="comment">// P type Funtion은 입력을 P타입으로 받는다.</span></span><br><span class="line">        IntFunction&lt;String&gt; intFunction = (value) -&gt; String.valueOf(value);<span class="comment">// &quot;&quot; + value도 가능.</span></span><br><span class="line">        System.out.println(intFunction.apply(<span class="number">512</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ToP Type Function은 출력을 P타입으로 한다.</span></span><br><span class="line">        ToIntFunction&lt;String&gt; funcFour = (s) -&gt; s.length(); <span class="comment">// 4:21</span></span><br><span class="line">        System.out.println(funcFour.applyAsInt(<span class="string">&quot;abcde&quot;</span>));</span><br><span class="line">        <span class="comment">// 출력이 P타입인 경우에는 AsP가 들어간다.!!!</span></span><br><span class="line">        <span class="comment">//ToIntBiFunction&lt;String,String&gt;// int 출력을 하는 Bi 함수</span></span><br><span class="line">        <span class="comment">// P: Int, Long, Double</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int 에서 double로 바꾸는 함수 PToQFunction : P -&gt; Q로 매핑하는 함수</span></span><br><span class="line">        IntToDoubleFunction funcfive;</span><br><span class="line">        <span class="comment">// IntToIntFunction은 없다. 동일한 것에 대해서는 다른게 있다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Operator-계열"><a href="#Operator-계열" class="headerlink" title="Operator 계열"></a>Operator 계열</h3><ul>
<li>입력받은 타입과 동일한 타입의 출력을 하는 함수형 인터페이스</li>
<li>Funtion 계열과 달리 입출력 타입이 다를 수 없다.</li>
<li>applyXXX() 메소드를 가지고 있고 매개값을 리턴값으로 매핑하는 역할보다는<br>매개값을 이용해서 연산을 수행한 후 동일한 타입으로 리턴값을 제공하는 역할을 한다.</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>UnaryOperator<T></td>
<td>T apply(T t)</td>
</tr>
<tr>
<td>BinaryOperator<T></td>
<td>T apply(T t1, T t2)</td>
</tr>
<tr>
<td>IntUnaryOperator</td>
<td>int applyAsInt(int value)</td>
</tr>
<tr>
<td>LongUnaryOperator</td>
<td>long applyAsLong(long value)</td>
</tr>
<tr>
<td>DoubleUnaryOperator</td>
<td>double applyAsDouble(double value)</td>
</tr>
<tr>
<td>IntBinaryOperator</td>
<td>int applyAsInt(int value1, int value2)</td>
</tr>
<tr>
<td>LongBinaryOperator</td>
<td>long applyAsLong(long value, long value2)</td>
</tr>
<tr>
<td>DoubleBinaryOperator</td>
<td>double applyAsDouble(double value, double value2)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.BinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntUnaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">// 그냥 operator는 없다.</span></span><br><span class="line">        <span class="comment">//입력이 1개 인 것을 Unary를 붙여서 표현</span></span><br><span class="line">        UnaryOperator&lt;String&gt; operator = s -&gt; s+<span class="string">&quot;.&quot;</span>; <span class="comment">//리턴타입을 따로 입력받지 않는다 입출력이 같으니깐</span></span><br><span class="line">        System.out.println(operator.apply(<span class="string">&quot;왔다&quot;</span>)); <span class="comment">// apply() 사용.</span></span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;String&gt; operator1 = (s1,s2) -&gt; s1 + s2;<span class="comment">//타입은 하나만 입력받게 되어있다. 출력은 동일한 타입이여야 하니깐?</span></span><br><span class="line">        System.out.println(operator1.apply(<span class="string">&quot;나&quot;</span>,<span class="string">&quot;왔다&quot;</span>));</span><br><span class="line"></span><br><span class="line">        IntUnaryOperator op = value -&gt; value*<span class="number">10</span>; <span class="comment">//타입을 받지 않는다 어차피 int입력 int출력이니</span></span><br><span class="line">        System.out.println(op.applyAsInt(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">// LongUnaryOperator, DoubleUnaryOperator</span></span><br><span class="line"></span><br><span class="line">        IntBinaryOperator ibo = (v1,v2) -&gt; v1 * v2;</span><br><span class="line">        System.out.println(ibo.applyAsInt(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">        <span class="comment">//LongBinaryOperator, DoubleBinaryOperator</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Predicate-계열"><a href="#Predicate-계열" class="headerlink" title="Predicate 계열"></a>Predicate 계열</h3><ul>
<li>논리 판단을 해주는 함수형 인터페이스</li>
<li>입력을 받아서 boolean 타입 출력을 반환한다.</li>
<li>매개변수와 boolean 리턴값이 있는 testXXX() 메소드를 가지고 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>메소드</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate<T></td>
<td>boolean test(T t)</td>
</tr>
<tr>
<td>BiPredicate&lt;T, U&gt;</td>
<td>boolean test(T t, U u)</td>
</tr>
<tr>
<td>IntPredicate</td>
<td>boolean test(int value)</td>
</tr>
<tr>
<td>LongPredicate</td>
<td>boolean test(long value)</td>
</tr>
<tr>
<td>DoublePredicate</td>
<td>boolean test(double value)</td>
</tr>
</tbody></table>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.BiPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = (s) -&gt; s.length() == <span class="number">4</span>; <span class="comment">// 조건식이 들어가야 한다.</span></span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;Four&quot;</span>)); <span class="comment">// test()를 사용한다 true or false 값 출력</span></span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;six&quot;</span>));</span><br><span class="line"></span><br><span class="line">        BiPredicate&lt;String, Integer&gt; pred2 = (s,v) -&gt; s.length() ==v;</span><br><span class="line">        System.out.println(pred2.test(<span class="string">&quot;abcd&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        System.out.println(pred2.test(<span class="string">&quot;abc&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        IntPredicate pred3 = x -&gt; x &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//LongPredicate, DoublePredicate asP출력은 존재하지 않는다.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="표준-함수형-인터페이스의-메소드"><a href="#표준-함수형-인터페이스의-메소드" class="headerlink" title="표준 함수형 인터페이스의 메소드"></a>표준 함수형 인터페이스의 메소드</h2><h3 id="andThen-compose"><a href="#andThen-compose" class="headerlink" title="andThen(), compose()"></a>andThen(), compose()</h3><ul>
<li><p>두 개 이상의 함수형 인터페이스를 연결하기 위해서 사용한다.</p>
<ul>
<li><p><code>A.andThen(B)</code> : A를 먼저 실행하고 B를 실행, Consumer, Function, Operator 계열의 default method로 구현</p>
</li>
<li><p>Consumer의 순차적 연결</p>
<ul>
<li>Consumer 종류의 함수적 인터페이스는 처리 결과를 리턴하지 않기 때문에<br>andThen()과 compose() 디폴트 메소드는 함수적인터페이스의 호출 순서만 정한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c0 = s -&gt; System.out.println(<span class="string">&quot;c0 :&quot;</span> + s);</span><br><span class="line">Consumer&lt;String&gt; c1 = s -&gt; System.out.println(<span class="string">&quot;c1 :&quot;</span> + s);</span><br><span class="line">Consumer&lt;String&gt; c2 = c0.andThen(c1);</span><br><span class="line">c2.accept(<span class="string">&quot;String&quot;</span>); <span class="comment">//동일한 스트링을 출력한다.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>A.compose(B)</code> : B를 먼저 실행하고 A를 실행, Function, Operator 계열의 default method로 구현</p>
</li>
<li><p>Function의 순차적 연결</p>
<ul>
<li>Function과 Operator 종류의 함수적 인터페이스는 먼저 실행한 함수적 인터페이스의<br>결과를 다음 함수적 인터페이스의 매개값으로 넘겨주고, 최종처리결과를 리턴한다.</li>
</ul>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function 계열은 입력-&gt;출력 ==&gt; 입력-&gt; 출력 타입이 연쇄 되어야 한다.</span></span><br><span class="line">Function&lt;String, Integer&gt; func1 = s -&gt; s.length();</span><br><span class="line">Function&lt;Integer, Long&gt; func2 = value -&gt; (<span class="keyword">long</span>)value;</span><br><span class="line"><span class="comment">// func1의 입력이 String, 출력이 Integer이니깐, andThen()의 입력은 Integer여야 한다.</span></span><br><span class="line">Function&lt;String,Long&gt; func3 = func1.andThen(func2);</span><br><span class="line">System.out.println(func3.apply(<span class="string">&quot;four&quot;</span>));</span><br><span class="line"></span><br><span class="line">Function&lt;String, Long&gt; func4 = func2.compose(func1);</span><br><span class="line">System.out.println(func4.apply(<span class="string">&quot;four&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="and-or-negeate-isEqual"><a href="#and-or-negeate-isEqual" class="headerlink" title="and(), or(), negeate(), isEqual()"></a>and(), or(), negeate(), isEqual()</h3></li>
<li><p>Predicate 계열의 기본 메소드</p>
<ul>
<li>and(), or(), negate()</li>
<li>&amp;&amp; , ||, ! 연산자의 동작을 한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체에서 메소드로 접근한다.</span></span><br><span class="line">DoublePredicate p0 = x -&gt; x &gt; <span class="number">0.5</span>;</span><br><span class="line">DoublePredicate p1 = x -&gt; x &lt; <span class="number">0.7</span>;</span><br><span class="line">DoublePredicate p2 = p0.and(p1);</span><br><span class="line">DoublePredicate p3 = p0.or(p1); </span><br><span class="line">DoublePredicate p4 = p0.negate();</span><br><span class="line">System.out.println(p0.test(<span class="number">0.9</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(p1.test(<span class="number">0.9</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(p2.test(<span class="number">0.9</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(p3.test(<span class="number">0.9</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(p4.test(<span class="number">0.9</span>)); <span class="comment">// false not p0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Predicate 계열의 클래스 메소드</p>
<ul>
<li>isEqual()<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; eq = Predicate.isEqual(<span class="string">&quot;String&quot;</span>);</span><br><span class="line"><span class="comment">// 함수형 인터페이스를 사용할 수 있다. 람다식 사용 x</span></span><br><span class="line"><span class="comment">// 들어오는 String이랑 eq랑 같은지 테스트해주는 함수형 인터페이스를 리턴해줌</span></span><br><span class="line">System.out.println(eq.test(<span class="string">&quot;String&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(eq.test(<span class="string">&quot;String!&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="minBy-maxBy"><a href="#minBy-maxBy" class="headerlink" title="minBy(), maxBy()"></a>minBy(), maxBy()</h3></li>
</ul>
</li>
<li><p>BinaryOperator 클래스의 클래스 메소드</p>
<ul>
<li>Comparator<T>를 파라미터로 받아 최소값/최대값을 구하는 BinaryOperator<T>를 리턴<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        BinaryOperator&lt;String&gt; minBy = BinaryOperator.minBy((o1,o2)-&gt; o1.length() &gt; o2.length() ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        BinaryOperator&lt;String&gt; maxBy = BinaryOperator.maxBy((o1,o2)-&gt; o1.length() &gt; o2.length() ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BinaryOperator.minBy((String o1,String o2)-&gt; o1.length()+o2.length()); 이것도 가능</span></span><br><span class="line">        <span class="comment">// 어떤걸 받아 줄건지 써줘야 한다.</span></span><br><span class="line">        <span class="comment">// 앞에 String 타입을 넣어주면 뒤에서 o1,o2가 String 이라는 것을 추론할 수 있다.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(minBy.apply(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cd&quot;</span>)); <span class="comment">// 더 작은게 출력됨</span></span><br><span class="line">        System.out.println(maxBy.apply(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cd&quot;</span>)); <span class="comment">// 더 큰게 출력됨</span></span><br><span class="line">        System.out.println(minBy.apply(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;cde&quot;</span>)); <span class="comment">// abc가 출려됨</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="메소드-참조-람다식에-메소드-생성자-사용하는-예"><a href="#메소드-참조-람다식에-메소드-생성자-사용하는-예" class="headerlink" title="메소드 참조 (람다식에 메소드/생성자 사용하는 예)"></a>메소드 참조 (람다식에 메소드/생성자 사용하는 예)</h3></li>
</ul>
</li>
<li><p>메소드를 참조해서 매개변수의 정보 및 리턴타입을 알아내어<br> 람다식에서 불필요한 매개변수를 제거하는 것이 목적이다.</p>
</li>
<li><p>람다식에 기존에 구현되어 있는 내용을 재사용하고자 할 때 사용</p>
<ul>
<li>함수형 인터페이스를 재사용하지 못하는 단점을 보완하기 위해서 사용한다.</li>
</ul>
</li>
<li><p>종종 람다식은 기존 메소드를 단순하게 호출만 하는 경우가 있다.<br>(left, right) -&gt; Math.max(left,right);   ==&gt; Math::max (메소드 참조)</p>
</li>
<li><p>메소드 참조도 람다식과 마찬가지로 인터페이스의 익명 구현 객체로 생성이 된다.</p>
<ul>
<li>타겟 타입에서 추상 메소드의 매개변수 및 리턴 타입에 따라 메소드 참조도 달라진다.</li>
<li>예) IntBinaryOperator 인터페이스는 두 개의 int 매개값을 받아 int값을 리턴하므로<br>동일하게 매개값과 리턴타입을 갖는 Math 클래스의 max()메소드를 참조할 수 있다.<br>IntBinaryOperator operator  = Mat::max;<h4 id="정적-메소드-참조-와-인스턴스-메소드-참조"><a href="#정적-메소드-참조-와-인스턴스-메소드-참조" class="headerlink" title="정적 메소드 참조 와 인스턴스 메소드 참조"></a>정적 메소드 참조 와 인스턴스 메소드 참조</h4><h5 id="ClassName-instanceMethod"><a href="#ClassName-instanceMethod" class="headerlink" title="ClassName::instanceMethod"></a>ClassName::instanceMethod</h5></li>
</ul>
</li>
<li><p>첫번째 파라미터를 객체로, 두번째 파라미터를 메소드 입력으로 사용한다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(strings, <span class="attr">String:</span>:compareTo);</span><br></pre></td></tr></table></figure>
<h5 id="ClassName-classMethod"><a href="#ClassName-classMethod" class="headerlink" title="ClassName::classMethod"></a>ClassName::classMethod</h5></li>
<li><p>클래스 메소드의 입력으로 모든 파라미터가 사용됨</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; parser = <span class="attr">Integer:</span>:parseInt;</span><br></pre></td></tr></table></figure>
<h5 id="instance-instanceMethod"><a href="#instance-instanceMethod" class="headerlink" title="instance::instanceMethod"></a>instance::instanceMethod</h5></li>
<li><p>주어진 객체의 메소드를 호출</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">&quot;StringA&quot;</span>;</span><br><span class="line">Predicate&lt;String&gt; pred = <span class="attr">string:</span>:equals;</span><br><span class="line">System.out.println(pred.apply(<span class="string">&quot;StringA&quot;</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticMethod(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> instanceMethod(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferencesExam</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        IntBinaryOperator operator;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 정적 메소드 참조</span></span><br><span class="line">        operator = (x,y) -&gt; Calculator.staticMethod(x,y);</span><br><span class="line">        System.out.println(<span class="string">&quot;결과1:&quot;</span>+operator.applyAsInt(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        operator = <span class="attr">Calculator:</span>:staticMethod;</span><br><span class="line">        System.out.println(<span class="string">&quot;결과2:&quot;</span>+operator.applyAsInt(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 인스턴스 메소드 참조</span></span><br><span class="line"></span><br><span class="line">        Calculator obj = <span class="keyword">new</span> Calculator();</span><br><span class="line">        operator = (x,y) -&gt; obj.instanceMethod(x,y);</span><br><span class="line">        System.out.println(<span class="string">&quot;결과3:&quot;</span>+operator.applyAsInt(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">        operator = <span class="attr">obj:</span>:instanceMethod;</span><br><span class="line">        System.out.println(<span class="string">&quot;결과4:&quot;</span>+operator.applyAsInt(<span class="number">7</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="매개변수의-메소드-참조"><a href="#매개변수의-메소드-참조" class="headerlink" title="매개변수의 메소드 참조"></a>매개변수의 메소드 참조</h4><ul>
<li>(a,b) -&gt; {a.instanceMethod(b);}  ==&gt; 클래스 :: instanceMethod<ul>
<li>이 때 클래스는 a의 타입이 된다. a의타입이 string이면 string이 된다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgumentMethodReferencesExam</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        ToIntBiFunction&lt;String,String&gt; function;</span><br><span class="line"></span><br><span class="line">        function = (a,b) -&gt; a.compareToIgnoreCase(b);</span><br><span class="line">        print(function.applyAsInt(<span class="string">&quot;java8&quot;</span>,<span class="string">&quot;JAVA8&quot;</span>));</span><br><span class="line">        function = <span class="attr">String:</span>:compareToIgnoreCase;</span><br><span class="line">        print(function.applyAsInt(<span class="string">&quot;kplus&quot;</span>,<span class="string">&quot;JAVA8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> print(<span class="keyword">int</span> order) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;사전순으로 나옵니다.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(order == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;동일한 문자열 입니다.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;사전역순으로 나옵니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="생성자-참조"><a href="#생성자-참조" class="headerlink" title="생성자 참조"></a>생성자 참조</h4><h5 id="ClassName-new"><a href="#ClassName-new" class="headerlink" title="ClassName::new"></a>ClassName::new</h5></li>
</ul>
</li>
<li>생성자를 이용하여 객체를 생성하는 람다식<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;String&gt; func = <span class="attr">String:</span>:<span class="keyword">new</span>;</span><br><span class="line">String string = func.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Member() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Member() 실행&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Member(String id) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Member(String id) 실행&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Member(String name, String id) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Member(String name, String id) 실행&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorReferencesExam</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Function&lt;String,Member&gt; function1= <span class="attr">Member:</span>:<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">        Member member1 = function1.apply(<span class="string">&quot;angel&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;String,String,Member&gt; function2 = <span class="attr">Member:</span>:<span class="keyword">new</span>;</span><br><span class="line">        Member member2 = function2.apply(<span class="string">&quot;홍길동&quot;</span>,<span class="string">&quot;hong&quot;</span>);</span><br><span class="line">      <span class="comment">// 매개변수가 어떻게 제공이 되는야에 따라서 어떤생성자가 생성이되는지 달라진다.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ClassName-new-1"><a href="#ClassName-new-1" class="headerlink" title="ClassName[]::new"></a>ClassName[]::new</h5><ul>
<li>배열을 생성하는 람다식<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;String[]&gt; func = String[]::<span class="keyword">new</span>;</span><br><span class="line">String [] strings = func.apply(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>


</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/27/Java/JavaAdvanced/Java-LambdaExpression/" data-id="ckgxjhqeb002ocwu27w9q65sr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Subject/Homework10/GenericList" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/Java/Subject/Homework10/GenericList/" class="article-date">
  <time datetime="2020-09-25T12:16:07.140Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/Java/Subject/Homework10/GenericList/">Subject_Day10_GenericRect</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="과제-Day10"><a href="#과제-Day10" class="headerlink" title="과제 Day10"></a>과제 Day10</h1><h2 id="GenericList구현하기"><a href="#GenericList구현하기" class="headerlink" title="GenericList구현하기"></a>GenericList구현하기</h2><h3 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h3><ul>
<li><p>List<T> 제네릭 인터페이스를 구현하여 ArrayList<T> 제네릭을 완성하시오.</p>
</li>
<li><p>List는 순서가 있는 연속된 값으로, List 인터페이스에 선언되어 있는 메소드의 기능은 아래와 같다.</p>
<ul>
<li>append(): List의 마지막에 value를 삽입한다.</li>
<li>prepend(): List의 시작점에 value를 삽입한다. 기존의 데이터를 한 칸씩 뒤로 옮긴다.</li>
<li>insert(): index에 value를 삽입한다. 기존 데이터를 한 칸씩 뒤로 옮긴다.</li>
<li>remove(): index의 value를 삭제한다. 기존 데이터를 한 칸씩 앞으로 당긴다.</li>
<li>get(): index의 value를 반환한다.</li>
<li>length(): List의 길이를 출력한다.</li>
</ul>
</li>
<li><p>ArrayList<T>는 Object []를 이용하여 List<T>를 구현한다.</p>
<ul>
<li>생성자에서는 capacity를 입력받으며, 배열의 크기가 부족할 때마다 2배씩 증가시킨다.</li>
</ul>
<h3 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">void</span> append(T value);</span><br><span class="line">    <span class="keyword">void</span> prepend(T value);</span><br><span class="line">    <span class="keyword">void</span> insert(<span class="keyword">int</span> index, T value);</span><br><span class="line">    <span class="keyword">void</span> remove(<span class="keyword">int</span> index);</span><br><span class="line">    T get(<span class="keyword">int</span> index);</span><br><span class="line">    <span class="keyword">int</span> length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> Object[] integers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        integers = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> expandCapacity(<span class="keyword">int</span> offset) &#123;</span><br><span class="line">        Object [] newIntegers = <span class="keyword">new</span> Object[capacity * <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(integers, <span class="number">0</span>, newIntegers, offset, capacity);</span><br><span class="line">        integers = newIntegers;</span><br><span class="line">        capacity *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> expandCapacity() &#123;</span><br><span class="line">        expandCapacity(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> append(T value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(length == capacity)&#123;</span><br><span class="line">            expandCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        integers[length++] = value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> prepend(T value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length == capacity) &#123;</span><br><span class="line">            expandCapacity(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (length &gt;= <span class="number">0</span>) System.arraycopy(integers, <span class="number">0</span>, integers, <span class="number">1</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">        integers[<span class="number">0</span>] =  value;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> insert(<span class="keyword">int</span> index, T value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length == capacity) &#123;</span><br><span class="line">            expandCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= length &amp;&amp; length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(integers, index, integers, index + <span class="number">1</span>, length - index);</span><br><span class="line">        &#125;</span><br><span class="line">        integers[index] =  value;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> remove(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; length &amp;&amp; length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(integers, index + <span class="number">1</span>, integers, index, length - index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        length--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T get(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) integers[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Integer.valueOf(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length() &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericList</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printList(ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>, list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            list.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        printList(list);</span><br><span class="line"></span><br><span class="line">        list.remove(<span class="number">5</span>);</span><br><span class="line">        printList(list);</span><br><span class="line"></span><br><span class="line">        list.prepend(<span class="number">1</span>);</span><br><span class="line">        list.prepend(<span class="number">2</span>);</span><br><span class="line">        list.prepend(<span class="number">3</span>);</span><br><span class="line">        printList(list);</span><br><span class="line"></span><br><span class="line">        list.insert(<span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line">        printList(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/25/Java/Subject/Homework10/GenericList/" data-id="ckgxjhqe1002kcwu24qbu3frk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Subject/Homework09/List" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/Java/Subject/Homework09/List/" class="article-date">
  <time datetime="2020-09-25T12:10:43.092Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/Java/Subject/Homework09/List/">Subject_Day09_Rect</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="과제-Day9"><a href="#과제-Day9" class="headerlink" title="과제 Day9"></a>과제 Day9</h1><h2 id="List-구현하기"><a href="#List-구현하기" class="headerlink" title="List 구현하기"></a>List 구현하기</h2><h3 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h3><ul>
<li><p>List 인터페이스를 구현하여 IntArrayList 클래스를 완성하시오.</p>
</li>
<li><p>List는 순서가 있는 연속된 값으로, List 인터페이스에 선언되어 있는 메소드의 기능은 아래와 같다.</p>
<ul>
<li>append(): List의 마지막에 value를 삽입한다.</li>
<li>prepend(): List의 시작점에 value를 삽입한다. 기존의 데이터를 한 칸씩 뒤로 옮긴다.</li>
<li>insert(): index에 value를 삽입한다. 기존 데이터를 한 칸씩 뒤로 옮긴다.</li>
<li>remove(): index의 value를 삭제한다. 기존 데이터를 한 칸씩 앞으로 당긴다.</li>
<li>get(): index의 value를 반환한다.</li>
<li>length(): List의 길이를 출력한다.</li>
</ul>
</li>
<li><p>IntArrayList는 int []를 이용하여 List를 구현한다.</p>
<ul>
<li>생성자에서는 capacity를 입력받으며, 배열의 크기가 부족할 때마다 2배씩 증가시킨다.</li>
</ul>
<h3 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> append(<span class="keyword">int</span> value);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> prepend(<span class="keyword">int</span> value);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> insert(<span class="keyword">int</span> index, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> remove(<span class="keyword">int</span> index);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> get(<span class="keyword">int</span> index);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArrayList</span> <span class="keyword">implements</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> is_empty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.last == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IntArrayList(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.last = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.first = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> append(<span class="keyword">int</span> value) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last == capacity)&#123;</span><br><span class="line">            <span class="keyword">int</span> [] new_array = <span class="keyword">new</span> <span class="keyword">int</span>[capacity * <span class="number">2</span>];</span><br><span class="line">            System.arraycopy(array,<span class="number">0</span>,new_array,<span class="number">0</span>,array.length);</span><br><span class="line">            array = new_array;</span><br><span class="line">            capacity = capacity *<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[last++] = value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> prepend(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last == capacity)&#123;</span><br><span class="line">            <span class="keyword">int</span> [] new_array = <span class="keyword">new</span> <span class="keyword">int</span>[capacity * <span class="number">2</span>];</span><br><span class="line">            System.arraycopy(array,<span class="number">0</span>,new_array,<span class="number">0</span>,array.length);</span><br><span class="line">            array = new_array;</span><br><span class="line">            capacity = capacity *<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=last+<span class="number">1</span>; i&gt;first; i--)&#123;</span><br><span class="line">            array[i] = array[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[first] = value;</span><br><span class="line">        last++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> insert(<span class="keyword">int</span> index, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last == capacity)&#123;</span><br><span class="line">            <span class="keyword">int</span> [] new_array = <span class="keyword">new</span> <span class="keyword">int</span>[capacity * <span class="number">2</span>];</span><br><span class="line">            System.arraycopy(array,<span class="number">0</span>,new_array,<span class="number">0</span>,array.length);</span><br><span class="line">            array = new_array;</span><br><span class="line">            capacity = capacity *<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=last+<span class="number">1</span>; i&gt;index; i--)&#123;</span><br><span class="line">            array[i] = array[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = value;</span><br><span class="line">        last++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> remove(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_empty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;배열이 비어있습니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=index; i&lt;last; i++)&#123;</span><br><span class="line">            array[i] = array[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[last] = <span class="number">0</span>;</span><br><span class="line">        last--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> get(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> length() &#123;</span><br><span class="line">        System.out.println(last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line"></span><br><span class="line">        IntArrayList ial = <span class="keyword">new</span> IntArrayList(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line">            ial.append(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/25/Java/Subject/Homework09/List/" data-id="ckgxjhqdz002jcwu2esqhgbut" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Subject/Homework07/Rect" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/Java/Subject/Homework07/Rect/" class="article-date">
  <time datetime="2020-09-25T12:06:47.869Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/Java/Subject/Homework07/Rect/">Subject_Day07_Rect</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="과제-Day7"><a href="#과제-Day7" class="headerlink" title="과제 Day7"></a>과제 Day7</h1><h2 id="Rect-구현하기"><a href="#Rect-구현하기" class="headerlink" title="Rect 구현하기"></a>Rect 구현하기</h2><h3 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h3><ul>
<li>아래 테스트 코드가 정상 동작하도록 클래스들을 완성하시오.</li>
<li>getArea(): 사각형의 넓이를 반환한다.</li>
<li>getCenterOfMass(): 사각형의 질량중심을 반환한다.</li>
<li>GetAllPoints(): 사각형의 네 점을 배열로 반환한다.</li>
<li>rot90(): Pivot을 기준으로 사각형을 90도 회전시킨다.</li>
</ul>
<h3 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2D(<span class="keyword">float</span> x, <span class="keyword">float</span> y) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="comment">// write codes here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%f, %f&quot;</span>,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectCore</span> &#123;</span></span><br><span class="line">    <span class="keyword">protected</span> Vector2D pos;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">float</span> w, h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RectCore(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> w, <span class="keyword">float</span> h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.pos = <span class="keyword">new</span> Vector2D(x, y);</span><br><span class="line">        <span class="built_in">this</span>.w = w;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="comment">// write codes here</span></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%f, %f, %f&quot;</span>,pos.toString(),w,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">RectCore</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Vector2D [] v2 = <span class="keyword">new</span> Vector2D[<span class="number">4</span>];</span><br><span class="line">    &#123;</span><br><span class="line">        v2[<span class="number">0</span>] = pos;</span><br><span class="line">        v2[<span class="number">1</span>] = <span class="keyword">new</span> Vector2D(pos.x,pos.y+h);</span><br><span class="line">        v2[<span class="number">2</span>] = <span class="keyword">new</span> Vector2D(pos.x+w,pos.y+h);</span><br><span class="line">        v2[<span class="number">3</span>] = <span class="keyword">new</span> Vector2D(pos.x+w,pos.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Rect(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> w, <span class="keyword">float</span> h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> getArea() &#123;</span><br><span class="line">        <span class="comment">// write codes here</span></span><br><span class="line">        <span class="keyword">float</span> area = w * h;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2D getCenterOfMass() &#123;</span><br><span class="line">        <span class="comment">// write codes here</span></span><br><span class="line">        <span class="keyword">float</span> a = (<span class="keyword">float</span>) (<span class="built_in">this</span>.pos.x + (w * <span class="number">0.5</span>));</span><br><span class="line">        <span class="keyword">float</span> b = (<span class="keyword">float</span>) (<span class="built_in">this</span>.pos.y + (h * <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector2D(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2D [] getAllPoints() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> rot90(Vector2D pivot) &#123;</span><br><span class="line">        <span class="comment">// write codes here</span></span><br><span class="line">        Vector2D [] v3 = <span class="keyword">new</span> Vector2D[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">float</span> x1 = (<span class="keyword">float</span>) ((<span class="keyword">float</span>)pivot.x - <span class="number">0.5</span>*h);</span><br><span class="line">        <span class="keyword">float</span> x2 = (<span class="keyword">float</span>) ((<span class="keyword">float</span>)pivot.x + <span class="number">0.5</span>*h);</span><br><span class="line">        <span class="keyword">float</span> y1 = (<span class="keyword">float</span>) ((<span class="keyword">float</span>)pivot.y - <span class="number">0.5</span>*w);</span><br><span class="line">        <span class="keyword">float</span> y2 = (<span class="keyword">float</span>) ((<span class="keyword">float</span>)pivot.y + <span class="number">0.5</span>*w);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        v3[<span class="number">0</span>] = <span class="keyword">new</span> Vector2D(x1,y1);</span><br><span class="line">        v3[<span class="number">1</span>] = <span class="keyword">new</span> Vector2D(x1,y2);</span><br><span class="line">        v3[<span class="number">2</span>] = <span class="keyword">new</span> Vector2D(x2,y2);</span><br><span class="line">        v3[<span class="number">3</span>] = <span class="keyword">new</span> Vector2D(x2,y1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;v2.length; i++)&#123;</span><br><span class="line">            System.out.println(v3[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="comment">// write codes here</span></span><br><span class="line">        <span class="keyword">return</span> v2[<span class="number">0</span>].toString() + <span class="string">&quot; &quot;</span>+ v2[<span class="number">1</span>].toString() + <span class="string">&quot; &quot;</span></span><br><span class="line">                +v2[<span class="number">2</span>].toString() + <span class="string">&quot; &quot;</span> + v2[<span class="number">4</span>].toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Rect rect = <span class="keyword">new</span> Rect(<span class="number">0.5</span>f, <span class="number">0.7</span>f, <span class="number">1.5</span>f, <span class="number">2.3</span>f);</span><br><span class="line">        System.out.println(<span class="string">&quot;Area: &quot;</span> + rect.getArea());</span><br><span class="line">        System.out.println(<span class="string">&quot;CoM: &quot;</span> + rect.getCenterOfMass());</span><br><span class="line">        System.out.println(<span class="string">&quot;All Points: &quot;</span> + Arrays.toString(rect.getAllPoints()));</span><br><span class="line"></span><br><span class="line">        rect.rot90(<span class="keyword">new</span> Vector2D(<span class="number">0.4</span>f, <span class="number">0.2</span>f));</span><br><span class="line">        System.out.println(<span class="string">&quot;Rotated rect: &quot;</span> + rect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/25/Java/Subject/Homework07/Rect/" data-id="ckgxjhqdu002fcwu2640hc0wf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Subject/Homework06/Vector3D" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/Java/Subject/Homework06/Vector3D/" class="article-date">
  <time datetime="2020-09-21T12:45:28.954Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/Java/Subject/Homework06/Vector3D/">Subject_Day06_Vector3D</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="과제-Day6"><a href="#과제-Day6" class="headerlink" title="과제 Day6"></a>과제 Day6</h1><h2 id="3차원-벡터-클래스-구현하기"><a href="#3차원-벡터-클래스-구현하기" class="headerlink" title="3차원 벡터 클래스 구현하기"></a>3차원 벡터 클래스 구현하기</h2><h3 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h3><ul>
<li><p>속성</p>
<ul>
<li>float타입의 x, y, z</li>
</ul>
</li>
<li><p>생성자</p>
<ul>
<li>Vector3D(float x, float y, float z)</li>
</ul>
</li>
<li><p>메소드</p>
<ul>
<li>x, y, z에 대한 getter 및 setter</li>
<li>add(): 벡터끼리의 덧셈, 실수와의 덧셈을 반환</li>
<li>sub(): 벡터끼리의 뺄셈, 실수와의 뺄셈을 반환</li>
<li>inner(): 두 벡터의 내적을 반환</li>
<li>mul(): 실수와의 곱을 반환</li>
<li>mag(): 벡터의 크기를 반환</li>
<li>print(): 벡터의 내용을 “(%.3f, %.3f, %.3f)\n” 형식으로 콘솔에 출력</li>
</ul>
</li>
</ul>
<h3 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector3D</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line"></span><br><span class="line">    Vector3D(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> getX() &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setX(<span class="keyword">float</span> x) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> getY() &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setY(<span class="keyword">float</span> y) &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> getZ() &#123;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setZ(<span class="keyword">float</span> z) &#123;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3D add(Vector3D v2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3D(<span class="built_in">this</span>.x + v2.x,<span class="built_in">this</span>.y + v2.y,<span class="built_in">this</span>.z + v2.z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Vector3D add(<span class="keyword">float</span> f) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3D(<span class="built_in">this</span>.x + f,<span class="built_in">this</span>.y + f,<span class="built_in">this</span>.z + f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3D sub(Vector3D v1) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3D(<span class="built_in">this</span>.x - v1.x,<span class="built_in">this</span>.y - v1.y,<span class="built_in">this</span>.z - v1.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3D sub(<span class="keyword">float</span> f) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3D( <span class="built_in">this</span>.x - f,<span class="built_in">this</span>.y - f,<span class="built_in">this</span>.z - f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> inner(Vector3D v2) &#123;</span><br><span class="line">        <span class="keyword">float</span> num = <span class="built_in">this</span>.x * v2.x + <span class="built_in">this</span>.y * v2.y + <span class="built_in">this</span>.z * v2.z;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3D mult(<span class="keyword">float</span> v) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x *= v;</span><br><span class="line">        <span class="built_in">this</span>.y *= v;</span><br><span class="line">        <span class="built_in">this</span>.z *= v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> mag() &#123;</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>) Math.sqrt(Math.pow(<span class="built_in">this</span>.x,<span class="number">2</span>)+Math.pow(<span class="built_in">this</span>.y,<span class="number">2</span>)+Math.pow(<span class="built_in">this</span>.z,<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> print()&#123;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;%.3f,%.3f,%.3f\n&quot;</span>,x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector3DTest</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Vector3D v1 = <span class="keyword">new</span> Vector3D(<span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">0.9</span>f);</span><br><span class="line">        Vector3D v2 = <span class="keyword">new</span> Vector3D(<span class="number">0.8</span>f, <span class="number">0.1</span>f, <span class="number">1.3</span>f);</span><br><span class="line"></span><br><span class="line">        v1.add(v2).print();</span><br><span class="line">        v2.sub(v1).print();</span><br><span class="line">        v1.add(<span class="number">0.2</span>f).print();</span><br><span class="line">        v2.sub(<span class="number">0.05</span>f).print();</span><br><span class="line">        System.out.println(v1.inner(v2));</span><br><span class="line">        v1.mult(<span class="number">1.2</span>f).print();</span><br><span class="line">        System.out.println(v2.mag());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/21/Java/Subject/Homework06/Vector3D/" data-id="ckgxjhqdx002hcwu27mmaatkf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Subject/Homework06/SingletonPattern" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/Java/Subject/Homework06/SingletonPattern/" class="article-date">
  <time datetime="2020-09-21T12:42:57.306Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/Java/Subject/Homework06/SingletonPattern/">Subject_Day06_SingletonPattern</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="과제-Day6"><a href="#과제-Day6" class="headerlink" title="과제 Day6"></a>과제 Day6</h1><h2 id="싱글톤-패턴-구하기"><a href="#싱글톤-패턴-구하기" class="headerlink" title="싱글톤 패턴 구하기"></a>싱글톤 패턴 구하기</h2><h3 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h3><ul>
<li>단 하나의 인스턴스만 존재할 수 있는 클래스 SingletonPattern을 구현하시오.</li>
<li>생성자를 외부에서 직접 호출할 수 없다.</li>
<li>정적 메소드인 getInstance() 메소드를 이용해 객체를 받아온다.</li>
<li>받아온 객체는 항상 같은 객체를 참조해야 한다.<h3 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h3></li>
<li>소프트웨어 디자인 패턴에서 싱글턴 패턴(Singleton pattern)을 따르는 클래스는,</li>
<li>생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고</li>
<li>최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.</li>
<li>이와 같은 디자인 유형을 싱글턴 패턴이라고 한다.<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPattern</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern instance = <span class="keyword">new</span> SingletonPattern();</span><br><span class="line">    <span class="keyword">private</span> SingletonPattern()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern getInstance()&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        SingletonPattern instanceOne = SingletonPattern.getInstance();</span><br><span class="line">        SingletonPattern instanceTwo = SingletonPattern.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instanceOne == instanceTwo); <span class="comment">// should be true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/21/Java/Subject/Homework06/SingletonPattern/" data-id="ckgxjhqdy002icwu2c8ih1oot" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Subject/Homework06/MyMath" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/Java/Subject/Homework06/MyMath/" class="article-date">
  <time datetime="2020-09-21T12:39:00.243Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/Java/Subject/Homework06/MyMath/">Subject_Day06_MyMath</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="과제-Day6"><a href="#과제-Day6" class="headerlink" title="과제 Day6"></a>과제 Day6</h1><h2 id="MyMath-클래스-구현하기"><a href="#MyMath-클래스-구현하기" class="headerlink" title="MyMath 클래스 구현하기"></a>MyMath 클래스 구현하기</h2><h3 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h3><ul>
<li>인스턴스를 생성할 수 없는 MyMath 클래스를 구현하시오.</li>
<li>MyMath 클래스는 다음 정적 변수를 가진다.</li>
<li>PI = 3.1415927;</li>
<li>E = 2.718281;</li>
<li>MyMath 클래스는 다음 정적 메소드를 가진다.</li>
<li>min - 정수 또는 실수를 여러개 입력받아 최소값을 구한다.</li>
<li>max - 정수 또는 실수를 여러개 입력받아 최대값을 구한다.</li>
<li>abs - 정수 또는 실수를 입력받아 절대값을 구한다.</li>
<li>floor - 실수를 입력받아 내림 연산한 정수를 출력한다.</li>
<li>ceil - 실수를 입력받아 올림 연산한 정수를 출력한다.<h3 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> PI =<span class="number">3.1415927</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> E = <span class="number">2.718281</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyMath()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> min(<span class="keyword">int</span>...params)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;params.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; params[i])&#123;</span><br><span class="line">            min = params[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">double</span> min(<span class="keyword">double</span>...params)&#123;</span><br><span class="line">        <span class="keyword">double</span> min = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;params.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; params[i])&#123;</span><br><span class="line">                min = params[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> max(<span class="keyword">int</span>...params)&#123;</span><br><span class="line">        <span class="keyword">int</span> max = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;params.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; params[i])&#123;</span><br><span class="line">                max = params[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> max(<span class="keyword">double</span>...params)&#123;</span><br><span class="line">        <span class="keyword">double</span> max = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;params.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; params[i])&#123;</span><br><span class="line">                max = params[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> abs(<span class="keyword">int</span> num1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            num1 = <span class="number">-1</span> * num1;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span>  num1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> abs(<span class="keyword">double</span> num1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            num1 = -num1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> floor(<span class="keyword">double</span> num)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.floor(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> ceil(<span class="keyword">double</span> num)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.ceil(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMathTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"><span class="comment">//         System.out.println(MyMath()); // should fail</span></span><br><span class="line">        System.out.println(MyMath.PI);</span><br><span class="line">        System.out.println(MyMath.E);</span><br><span class="line">        System.out.println(MyMath.min(<span class="number">2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">6</span>));</span><br><span class="line">        System.out.println(MyMath.max(<span class="number">7</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">-4</span>));</span><br><span class="line">        System.out.println(MyMath.abs(<span class="number">5</span>));</span><br><span class="line">        System.out.println(MyMath.abs(<span class="number">-2.3</span>));</span><br><span class="line">        System.out.println(MyMath.floor(<span class="number">-1.5232</span>));</span><br><span class="line">        System.out.println(MyMath.ceil(<span class="number">4.6452</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://limjoonchul.github.io/2020/09/21/Java/Subject/Homework06/MyMath/" data-id="ckgxjhqdv002gcwu23j2i5nsy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/31/Java/JavaAdvanced/Java-MultiThread/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/31/Java/JavaAdvanced/Java-RegularExpression/">Java_RegularExpression(정규표현식)</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-StockPrice/">AlgorithmSolution_StockPrice(주식가격)</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-NotFinishedPlayer/">AlgorithmSolution_완주하지 못한 선수</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Algorithm/Solution-PhoneNumberList/">AlgorithmSolution_전화 번호 목록</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Facamp lim<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>